import { TypedDocumentNode as DocumentNode } from "@graphql-typed-document-node/core";
export declare type Maybe<T> = T | null;
export declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export declare type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export declare type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    /** Represents a date and time in ISO 8601 format. Accepts shortcuts like `2021` to represent midnight Fri Jan 01 2021. Also accepts ISO 8601 durations strings which are added to the current date to create the represented date (e.g '-P2W1D' represents the date that was two weeks and 1 day ago) */
    DateTime: Date;
    /** The `JSON` scalar type represents arbitrary values as *stringified* JSON */
    JSON: Record<string, unknown>;
    /** The `JSONObject` scalar type represents arbitrary values as *embedded* JSON */
    JSONObject: Record<string, unknown>;
    /** Represents a date in ISO 8601 format. Accepts shortcuts like `2021` to represent midnight Fri Jan 01 2021. Also accepts ISO 8601 durations strings which are added to the current date to create the represented date (e.g '-P2W1D' represents the date that was two weeks and 1 day ago) */
    TimelessDate: any;
    /** A universally unique identifier as specified by RFC 4122. */
    UUID: any;
};
export declare type AirbyteConfigurationInput = {
    /** Linear export API key. */
    apiKey: Scalars["String"];
};
/** An API key. Grants access to the user's resources. */
export declare type ApiKey = Node & {
    __typename?: "ApiKey";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The label of the API key. */
    label: Scalars["String"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type ApiKeyConnection = {
    __typename?: "ApiKeyConnection";
    edges: Array<ApiKeyEdge>;
    nodes: Array<ApiKey>;
    pageInfo: PageInfo;
};
export declare type ApiKeyCreateInput = {
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The API key value. */
    key: Scalars["String"];
    /** The label for the API key. */
    label: Scalars["String"];
};
export declare type ApiKeyEdge = {
    __typename?: "ApiKeyEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: ApiKey;
};
export declare type ApiKeyPayload = {
    __typename?: "ApiKeyPayload";
    /** The API key that was created. */
    apiKey: ApiKey;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Public information of the OAuth application. */
export declare type Application = {
    __typename?: "Application";
    /** OAuth application's client ID. */
    clientId: Scalars["String"];
    /** Information about the application. */
    description?: Maybe<Scalars["String"]>;
    /** Name of the developer. */
    developer: Scalars["String"];
    /** Url of the developer (homepage or docs). */
    developerUrl: Scalars["String"];
    /** OAuth application's ID. */
    id: Scalars["String"];
    /** Image of the application. */
    imageUrl?: Maybe<Scalars["String"]>;
    /** Application name. */
    name: Scalars["String"];
};
/** A generic payload return from entity archive or deletion mutations. */
export declare type ArchivePayload = {
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Contains requested archived model objects. */
export declare type ArchiveResponse = {
    __typename?: "ArchiveResponse";
    /** A JSON serialized collection of model objects loaded from the archive */
    archive: Scalars["String"];
    /** The version of the remote database. Incremented by 1 for each migration run on the database. */
    databaseVersion: Scalars["Float"];
    /** Whether the dependencies for the model objects are included in the archive. */
    includesDependencies: Scalars["Boolean"];
    /** The total number of entities in the archive. */
    totalCount: Scalars["Float"];
};
/** Issue attachment (e.g. support ticket, pull request). */
export declare type Attachment = Node & {
    __typename?: "Attachment";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The creator of the attachment. */
    creator?: Maybe<User>;
    /** Indicates if attachments for the same source application should be grouped in the Linear UI. */
    groupBySource: Scalars["Boolean"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The issue this attachment belongs to. */
    issue: Issue;
    /** Custom metadata related to the attachment. */
    metadata: Scalars["JSONObject"];
    /** Information about the source which created the attachment. */
    source?: Maybe<Scalars["JSONObject"]>;
    /** An accessor helper to source.type, defines the source type of the attachment. */
    sourceType?: Maybe<Scalars["String"]>;
    /** Content for the subtitle line in the Linear attachment widget. */
    subtitle?: Maybe<Scalars["String"]>;
    /** Content for the title line in the Linear attachment widget. */
    title: Scalars["String"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Location of the attachment which is also used as an identifier. */
    url: Scalars["String"];
};
/** A generic payload return from entity archive mutations. */
export declare type AttachmentArchivePayload = ArchivePayload & {
    __typename?: "AttachmentArchivePayload";
    /** The archived/unarchived entity. Null if entity was deleted. */
    entity?: Maybe<Attachment>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Attachment collection filtering options. */
export declare type AttachmentCollectionFilter = {
    /** Compound filters, all of which need to be matched by the attachment. */
    and?: Maybe<Array<AttachmentCollectionFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the attachments creator must satisfy. */
    creator?: Maybe<NullableUserFilter>;
    /** Filters that needs to be matched by all attachments. */
    every?: Maybe<AttachmentFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the collection length. */
    length?: Maybe<NumberComparator>;
    /** Compound filters, one of which need to be matched by the attachment. */
    or?: Maybe<Array<AttachmentCollectionFilter>>;
    /** Filters that needs to be matched by some attachments. */
    some?: Maybe<AttachmentFilter>;
    /** Comparator for the source type. */
    sourceType?: Maybe<SourceTypeComparator>;
    /** Comparator for the subtitle. */
    subtitle?: Maybe<NullableStringComparator>;
    /** Comparator for the title. */
    title?: Maybe<StringComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
    /** Comparator for the url. */
    url?: Maybe<StringComparator>;
};
export declare type AttachmentConnection = {
    __typename?: "AttachmentConnection";
    edges: Array<AttachmentEdge>;
    nodes: Array<Attachment>;
    pageInfo: PageInfo;
};
export declare type AttachmentCreateInput = {
    /** Create a linked comment with markdown body. */
    commentBody?: Maybe<Scalars["String"]>;
    /** Create a linked comment with Prosemirror body. Please use `commentBody` instead */
    commentBodyData?: Maybe<Scalars["JSONObject"]>;
    /** Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=application` mode. */
    createAsUser?: Maybe<Scalars["String"]>;
    /** Indicates if attachments for the same source application should be grouped in the Linear UI. */
    groupBySource?: Maybe<Scalars["Boolean"]>;
    /** An icon url to display with the attachment. Should be of jpg or png format. Maximum of 1MB in size. Dimensions should be 20x20px for optimal display quality. */
    iconUrl?: Maybe<Scalars["String"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The issue to associate the attachment with. */
    issueId: Scalars["String"];
    /** Attachment metadata object with string and number values. */
    metadata?: Maybe<Scalars["JSONObject"]>;
    /** The attachment subtitle. */
    subtitle?: Maybe<Scalars["String"]>;
    /** The attachment title. */
    title: Scalars["String"];
    /** Attachment location which is also used as an unique identifier for the attachment. If another attachment is created with the same `url` value, existing record is updated instead. */
    url: Scalars["String"];
};
export declare type AttachmentEdge = {
    __typename?: "AttachmentEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Attachment;
};
/** Attachment filtering options. */
export declare type AttachmentFilter = {
    /** Compound filters, all of which need to be matched by the attachment. */
    and?: Maybe<Array<AttachmentFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the attachments creator must satisfy. */
    creator?: Maybe<NullableUserFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Compound filters, one of which need to be matched by the attachment. */
    or?: Maybe<Array<AttachmentFilter>>;
    /** Comparator for the source type. */
    sourceType?: Maybe<SourceTypeComparator>;
    /** Comparator for the subtitle. */
    subtitle?: Maybe<NullableStringComparator>;
    /** Comparator for the title. */
    title?: Maybe<StringComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
    /** Comparator for the url. */
    url?: Maybe<StringComparator>;
};
export declare type AttachmentPayload = {
    __typename?: "AttachmentPayload";
    /** The issue attachment that was created. */
    attachment: Attachment;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type AttachmentSourcesPayload = {
    __typename?: "AttachmentSourcesPayload";
    /** A unique list of all source types used in this workspace */
    sources: Scalars["JSONObject"];
};
export declare type AttachmentUpdateInput = {
    /** An icon url to display with the attachment. Should be of jpg or png format. Maximum of 1MB in size. Dimensions should be 20x20px for optimal display quality. */
    iconUrl?: Maybe<Scalars["String"]>;
    /** Attachment metadata object with string and number values. */
    metadata?: Maybe<Scalars["JSONObject"]>;
    /** The attachment subtitle. */
    subtitle?: Maybe<Scalars["String"]>;
    /** The attachment title. */
    title: Scalars["String"];
};
/** Workspace audit log entry object. */
export declare type AuditEntry = Node & {
    __typename?: "AuditEntry";
    /** The user that caused the audit entry to be created. */
    actor?: Maybe<User>;
    /** The ID of the user that caused the audit entry to be created. */
    actorId?: Maybe<Scalars["String"]>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** Country code of request resulting to audit entry. */
    countryCode?: Maybe<Scalars["String"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** IP from actor when entry was recorded. */
    ip?: Maybe<Scalars["String"]>;
    /** Additional metadata related to the audit entry. */
    metadata?: Maybe<Scalars["JSONObject"]>;
    /** The organization the audit log belongs to. */
    organization?: Maybe<Organization>;
    /** Additional information related to the request which performed the action. */
    requestInformation?: Maybe<Scalars["JSONObject"]>;
    type: Scalars["String"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type AuditEntryConnection = {
    __typename?: "AuditEntryConnection";
    edges: Array<AuditEntryEdge>;
    nodes: Array<AuditEntry>;
    pageInfo: PageInfo;
};
export declare type AuditEntryEdge = {
    __typename?: "AuditEntryEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: AuditEntry;
};
/** Audit entry filtering options. */
export declare type AuditEntryFilter = {
    /** Filters that the audit entry actor must satisfy. */
    actor?: Maybe<NullableUserFilter>;
    /** Comparator for the country code. */
    countryCode?: Maybe<StringComparator>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the IP address. */
    ip?: Maybe<StringComparator>;
    /** Comparator for the type. */
    type?: Maybe<StringComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type AuditEntryType = {
    __typename?: "AuditEntryType";
    /** Description of the audit entry type. */
    description: Scalars["String"];
    /** The audit entry type. */
    type: Scalars["String"];
};
/** [INTERNAL] An OAuth userId/createdDate tuple */
export declare type AuthMembership = {
    __typename?: "AuthMembership";
    /** The date of the authorization */
    createdAt: Scalars["DateTime"];
    /** The authorizing userId */
    userId: Scalars["String"];
};
export declare type AuthResolverResponse = {
    __typename?: "AuthResolverResponse";
    /** Should the signup flow allow access for the domain. */
    allowDomainAccess?: Maybe<Scalars["Boolean"]>;
    /** Organizations this account has access to, but is not yet a member. */
    availableOrganizations?: Maybe<Array<Organization>>;
    /** Email for the authenticated account. */
    email?: Maybe<Scalars["String"]>;
    /** User account ID. */
    id: Scalars["String"];
    /** ID of the organization last accessed by the user. */
    lastUsedOrganizationId?: Maybe<Scalars["String"]>;
    /** JWT token for authentication of the account. */
    token?: Maybe<Scalars["String"]>;
    /** Users belonging to this account. */
    users: Array<User>;
};
/** [INTERNAL] Public information of the OAuth application, plus the authorized scopes for a given user. */
export declare type AuthorizedApplication = {
    __typename?: "AuthorizedApplication";
    /** OAuth application's ID. */
    appId: Scalars["String"];
    /** OAuth application's client ID. */
    clientId: Scalars["String"];
    /** Image of the application. */
    imageUrl?: Maybe<Scalars["String"]>;
    /** Application name. */
    name: Scalars["String"];
    /** Scopes that are authorized for this application for a given user. */
    scope: Array<Scalars["String"]>;
    /** Whether or not webhooks are enabled for the application. */
    webhooksEnabled: Scalars["Boolean"];
};
/** Comparator for booleans. */
export declare type BooleanComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["Boolean"]>;
    /** Not equals constraint. */
    neq?: Maybe<Scalars["Boolean"]>;
};
/** A comment associated with an issue. */
export declare type Comment = Node & {
    __typename?: "Comment";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The comment content in markdown format. */
    body: Scalars["String"];
    /** The comment content as a Prosemirror document. */
    bodyData: Scalars["String"];
    /** The children of the comment. */
    children: CommentConnection;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The time user edited the comment. */
    editedAt?: Maybe<Scalars["DateTime"]>;
    /** [ALPHA] The external user who wrote the comment. */
    externalUser?: Maybe<ExternalUser>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The issue that the comment is associated with. */
    issue: Issue;
    /** The parent comment under which the current comment is nested. */
    parent?: Maybe<Comment>;
    /** Emoji reaction summary, grouped by emoji type */
    reactionData: Scalars["JSONObject"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Comment's URL. */
    url: Scalars["String"];
    /** The user who wrote the comment. */
    user?: Maybe<User>;
};
/** A comment associated with an issue. */
export declare type CommentChildrenArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CommentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** Comment filtering options. */
export declare type CommentCollectionFilter = {
    /** Compound filters, all of which need to be matched by the comment. */
    and?: Maybe<Array<CommentCollectionFilter>>;
    /** Comparator for the comments body. */
    body?: Maybe<StringComparator>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that needs to be matched by all comments. */
    every?: Maybe<CommentFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the comments issue must satisfy. */
    issue?: Maybe<IssueFilter>;
    /** Comparator for the collection length. */
    length?: Maybe<NumberComparator>;
    /** Compound filters, one of which need to be matched by the comment. */
    or?: Maybe<Array<CommentCollectionFilter>>;
    /** Filters that needs to be matched by some comments. */
    some?: Maybe<CommentFilter>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
    /** Filters that the comments creator must satisfy. */
    user?: Maybe<UserFilter>;
};
export declare type CommentConnection = {
    __typename?: "CommentConnection";
    edges: Array<CommentEdge>;
    nodes: Array<Comment>;
    pageInfo: PageInfo;
};
export declare type CommentCreateInput = {
    /** The comment content in markdown format. */
    body?: Maybe<Scalars["String"]>;
    /** The comment content as a Prosemirror document. */
    bodyData?: Maybe<Scalars["JSON"]>;
    /** Create comment as a user with the provided name. This option is only available to OAuth applications creating comments in `actor=application` mode. */
    createAsUser?: Maybe<Scalars["String"]>;
    /** The date when the comment was created (e.g. if importing from another system). Must be a date in the past. If none is provided, the backend will generate the time as now. */
    createdAt?: Maybe<Scalars["DateTime"]>;
    /** Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=application` mode. */
    displayIconUrl?: Maybe<Scalars["String"]>;
    /** Flag to prevent auto subscription to the issue the comment is created on. */
    doNotSubscribeToIssue?: Maybe<Scalars["Boolean"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The issue to associate the comment with. */
    issueId: Scalars["String"];
    /** The parent comment under which to nest a current comment. */
    parentId?: Maybe<Scalars["String"]>;
};
export declare type CommentEdge = {
    __typename?: "CommentEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Comment;
};
/** Comment filtering options. */
export declare type CommentFilter = {
    /** Compound filters, all of which need to be matched by the comment. */
    and?: Maybe<Array<CommentFilter>>;
    /** Comparator for the comments body. */
    body?: Maybe<StringComparator>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the comments issue must satisfy. */
    issue?: Maybe<IssueFilter>;
    /** Compound filters, one of which need to be matched by the comment. */
    or?: Maybe<Array<CommentFilter>>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
    /** Filters that the comments creator must satisfy. */
    user?: Maybe<UserFilter>;
};
export declare type CommentPayload = {
    __typename?: "CommentPayload";
    /** The comment that was created or updated. */
    comment: Comment;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type CommentUpdateInput = {
    /** The comment content. */
    body?: Maybe<Scalars["String"]>;
    /** The comment content as a Prosemirror document. */
    bodyData?: Maybe<Scalars["JSON"]>;
};
/** A company related to issue's origin. */
export declare type Company = Node & {
    __typename?: "Company";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** Custom company properties. */
    companyProperties: Scalars["JSONObject"];
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who added the company. */
    creator: User;
    /** Company ID in an external system. */
    externalId: Scalars["String"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Company logo URL. */
    logoUrl?: Maybe<Scalars["String"]>;
    /** Company name. */
    name: Scalars["String"];
    /** The organization of the customer. */
    organization: Organization;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Company website URL. */
    websiteUrl?: Maybe<Scalars["String"]>;
};
export declare type CompanyConnection = {
    __typename?: "CompanyConnection";
    edges: Array<CompanyEdge>;
    nodes: Array<Company>;
    pageInfo: PageInfo;
};
export declare type CompanyEdge = {
    __typename?: "CompanyEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Company;
};
export declare type ContactCreateInput = {
    /** User's browser information. */
    browser?: Maybe<Scalars["String"]>;
    /** User's Linear client information. */
    clientVersion?: Maybe<Scalars["String"]>;
    /** User's device information. */
    device?: Maybe<Scalars["String"]>;
    /** How disappointed the user would be if they could no longer use Linear. */
    disappointmentRating?: Maybe<Scalars["Int"]>;
    /** The message the user sent. */
    message: Scalars["String"];
    /** User's operating system. */
    operatingSystem?: Maybe<Scalars["String"]>;
    /** The type of support contact. */
    type: Scalars["String"];
};
export declare type ContactPayload = {
    __typename?: "ContactPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** [INTERNAL] Input for sending a message to the Linear Sales team */
export declare type ContactSalesCreateInput = {
    /** Size of the company. */
    companySize?: Maybe<Scalars["String"]>;
    /** Work email of the person requesting information. */
    email: Scalars["String"];
    /** The message the user sent. */
    message?: Maybe<Scalars["String"]>;
    /** Name of the person requesting information. */
    name: Scalars["String"];
};
/** [Internal] Comparator for content. */
export declare type ContentComparator = {
    /** [Internal] Contains constraint. */
    contains?: Maybe<Scalars["String"]>;
    /** [Internal] Not-contains constraint. */
    notContains?: Maybe<Scalars["String"]>;
};
export declare enum ContextViewType {
    ActiveCycle = "activeCycle",
    ActiveIssues = "activeIssues",
    Backlog = "backlog",
    Triage = "triage",
    UpcomingCycle = "upcomingCycle"
}
export declare type CreateCsvExportReportPayload = {
    __typename?: "CreateCsvExportReportPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type CreateOrJoinOrganizationResponse = {
    __typename?: "CreateOrJoinOrganizationResponse";
    organization: Organization;
    user: User;
};
export declare type CreateOrganizationInput = {
    /** Whether the organization should allow email domain access. */
    domainAccess?: Maybe<Scalars["Boolean"]>;
    /** The name of the organization. */
    name: Scalars["String"];
    /** The timezone of the organization, passed in by client. */
    timezone?: Maybe<Scalars["String"]>;
    /** The URL key of the organization. */
    urlKey: Scalars["String"];
    /** JSON serialized UTM parameters associated with the creation of the workspace. */
    utm?: Maybe<Scalars["String"]>;
};
/** A custom view that has been saved by a user. */
export declare type CustomView = Node & {
    __typename?: "CustomView";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The color of the icon of the custom view. */
    color?: Maybe<Scalars["String"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the custom view. */
    creator: User;
    /** The description of the custom view. */
    description?: Maybe<Scalars["String"]>;
    /** The filter applied to issues in the custom view. */
    filterData: Scalars["JSONObject"];
    /**
     * The filters applied to issues in the custom view.
     * @deprecated Will be replaced by `filterData` in a future update
     */
    filters: Scalars["JSONObject"];
    /** The icon of the custom view. */
    icon?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The name of the custom view. */
    name: Scalars["String"];
    /** The organization of the custom view. */
    organization: Organization;
    /** [ALPHA] The user who owns the custom view. */
    owner?: Maybe<User>;
    /** [ALPHA] The filter applied to projects in the custom view. */
    projectFilterData?: Maybe<Scalars["JSONObject"]>;
    /** Whether the custom view is shared with everyone in the organization. */
    shared: Scalars["Boolean"];
    /** The team associated with the custom view. */
    team?: Maybe<Team>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** [ALPHA] The user who last updated the custom view. */
    updatedBy: User;
};
export declare type CustomViewConnection = {
    __typename?: "CustomViewConnection";
    edges: Array<CustomViewEdge>;
    nodes: Array<CustomView>;
    pageInfo: PageInfo;
};
export declare type CustomViewCreateInput = {
    /** The color of the icon of the custom view. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the custom view. */
    description?: Maybe<Scalars["String"]>;
    /** The filter applied to issues in the custom view. */
    filterData?: Maybe<Scalars["JSONObject"]>;
    /** The filters applied to issues in the custom view. */
    filters?: Maybe<Scalars["JSONObject"]>;
    /** The icon of the custom view. */
    icon?: Maybe<Scalars["String"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The name of the custom view. */
    name: Scalars["String"];
    /** The owner of the custom view. */
    ownerId?: Maybe<Scalars["String"]>;
    /** [ALPHA] The project filter applied to issues in the custom view. */
    projectFilterData?: Maybe<Scalars["JSONObject"]>;
    /** Whether the custom view is shared with everyone in the organization. */
    shared?: Maybe<Scalars["Boolean"]>;
    /** The id of the team associated with the custom view. */
    teamId?: Maybe<Scalars["String"]>;
};
export declare type CustomViewEdge = {
    __typename?: "CustomViewEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: CustomView;
};
/** A custom view notification subscription. */
export declare type CustomViewNotificationSubscription = Entity & Node & NotificationSubscription & {
    __typename?: "CustomViewNotificationSubscription";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The type of view to which the notification subscription context is associated with. */
    contextViewType?: Maybe<ContextViewType>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The custom view subscribed to. */
    customView: CustomView;
    /** The contextual cycle view associated with the notification subscription. */
    cycle?: Maybe<Cycle>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The contextual label view associated with the notification subscription. */
    label?: Maybe<IssueLabel>;
    /** The type of subscription. */
    notificationSubscriptionTypes: Array<Scalars["String"]>;
    /** The contextual project view associated with the notification subscription. */
    project?: Maybe<Project>;
    /** The user that subscribed to receive notifications. */
    subscriber: User;
    /** The team associated with the notification subscription. */
    team?: Maybe<Team>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user view associated with the notification subscription. */
    user?: Maybe<User>;
    /** The type of user view to which the notification subscription context is associated with. */
    userContextViewType?: Maybe<UserContextViewType>;
};
export declare type CustomViewPayload = {
    __typename?: "CustomViewPayload";
    /** The custom view that was created or updated. */
    customView: CustomView;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type CustomViewSuggestionPayload = {
    __typename?: "CustomViewSuggestionPayload";
    /** The suggested view description. */
    description?: Maybe<Scalars["String"]>;
    /** The suggested view icon. */
    icon?: Maybe<Scalars["String"]>;
    /** The suggested view name. */
    name?: Maybe<Scalars["String"]>;
};
export declare type CustomViewUpdateInput = {
    /** The color of the icon of the custom view. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the custom view. */
    description?: Maybe<Scalars["String"]>;
    /** The filter applied to issues in the custom view. */
    filterData?: Maybe<Scalars["JSONObject"]>;
    /** The filters applied to issues in the custom view. */
    filters?: Maybe<Scalars["JSONObject"]>;
    /** The icon of the custom view. */
    icon?: Maybe<Scalars["String"]>;
    /** The name of the custom view. */
    name?: Maybe<Scalars["String"]>;
    /** The owner of the custom view. */
    ownerId?: Maybe<Scalars["String"]>;
    /** [ALPHA] The project filter applied to issues in the custom view. */
    projectFilterData?: Maybe<Scalars["JSONObject"]>;
    /** Whether the custom view is shared with everyone in the organization. */
    shared?: Maybe<Scalars["Boolean"]>;
    /** The id of the team associated with the custom view. */
    teamId?: Maybe<Scalars["String"]>;
};
/** A set of issues to be resolved in a specified amount of time. */
export declare type Cycle = Node & {
    __typename?: "Cycle";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the cycle was automatically archived by the auto pruning process. */
    autoArchivedAt?: Maybe<Scalars["DateTime"]>;
    /** The completion time of the cycle. If null, the cycle hasn't been completed. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The number of completed issues in the cycle after each day. */
    completedIssueCountHistory: Array<Scalars["Float"]>;
    /** The number of completed estimation points after each day. */
    completedScopeHistory: Array<Scalars["Float"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The cycle's description. */
    description?: Maybe<Scalars["String"]>;
    /** The end time of the cycle. */
    endsAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The number of in progress estimation points after each day. */
    inProgressScopeHistory: Array<Scalars["Float"]>;
    /** The total number of issues in the cycle after each day. */
    issueCountHistory: Array<Scalars["Float"]>;
    /** Issues associated with the cycle. */
    issues: IssueConnection;
    /** The custom name of the cycle. */
    name?: Maybe<Scalars["String"]>;
    /** The number of the cycle. */
    number: Scalars["Float"];
    /** The overall progress of the cycle. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points. */
    progress: Scalars["Float"];
    /** The total number of estimation points after each day. */
    scopeHistory: Array<Scalars["Float"]>;
    /** The start time of the cycle. */
    startsAt: Scalars["DateTime"];
    /** The team that the cycle is associated with. */
    team: Team;
    /** Issues that weren't completed when the cycle was closed. */
    uncompletedIssuesUponClose: IssueConnection;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** A set of issues to be resolved in a specified amount of time. */
export declare type CycleIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A set of issues to be resolved in a specified amount of time. */
export declare type CycleUncompletedIssuesUponCloseArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A generic payload return from entity archive mutations. */
export declare type CycleArchivePayload = ArchivePayload & {
    __typename?: "CycleArchivePayload";
    /** The archived/unarchived entity. Null if entity was deleted. */
    entity?: Maybe<Cycle>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type CycleConnection = {
    __typename?: "CycleConnection";
    edges: Array<CycleEdge>;
    nodes: Array<Cycle>;
    pageInfo: PageInfo;
};
export declare type CycleCreateInput = {
    /** The completion time of the cycle. If null, the cycle hasn't been completed. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The description of the cycle. */
    description?: Maybe<Scalars["String"]>;
    /** The end date of the cycle. */
    endsAt: Scalars["DateTime"];
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The custom name of the cycle. */
    name?: Maybe<Scalars["String"]>;
    /** The start date of the cycle. */
    startsAt: Scalars["DateTime"];
    /** The team to associate the cycle with. */
    teamId: Scalars["String"];
};
export declare type CycleEdge = {
    __typename?: "CycleEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Cycle;
};
/** Cycle filtering options. */
export declare type CycleFilter = {
    /** Compound filters, all of which need to be matched by the cycle. */
    and?: Maybe<Array<CycleFilter>>;
    /** Comparator for the cycle completed at date. */
    completedAt?: Maybe<DateComparator>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the cycle ends at date. */
    endsAt?: Maybe<DateComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the filtering active cycle. */
    isActive?: Maybe<BooleanComparator>;
    /** Comparator for the filtering future cycles. */
    isFuture?: Maybe<BooleanComparator>;
    /** Comparator for the filtering next cycle. */
    isNext?: Maybe<BooleanComparator>;
    /** Comparator for the filtering past cycles. */
    isPast?: Maybe<BooleanComparator>;
    /** Comparator for the filtering previous cycle. */
    isPrevious?: Maybe<BooleanComparator>;
    /** Filters that the cycles issues must satisfy. */
    issues?: Maybe<IssueCollectionFilter>;
    /** Comparator for the cycle name. */
    name?: Maybe<StringComparator>;
    /** Comparator for the cycle number. */
    number?: Maybe<NumberComparator>;
    /** Compound filters, one of which need to be matched by the cycle. */
    or?: Maybe<Array<CycleFilter>>;
    /** Comparator for the cycle start date. */
    startsAt?: Maybe<DateComparator>;
    /** Filters that the cycles team must satisfy. */
    team?: Maybe<TeamFilter>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
/** A cycle notification subscription. */
export declare type CycleNotificationSubscription = Entity & Node & NotificationSubscription & {
    __typename?: "CycleNotificationSubscription";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The type of view to which the notification subscription context is associated with. */
    contextViewType?: Maybe<ContextViewType>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The contextual custom view associated with the notification subscription. */
    customView?: Maybe<CustomView>;
    /** The cycle subscribed to. */
    cycle: Cycle;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The contextual label view associated with the notification subscription. */
    label?: Maybe<IssueLabel>;
    /** The type of subscription. */
    notificationSubscriptionTypes: Array<Scalars["String"]>;
    /** The contextual project view associated with the notification subscription. */
    project?: Maybe<Project>;
    /** The user that subscribed to receive notifications. */
    subscriber: User;
    /** The team associated with the notification subscription. */
    team?: Maybe<Team>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user view associated with the notification subscription. */
    user?: Maybe<User>;
    /** The type of user view to which the notification subscription context is associated with. */
    userContextViewType?: Maybe<UserContextViewType>;
};
export declare type CyclePayload = {
    __typename?: "CyclePayload";
    /** The Cycle that was created or updated. */
    cycle?: Maybe<Cycle>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type CycleUpdateInput = {
    /** The end date of the cycle. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The description of the cycle. */
    description?: Maybe<Scalars["String"]>;
    /** The end date of the cycle. */
    endsAt?: Maybe<Scalars["DateTime"]>;
    /** The custom name of the cycle. */
    name?: Maybe<Scalars["String"]>;
    /** The start date of the cycle. */
    startsAt?: Maybe<Scalars["DateTime"]>;
};
/** Comparator for dates. */
export declare type DateComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["DateTime"]>;
    /** Greater-than constraint. Matches any values that are greater than the given value. */
    gt?: Maybe<Scalars["DateTime"]>;
    /** Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value. */
    gte?: Maybe<Scalars["DateTime"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["DateTime"]>>;
    /** Less-than constraint. Matches any values that are less than the given value. */
    lt?: Maybe<Scalars["DateTime"]>;
    /** Less-than-or-equal constraint. Matches any values that are less than or equal to the given value. */
    lte?: Maybe<Scalars["DateTime"]>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["DateTime"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["DateTime"]>>;
};
/** The day of the week. */
export declare enum Day {
    Friday = "Friday",
    Monday = "Monday",
    Saturday = "Saturday",
    Sunday = "Sunday",
    Thursday = "Thursday",
    Tuesday = "Tuesday",
    Wednesday = "Wednesday"
}
export declare type DeleteOrganizationInput = {
    /** The deletion code to confirm operation. */
    deletionCode: Scalars["String"];
};
/** A generic payload return from entity deletion mutations. */
export declare type DeletePayload = ArchivePayload & {
    __typename?: "DeletePayload";
    /** The identifier of the deleted entity. */
    entityId: Scalars["String"];
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** A document for a project. */
export declare type Document = Node & {
    __typename?: "Document";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The color of the icon. */
    color?: Maybe<Scalars["String"]>;
    /** The document content in markdown format. */
    content?: Maybe<Scalars["String"]>;
    /** The document content as JSON. */
    contentData?: Maybe<Scalars["JSONObject"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the document. */
    creator: User;
    /** The icon of the document. */
    icon?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The project that the document is associated with. */
    project: Project;
    /** The document's unique URL slug. */
    slugId: Scalars["String"];
    /** The document title. */
    title: Scalars["String"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user who last updated the document. */
    updatedBy: User;
};
export declare type DocumentConnection = {
    __typename?: "DocumentConnection";
    edges: Array<DocumentEdge>;
    nodes: Array<Document>;
    pageInfo: PageInfo;
};
/** A document content for a project. */
export declare type DocumentContent = Node & {
    __typename?: "DocumentContent";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The document content in markdown format. */
    content?: Maybe<Scalars["String"]>;
    /** The document content as JSON. */
    contentData?: Maybe<Scalars["JSONObject"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The issue that the document is associated with. */
    issue?: Maybe<Issue>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type DocumentCreateInput = {
    /** The color of the icon. */
    color?: Maybe<Scalars["String"]>;
    /** The document content as markdown. */
    content?: Maybe<Scalars["String"]>;
    /** The document content as a Prosemirror document. */
    contentData?: Maybe<Scalars["JSONObject"]>;
    /** The icon of the document. */
    icon?: Maybe<Scalars["String"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** Related project for the document. */
    projectId: Scalars["String"];
    /** The title of the document. */
    title: Scalars["String"];
};
export declare type DocumentEdge = {
    __typename?: "DocumentEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Document;
};
export declare type DocumentPayload = {
    __typename?: "DocumentPayload";
    /** The document that was created or updated. */
    document: Document;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type DocumentSearchPayload = {
    __typename?: "DocumentSearchPayload";
    /** Archived entities matching the search term along with all their dependencies. */
    archivePayload: ArchiveResponse;
    edges: Array<DocumentSearchResultEdge>;
    nodes: Array<DocumentSearchResult>;
    pageInfo: PageInfo;
    /** Total number of results for query without filters applied. */
    totalCount: Scalars["Float"];
};
export declare type DocumentSearchResult = Node & {
    __typename?: "DocumentSearchResult";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The color of the icon. */
    color?: Maybe<Scalars["String"]>;
    /** The document content in markdown format. */
    content?: Maybe<Scalars["String"]>;
    /** The document content as JSON. */
    contentData?: Maybe<Scalars["JSONObject"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the document. */
    creator: User;
    /** The icon of the document. */
    icon?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Metadata related to search result */
    metadata: Scalars["JSONObject"];
    /** The project that the document is associated with. */
    project: Project;
    /** The document's unique URL slug. */
    slugId: Scalars["String"];
    /** The document title. */
    title: Scalars["String"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user who last updated the document. */
    updatedBy: User;
};
export declare type DocumentSearchResultConnection = {
    __typename?: "DocumentSearchResultConnection";
    edges: Array<DocumentSearchResultEdge>;
    nodes: Array<DocumentSearchResult>;
    pageInfo: PageInfo;
};
export declare type DocumentSearchResultEdge = {
    __typename?: "DocumentSearchResultEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: DocumentSearchResult;
};
export declare type DocumentUpdateInput = {
    /** The color of the icon. */
    color?: Maybe<Scalars["String"]>;
    /** The document content as markdown. */
    content?: Maybe<Scalars["String"]>;
    /** The document content as a Prosemirror document. */
    contentData?: Maybe<Scalars["JSONObject"]>;
    /** The icon of the document. */
    icon?: Maybe<Scalars["String"]>;
    /** Related project for the document. */
    projectId?: Maybe<Scalars["String"]>;
    /** The title of the document. */
    title?: Maybe<Scalars["String"]>;
};
export declare type EmailSubscribeInput = {
    /** [INTERNAL] Email to subscribe. */
    email: Scalars["String"];
};
export declare type EmailSubscribePayload = {
    __typename?: "EmailSubscribePayload";
    /** [INTERNAL] Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type EmailUnsubscribeInput = {
    /** The user's email validation token. */
    token: Scalars["String"];
    /** Email type to unsubscribed from. */
    type: Scalars["String"];
    /** The identifier of the user. */
    userId: Scalars["String"];
};
export declare type EmailUnsubscribePayload = {
    __typename?: "EmailUnsubscribePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type EmailUserAccountAuthChallengeInput = {
    /** Auth code for the client initiating the sequence. */
    clientAuthCode?: Maybe<Scalars["String"]>;
    /** The email for which to generate the magic login code. */
    email: Scalars["String"];
    /** Whether the login was requested from the desktop app. */
    isDesktop?: Maybe<Scalars["Boolean"]>;
    /** Signup code. */
    signupCode?: Maybe<Scalars["String"]>;
};
export declare type EmailUserAccountAuthChallengeResponse = {
    __typename?: "EmailUserAccountAuthChallengeResponse";
    /** Supported challenge for this user account. Can be either verificationCode or password. */
    authType: Scalars["String"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Information for creating embedded content for the provided URL */
export declare type Embed = {
    __typename?: "Embed";
    /** The name of the author/owner of the resource */
    authorName?: Maybe<Scalars["String"]>;
    /** The description of the content */
    description?: Maybe<Scalars["String"]>;
    /** The height of embedded content (photo, video, rich) */
    height?: Maybe<Scalars["Float"]>;
    /** The HTML (video, rich) */
    html?: Maybe<Scalars["String"]>;
    /** The name of the provider */
    providerName?: Maybe<Scalars["String"]>;
    /** The height of the thumbnail preview image */
    thumbnailHeight?: Maybe<Scalars["Float"]>;
    /** The URL of the thumbnail preview image */
    thumbnailUrl?: Maybe<Scalars["String"]>;
    /** The width of the thumbnail preview image */
    thumbnailWidth?: Maybe<Scalars["Float"]>;
    /** Title for the returned embed view */
    title?: Maybe<Scalars["String"]>;
    /** The type of embed */
    type: Scalars["String"];
    /** The asset URL (photo) */
    url?: Maybe<Scalars["String"]>;
    /** The width of embedded content (photo, video, rich) */
    width?: Maybe<Scalars["Float"]>;
};
export declare type EmbedPayload = {
    __typename?: "EmbedPayload";
    /** Embed information */
    embed?: Maybe<Embed>;
    /** Whether the query was successful */
    success: Scalars["Boolean"];
};
/** A custom emoji. */
export declare type Emoji = Node & {
    __typename?: "Emoji";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the emoji. */
    creator: User;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The emoji's name. */
    name: Scalars["String"];
    /** The organization that the emoji belongs to. */
    organization: Organization;
    /** The source of the emoji. */
    source: Scalars["String"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The emoji image URL. */
    url: Scalars["String"];
};
export declare type EmojiConnection = {
    __typename?: "EmojiConnection";
    edges: Array<EmojiEdge>;
    nodes: Array<Emoji>;
    pageInfo: PageInfo;
};
export declare type EmojiCreateInput = {
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The name of the custom emoji. */
    name: Scalars["String"];
    /** The URL for the emoji. */
    url: Scalars["String"];
};
export declare type EmojiEdge = {
    __typename?: "EmojiEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Emoji;
};
export declare type EmojiPayload = {
    __typename?: "EmojiPayload";
    /** The emoji that was created. */
    emoji: Emoji;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** A basic entity. */
export declare type Entity = {
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** Comparator for estimates. */
export declare type EstimateComparator = {
    /** Compound filters, one of which need to be matched by the estimate. */
    and?: Maybe<Array<NullableNumberComparator>>;
    /** Equals constraint. */
    eq?: Maybe<Scalars["Float"]>;
    /** Greater-than constraint. Matches any values that are greater than the given value. */
    gt?: Maybe<Scalars["Float"]>;
    /** Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value. */
    gte?: Maybe<Scalars["Float"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["Float"]>>;
    /** Less-than constraint. Matches any values that are less than the given value. */
    lt?: Maybe<Scalars["Float"]>;
    /** Less-than-or-equal constraint. Matches any values that are less than or equal to the given value. */
    lte?: Maybe<Scalars["Float"]>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["Float"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["Float"]>>;
    /** Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values. */
    null?: Maybe<Scalars["Boolean"]>;
    /** Compound filters, all of which need to be matched by the estimate. */
    or?: Maybe<Array<NullableNumberComparator>>;
};
/** [ALPHA] An external authenticated (e.g., through Slack) user which doesn't have a Linear account, but can create and update entities in Linear from the external system that authenticated them. */
export declare type ExternalUser = Node & {
    __typename?: "ExternalUser";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** An URL to the external user's avatar image. */
    avatarUrl?: Maybe<Scalars["String"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The external user's display name. Unique within each organization. Can match the display name of an actual user. */
    displayName: Scalars["String"];
    /** The external user's email address. */
    email?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The last time the external user was seen interacting with Linear. */
    lastSeen?: Maybe<Scalars["DateTime"]>;
    /** The external user's full name. */
    name: Scalars["String"];
    /** Organization the external user belongs to. */
    organization: Organization;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type ExternalUserConnection = {
    __typename?: "ExternalUserConnection";
    edges: Array<ExternalUserEdge>;
    nodes: Array<ExternalUser>;
    pageInfo: PageInfo;
};
export declare type ExternalUserEdge = {
    __typename?: "ExternalUserEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: ExternalUser;
};
/** User favorites presented in the sidebar. */
export declare type Favorite = Node & {
    __typename?: "Favorite";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** Children of the favorite. Only applies to favorites of type folder. */
    children: FavoriteConnection;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The favorited custom view. */
    customView?: Maybe<CustomView>;
    /** The favorited cycle. */
    cycle?: Maybe<Cycle>;
    /** The favorited document. */
    document?: Maybe<Document>;
    /** The name of the folder. Only applies to favorites of type folder. */
    folderName?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The favorited issue. */
    issue?: Maybe<Issue>;
    /** The favorited label. */
    label?: Maybe<IssueLabel>;
    /** The owner of the favorite. */
    owner: User;
    /** The parent folder of the favorite. */
    parent?: Maybe<Favorite>;
    /** The team of the favorited predefined view. */
    predefinedViewTeam?: Maybe<Team>;
    /** The type of favorited predefined view. */
    predefinedViewType?: Maybe<Scalars["String"]>;
    /** The favorited project. */
    project?: Maybe<Project>;
    /** The favorited team of the project. */
    projectTeam?: Maybe<Team>;
    /** The favorited roadmap. */
    roadmap?: Maybe<Roadmap>;
    /** The order of the item in the favorites list. */
    sortOrder: Scalars["Float"];
    /** The type of the favorite. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The favorited user. */
    user?: Maybe<User>;
};
/** User favorites presented in the sidebar. */
export declare type FavoriteChildrenArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type FavoriteConnection = {
    __typename?: "FavoriteConnection";
    edges: Array<FavoriteEdge>;
    nodes: Array<Favorite>;
    pageInfo: PageInfo;
};
export declare type FavoriteCreateInput = {
    /** The identifier of the custom view to favorite. */
    customViewId?: Maybe<Scalars["String"]>;
    /** The identifier of the cycle to favorite. */
    cycleId?: Maybe<Scalars["String"]>;
    /** The identifier of the document to favorite. */
    documentId?: Maybe<Scalars["String"]>;
    /** The name of the favorite folder. */
    folderName?: Maybe<Scalars["String"]>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifier of the issue to favorite. */
    issueId?: Maybe<Scalars["String"]>;
    /** The identifier of the label to favorite. */
    labelId?: Maybe<Scalars["String"]>;
    /** The parent folder of the favorite. */
    parentId?: Maybe<Scalars["String"]>;
    /** The identifier of team for the predefined view to favorite. */
    predefinedViewTeamId?: Maybe<Scalars["String"]>;
    /** The type of the predefined view to favorite. */
    predefinedViewType?: Maybe<Scalars["String"]>;
    /** The identifier of the project to favorite. */
    projectId?: Maybe<Scalars["String"]>;
    /** The identifier of the project team to favorite. */
    projectTeamId?: Maybe<Scalars["String"]>;
    /** The identifier of the roadmap to favorite. */
    roadmapId?: Maybe<Scalars["String"]>;
    /** The position of the item in the favorites list. */
    sortOrder?: Maybe<Scalars["Float"]>;
    /** The identifier of the user to favorite. */
    userId?: Maybe<Scalars["String"]>;
};
export declare type FavoriteEdge = {
    __typename?: "FavoriteEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Favorite;
};
export declare type FavoritePayload = {
    __typename?: "FavoritePayload";
    /** The object that was added as a favorite. */
    favorite: Favorite;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type FavoriteUpdateInput = {
    /** The name of the favorite folder. */
    folderName?: Maybe<Scalars["String"]>;
    /** The identifier (in UUID v4 format) of the folder to move the favorite under. */
    parentId?: Maybe<Scalars["String"]>;
    /** The position of the item in the favorites list. */
    sortOrder?: Maybe<Scalars["Float"]>;
};
/** Object representing Figma preview information. */
export declare type FigmaEmbed = {
    __typename?: "FigmaEmbed";
    /** Date when the file was updated at the time of embedding. */
    lastModified: Scalars["DateTime"];
    /** Figma file name. */
    name: Scalars["String"];
    /** Node name. */
    nodeName?: Maybe<Scalars["String"]>;
    /** Figma screenshot URL. */
    url?: Maybe<Scalars["String"]>;
};
export declare type FigmaEmbedPayload = {
    __typename?: "FigmaEmbedPayload";
    /** Figma embed information. */
    figmaEmbed?: Maybe<FigmaEmbed>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** A schedule for a team's first responder. */
export declare type FirstResponderSchedule = Node & {
    __typename?: "FirstResponderSchedule";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The integration used for scheduling. */
    integration: Integration;
    /** The id of the integration schedule used for scheduling. */
    integrationScheduleId?: Maybe<Scalars["String"]>;
    /** The current schedule and available schedules. */
    scheduleData: Scalars["JSONObject"];
    /** The team to which the schedule belongs to. */
    team: Team;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type FirstResponderScheduleConnection = {
    __typename?: "FirstResponderScheduleConnection";
    edges: Array<FirstResponderScheduleEdge>;
    nodes: Array<FirstResponderSchedule>;
    pageInfo: PageInfo;
};
export declare type FirstResponderScheduleEdge = {
    __typename?: "FirstResponderScheduleEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: FirstResponderSchedule;
};
export declare type FrontAttachmentPayload = {
    __typename?: "FrontAttachmentPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Front specific settings. */
export declare type FrontSettings = {
    __typename?: "FrontSettings";
    /** Whether a ticket should be automatically reopened when its linked Linear issue is cancelled. */
    automateTicketReopeningOnCancellation?: Maybe<Scalars["Boolean"]>;
    /** Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue */
    automateTicketReopeningOnComment?: Maybe<Scalars["Boolean"]>;
    /** Whether a ticket should be automatically reopened when its linked Linear issue is completed. */
    automateTicketReopeningOnCompletion?: Maybe<Scalars["Boolean"]>;
    /** Whether an internal message should be added when someone comments on an issue. */
    sendNoteOnComment?: Maybe<Scalars["Boolean"]>;
    /** Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled). */
    sendNoteOnStatusChange?: Maybe<Scalars["Boolean"]>;
};
export declare type FrontSettingsInput = {
    /** Whether a ticket should be automatically reopened when its linked Linear issue is cancelled. */
    automateTicketReopeningOnCancellation?: Maybe<Scalars["Boolean"]>;
    /** Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue */
    automateTicketReopeningOnComment?: Maybe<Scalars["Boolean"]>;
    /** Whether a ticket should be automatically reopened when its linked Linear issue is completed. */
    automateTicketReopeningOnCompletion?: Maybe<Scalars["Boolean"]>;
    /** Whether an internal message should be added when someone comments on an issue. */
    sendNoteOnComment?: Maybe<Scalars["Boolean"]>;
    /** Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled). */
    sendNoteOnStatusChange?: Maybe<Scalars["Boolean"]>;
};
export declare type GitHubCommitIntegrationPayload = {
    __typename?: "GitHubCommitIntegrationPayload";
    /** The integration that was created or updated. */
    integration?: Maybe<Integration>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The webhook secret to provide to GitHub. */
    webhookSecret: Scalars["String"];
};
/** Metadata and settings for a GitHub integration. */
export declare type GitHubSettings = {
    __typename?: "GitHubSettings";
    /** The avatar URL for the GitHub organization */
    orgAvatarUrl: Scalars["String"];
    /** The GitHub organization's name */
    orgLogin: Scalars["String"];
};
export declare type GitHubSettingsInput = {
    /** The avatar URL for the GitHub organization */
    orgAvatarUrl: Scalars["String"];
    /** The GitHub organization's name */
    orgLogin: Scalars["String"];
};
/** GitHub OAuth token, plus information about the organizations the user is a member of. */
export declare type GithubOAuthTokenPayload = {
    __typename?: "GithubOAuthTokenPayload";
    /** A list of the GitHub organizations the user is a member of with attached repositories. */
    organizations?: Maybe<Array<GithubOrg>>;
    /** The OAuth token if the operation to fetch it was successful. */
    token?: Maybe<Scalars["String"]>;
};
/** Relevant information for the GitHub organization. */
export declare type GithubOrg = {
    __typename?: "GithubOrg";
    /** GitHub organization id. */
    id: Scalars["String"];
    /** Whether or not this org is the user's personal repositories. */
    isPersonal?: Maybe<Scalars["Boolean"]>;
    /** The login for the GitHub organization. */
    login: Scalars["String"];
    /** The name of the GitHub organization. */
    name: Scalars["String"];
    /** Repositories that the organization owns. */
    repositories: Array<GithubRepo>;
};
/** Relevant information for the GitHub repository. */
export declare type GithubRepo = {
    __typename?: "GithubRepo";
    /** The id of the GitHub repository. */
    id: Scalars["String"];
    /** The name of the GitHub repository. */
    name: Scalars["String"];
};
/** Google Sheets specific settings. */
export declare type GoogleSheetsSettings = {
    __typename?: "GoogleSheetsSettings";
    sheetId: Scalars["Float"];
    spreadsheetId: Scalars["String"];
    spreadsheetUrl: Scalars["String"];
    updatedIssuesAt: Scalars["DateTime"];
};
export declare type GoogleSheetsSettingsInput = {
    sheetId: Scalars["Float"];
    spreadsheetId: Scalars["String"];
    spreadsheetUrl: Scalars["String"];
    updatedIssuesAt: Scalars["DateTime"];
};
export declare type GoogleUserAccountAuthInput = {
    /** Code returned from Google's OAuth flow. */
    code: Scalars["String"];
    /** The URI to redirect the user to. */
    redirectUri?: Maybe<Scalars["String"]>;
    /** Signup code. */
    signupCode?: Maybe<Scalars["String"]>;
    /** The identifiers of the teams to auto-join. */
    teamIdsToJoin?: Maybe<Array<Scalars["String"]>>;
    /** The timezone of the user's browser. */
    timezone: Scalars["String"];
};
/** Comparator for identifiers. */
export declare type IdComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["ID"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["ID"]>>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["ID"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["ID"]>>;
};
export declare type ImageUploadFromUrlPayload = {
    __typename?: "ImageUploadFromUrlPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The URL containing the image. */
    url?: Maybe<Scalars["String"]>;
};
/** An integration with an external service. */
export declare type Integration = Node & {
    __typename?: "Integration";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user that added the integration. */
    creator: User;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The organization that the integration is associated with. */
    organization: Organization;
    /** The integration's type. */
    service: Scalars["String"];
    /** The team that the integration is associated with. */
    team?: Maybe<Team>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type IntegrationConnection = {
    __typename?: "IntegrationConnection";
    edges: Array<IntegrationEdge>;
    nodes: Array<Integration>;
    pageInfo: PageInfo;
};
export declare type IntegrationEdge = {
    __typename?: "IntegrationEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Integration;
};
export declare type IntegrationPayload = {
    __typename?: "IntegrationPayload";
    /** The integration that was created or updated. */
    integration?: Maybe<Integration>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type IntegrationRequestInput = {
    /** Email associated with the request. */
    email?: Maybe<Scalars["String"]>;
    /** Name of the requested integration. */
    name: Scalars["String"];
};
export declare type IntegrationRequestPayload = {
    __typename?: "IntegrationRequestPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** The integration resource's settings */
export declare type IntegrationSettings = {
    __typename?: "IntegrationSettings";
    front?: Maybe<FrontSettings>;
    gitHub?: Maybe<GitHubSettings>;
    googleSheets?: Maybe<GoogleSheetsSettings>;
    intercom?: Maybe<IntercomSettings>;
    jira?: Maybe<JiraSettings>;
    notion?: Maybe<NotionSettings>;
    pagerDuty?: Maybe<PagerDutySettings>;
    sentry?: Maybe<SentrySettings>;
    slackOrgProjectUpdatesPost?: Maybe<SlackPostSettings>;
    slackPost?: Maybe<SlackPostSettings>;
    slackProjectPost?: Maybe<SlackPostSettings>;
    zendesk?: Maybe<ZendeskSettings>;
};
export declare type IntegrationSettingsInput = {
    front?: Maybe<FrontSettingsInput>;
    gitHub?: Maybe<GitHubSettingsInput>;
    googleSheets?: Maybe<GoogleSheetsSettingsInput>;
    intercom?: Maybe<IntercomSettingsInput>;
    jira?: Maybe<JiraSettingsInput>;
    notion?: Maybe<NotionSettingsInput>;
    pagerDuty?: Maybe<PagerDutyInput>;
    sentry?: Maybe<SentrySettingsInput>;
    slackOrgProjectUpdatesPost?: Maybe<SlackPostSettingsInput>;
    slackPost?: Maybe<SlackPostSettingsInput>;
    slackProjectPost?: Maybe<SlackPostSettingsInput>;
    zendesk?: Maybe<ZendeskSettingsInput>;
};
/** Join table between templates and integrations */
export declare type IntegrationTemplate = Node & {
    __typename?: "IntegrationTemplate";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The integration that the template is associated with. */
    integration: Integration;
    /** The template that the integration is associated with. */
    template: Template;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type IntegrationTemplateConnection = {
    __typename?: "IntegrationTemplateConnection";
    edges: Array<IntegrationTemplateEdge>;
    nodes: Array<IntegrationTemplate>;
    pageInfo: PageInfo;
};
export declare type IntegrationTemplateCreateInput = {
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifier of the integration. */
    integrationId: Scalars["String"];
    /** The identifier of the template. */
    templateId: Scalars["String"];
};
export declare type IntegrationTemplateEdge = {
    __typename?: "IntegrationTemplateEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: IntegrationTemplate;
};
export declare type IntegrationTemplatePayload = {
    __typename?: "IntegrationTemplatePayload";
    /** The IntegrationTemplate that was created or updated. */
    integrationTemplate: IntegrationTemplate;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** The configuration of all integrations for a project or a team. */
export declare type IntegrationsSettings = Node & {
    __typename?: "IntegrationsSettings";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Project which those settings apply to. */
    project?: Maybe<Project>;
    /** Whether to send a Slack message when a new issue is added to triage. */
    slackIssueAddedToTriage?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when a new issue is created for the project or the team. */
    slackIssueCreated?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when a comment is created on any of the project or team's issues. */
    slackIssueNewComment?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when an SLA is breached */
    slackIssueSlaBreached?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when an SLA is at high risk */
    slackIssueSlaHighRisk?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when any of the project or team's issues has a change in status. */
    slackIssueStatusChangedAll?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when any of the project or team's issues change to completed or cancelled. */
    slackIssueStatusChangedDone?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when a project update is created. */
    slackProjectUpdateCreated?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a new project update to team Slack channels. */
    slackProjectUpdateCreatedToTeam?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a new project update to workspace Slack channel. */
    slackProjectUpdateCreatedToWorkspace?: Maybe<Scalars["Boolean"]>;
    /** Team which those settings apply to. */
    team?: Maybe<Team>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type IntegrationsSettingsConnection = {
    __typename?: "IntegrationsSettingsConnection";
    edges: Array<IntegrationsSettingsEdge>;
    nodes: Array<IntegrationsSettings>;
    pageInfo: PageInfo;
};
export declare type IntegrationsSettingsCreateInput = {
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifier of the project to create settings for. */
    projectId?: Maybe<Scalars["String"]>;
    /** Whether to send a Slack message when a new issue is added to triage. */
    slackIssueAddedToTriage?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when a new issue is created for the project or the team. */
    slackIssueCreated?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when a comment is created on any of the project or team's issues. */
    slackIssueNewComment?: Maybe<Scalars["Boolean"]>;
    /** Whether to receive notification when an SLA has breached on Slack. */
    slackIssueSlaBreached?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when an SLA is at high risk */
    slackIssueSlaHighRisk?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when any of the project or team's issues has a change in status. */
    slackIssueStatusChangedAll?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when any of the project or team's issues change to completed or cancelled. */
    slackIssueStatusChangedDone?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when a project update is created. */
    slackProjectUpdateCreated?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when a project update is created to team channels. */
    slackProjectUpdateCreatedToTeam?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when a project update is created to workspace channel. */
    slackProjectUpdateCreatedToWorkspace?: Maybe<Scalars["Boolean"]>;
    /** The identifier of the team to create settings for. */
    teamId?: Maybe<Scalars["String"]>;
};
export declare type IntegrationsSettingsEdge = {
    __typename?: "IntegrationsSettingsEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: IntegrationsSettings;
};
export declare type IntegrationsSettingsPayload = {
    __typename?: "IntegrationsSettingsPayload";
    /** The settings that were created or updated. */
    integrationsSettings: IntegrationsSettings;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type IntegrationsSettingsUpdateInput = {
    /** Whether to send a Slack message when a new issue is added to triage. */
    slackIssueAddedToTriage?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when a new issue is created for the project or the team. */
    slackIssueCreated?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when a comment is created on any of the project or team's issues. */
    slackIssueNewComment?: Maybe<Scalars["Boolean"]>;
    /** Whether to receive notification when an SLA has breached on Slack. */
    slackIssueSlaBreached?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when an SLA is at high risk */
    slackIssueSlaHighRisk?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when any of the project or team's issues has a change in status. */
    slackIssueStatusChangedAll?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when any of the project or team's issues change to completed or cancelled. */
    slackIssueStatusChangedDone?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when a project update is created. */
    slackProjectUpdateCreated?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when a project update is created to team channels. */
    slackProjectUpdateCreatedToTeam?: Maybe<Scalars["Boolean"]>;
    /** Whether to send a Slack message when a project update is created to workspace channel. */
    slackProjectUpdateCreatedToWorkspace?: Maybe<Scalars["Boolean"]>;
};
/** Intercom specific settings. */
export declare type IntercomSettings = {
    __typename?: "IntercomSettings";
    /** Whether a ticket should be automatically reopened when its linked Linear issue is cancelled. */
    automateTicketReopeningOnCancellation?: Maybe<Scalars["Boolean"]>;
    /** Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue */
    automateTicketReopeningOnComment?: Maybe<Scalars["Boolean"]>;
    /** Whether a ticket should be automatically reopened when its linked Linear issue is completed. */
    automateTicketReopeningOnCompletion?: Maybe<Scalars["Boolean"]>;
    /** Whether an internal message should be added when someone comments on an issue. */
    sendNoteOnComment?: Maybe<Scalars["Boolean"]>;
    /** Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled). */
    sendNoteOnStatusChange?: Maybe<Scalars["Boolean"]>;
};
export declare type IntercomSettingsInput = {
    /** Whether a ticket should be automatically reopened when its linked Linear issue is cancelled. */
    automateTicketReopeningOnCancellation?: Maybe<Scalars["Boolean"]>;
    /** Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue */
    automateTicketReopeningOnComment?: Maybe<Scalars["Boolean"]>;
    /** Whether a ticket should be automatically reopened when its linked Linear issue is completed. */
    automateTicketReopeningOnCompletion?: Maybe<Scalars["Boolean"]>;
    /** Whether an internal message should be added when someone comments on an issue. */
    sendNoteOnComment?: Maybe<Scalars["Boolean"]>;
    /** Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled). */
    sendNoteOnStatusChange?: Maybe<Scalars["Boolean"]>;
};
/** An issue. */
export declare type Issue = Node & {
    __typename?: "Issue";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The user to whom the issue is assigned to. */
    assignee?: Maybe<User>;
    /** Attachments associated with the issue. */
    attachments: AttachmentConnection;
    /** The time at which the issue was automatically archived by the auto pruning process. */
    autoArchivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the issue was automatically closed by the auto pruning process. */
    autoClosedAt?: Maybe<Scalars["DateTime"]>;
    /**
     * The order of the item in its column on the board.
     * @deprecated Will be removed in near future, please use `sortOrder` instead
     */
    boardOrder: Scalars["Float"];
    /** Suggested branch name for the issue. */
    branchName: Scalars["String"];
    /** The time at which the issue was moved into canceled state. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** Children of the issue. */
    children: IssueConnection;
    /** Comments associated with the issue. */
    comments: CommentConnection;
    /** The time at which the issue was moved into completed state. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the issue. */
    creator?: Maybe<User>;
    /** Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk). */
    customerTicketCount: Scalars["Int"];
    /** The cycle that the issue is associated with. */
    cycle?: Maybe<Cycle>;
    /** The issue's description in markdown format. */
    description?: Maybe<Scalars["String"]>;
    /** [Internal] The issue's description as a Prosemirror document. */
    descriptionData?: Maybe<Scalars["JSON"]>;
    /** The date at which the issue is due. */
    dueDate?: Maybe<Scalars["TimelessDate"]>;
    /** The estimate of the complexity of the issue.. */
    estimate?: Maybe<Scalars["Float"]>;
    /** [ALPHA] The external user who created the issue. */
    externalUserCreator?: Maybe<ExternalUser>;
    /** The users favorite associated with this issue. */
    favorite?: Maybe<Favorite>;
    /** History entries associated with the issue. */
    history: IssueHistoryConnection;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Issue's human readable identifier (e.g. ENG-123). */
    identifier: Scalars["String"];
    /** Inverse relations associated with this issue. */
    inverseRelations: IssueRelationConnection;
    /** Labels associated with this issue. */
    labels: IssueLabelConnection;
    /** The issue's unique number. */
    number: Scalars["Float"];
    /** The parent of the issue. */
    parent?: Maybe<Issue>;
    /** Previous identifiers of the issue if it has been moved between teams. */
    previousIdentifiers: Array<Scalars["String"]>;
    /** The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low. */
    priority: Scalars["Float"];
    /** Label for the priority. */
    priorityLabel: Scalars["String"];
    /** The project that the issue is associated with. */
    project?: Maybe<Project>;
    /** The projectMilestone that the issue is associated with. */
    projectMilestone?: Maybe<ProjectMilestone>;
    /** Relations associated with this issue. */
    relations: IssueRelationConnection;
    /** [Internal] The time at which the issue's SLA will breach. */
    slaBreachesAt?: Maybe<Scalars["DateTime"]>;
    /** [Internal] The time at which the issue's SLA began. */
    slaStartedAt?: Maybe<Scalars["DateTime"]>;
    /** The user who snoozed the issue. */
    snoozedBy?: Maybe<User>;
    /** The time until an issue will be snoozed in Triage view. */
    snoozedUntilAt?: Maybe<Scalars["DateTime"]>;
    /** The order of the item in relation to other items in the organization. */
    sortOrder: Scalars["Float"];
    /** The time at which the issue was moved into started state. */
    startedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the issue entered triage. */
    startedTriageAt?: Maybe<Scalars["DateTime"]>;
    /** The workflow state that the issue is associated with. */
    state: WorkflowState;
    /** The order of the item in the sub-issue list. Only set if the issue has a parent. */
    subIssueSortOrder?: Maybe<Scalars["Float"]>;
    /** Users who are subscribed to the issue. */
    subscribers: UserConnection;
    /** The team that the issue is associated with. */
    team: Team;
    /** The issue's title. */
    title: Scalars["String"];
    /** A flag that indicates whether the issue is in the trash bin. */
    trashed?: Maybe<Scalars["Boolean"]>;
    /** The time at which the issue left triage. */
    triagedAt?: Maybe<Scalars["DateTime"]>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Issue URL. */
    url: Scalars["String"];
};
/** An issue. */
export declare type IssueAttachmentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<AttachmentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueChildrenArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueCommentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CommentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueHistoryArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueInverseRelationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueLabelsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueRelationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An issue. */
export declare type IssueSubscribersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A generic payload return from entity archive mutations. */
export declare type IssueArchivePayload = ArchivePayload & {
    __typename?: "IssueArchivePayload";
    /** The archived/unarchived entity. Null if entity was deleted. */
    entity?: Maybe<Issue>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type IssueBatchPayload = {
    __typename?: "IssueBatchPayload";
    /** The issues that were updated. */
    issues: Array<Issue>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Issue filtering options. */
export declare type IssueCollectionFilter = {
    /** Compound filters, all of which need to be matched by the issue. */
    and?: Maybe<Array<IssueCollectionFilter>>;
    /** Filters that the issues assignee must satisfy. */
    assignee?: Maybe<NullableUserFilter>;
    /** Filters that the issues attachments must satisfy. */
    attachments?: Maybe<AttachmentCollectionFilter>;
    /** Comparator for the issues auto archived at date. */
    autoArchivedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the issues auto closed at date. */
    autoClosedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the issues canceled at date. */
    canceledAt?: Maybe<NullableDateComparator>;
    /** Filters that the child issues must satisfy. */
    children?: Maybe<IssueCollectionFilter>;
    /** Filters that the issues comments must satisfy. */
    comments?: Maybe<CommentCollectionFilter>;
    /** Comparator for the issues completed at date. */
    completedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the issues creator must satisfy. */
    creator?: Maybe<NullableUserFilter>;
    /** Filters that the issues cycle must satisfy. */
    cycle?: Maybe<NullableCycleFilter>;
    /** Comparator for the issues description. */
    description?: Maybe<NullableStringComparator>;
    /** Comparator for the issues due date. */
    dueDate?: Maybe<NullableTimelessDateComparator>;
    /** Comparator for the issues estimate. */
    estimate?: Maybe<EstimateComparator>;
    /** Filters that needs to be matched by all issues. */
    every?: Maybe<IssueFilter>;
    /** Comparator for filtering issues which are blocked. */
    hasBlockedByRelations?: Maybe<RelationExistsComparator>;
    /** Comparator for filtering issues which are blocking. */
    hasBlockingRelations?: Maybe<RelationExistsComparator>;
    /** Comparator for filtering issues which are duplicates. */
    hasDuplicateRelations?: Maybe<RelationExistsComparator>;
    /** Comparator for filtering issues with relations. */
    hasRelatedRelations?: Maybe<RelationExistsComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that issue labels must satisfy. */
    labels?: Maybe<IssueLabelCollectionFilter>;
    /** Comparator for the collection length. */
    length?: Maybe<NumberComparator>;
    /** Comparator for the issues number. */
    number?: Maybe<NumberComparator>;
    /** Compound filters, one of which need to be matched by the issue. */
    or?: Maybe<Array<IssueCollectionFilter>>;
    /** Filters that the issue parent must satisfy. */
    parent?: Maybe<NullableIssueFilter>;
    /** Comparator for the issues priority. */
    priority?: Maybe<NullableNumberComparator>;
    /** Filters that the issues project must satisfy. */
    project?: Maybe<NullableProjectFilter>;
    /** Filters that the issues project milestone must satisfy. */
    projectMilestone?: Maybe<NullableProjectMilestoneFilter>;
    /** [Internal] Comparator for the issues content. */
    searchableContent?: Maybe<ContentComparator>;
    /** Comparator for the issues sla status. */
    slaStatus?: Maybe<SlaStatusComparator>;
    /** Filters that the issues snoozer must satisfy. */
    snoozedBy?: Maybe<NullableUserFilter>;
    /** Comparator for the issues snoozed until date. */
    snoozedUntilAt?: Maybe<NullableDateComparator>;
    /** Filters that needs to be matched by some issues. */
    some?: Maybe<IssueFilter>;
    /** Comparator for the issues started at date. */
    startedAt?: Maybe<NullableDateComparator>;
    /** Filters that the issues state must satisfy. */
    state?: Maybe<WorkflowStateFilter>;
    /** Filters that issue subscribers must satisfy. */
    subscribers?: Maybe<UserCollectionFilter>;
    /** Filters that the issues team must satisfy. */
    team?: Maybe<TeamFilter>;
    /** Comparator for the issues title. */
    title?: Maybe<StringComparator>;
    /** Comparator for the issues triaged at date. */
    triagedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type IssueConnection = {
    __typename?: "IssueConnection";
    edges: Array<IssueEdge>;
    nodes: Array<Issue>;
    pageInfo: PageInfo;
};
export declare type IssueCreateInput = {
    /** The identifier of the user to assign the issue to. */
    assigneeId?: Maybe<Scalars["String"]>;
    /** The position of the issue in its column on the board view. */
    boardOrder?: Maybe<Scalars["Float"]>;
    /** Create issue as a user with the provided name. This option is only available to OAuth applications creating issues in `actor=application` mode. */
    createAsUser?: Maybe<Scalars["String"]>;
    /** The date when the issue was created (e.g. if importing from another system). Must be a date in the past. If none is provided, the backend will generate the time as now. */
    createdAt?: Maybe<Scalars["DateTime"]>;
    /** The cycle associated with the issue. */
    cycleId?: Maybe<Scalars["String"]>;
    /** The issue description in markdown format. */
    description?: Maybe<Scalars["String"]>;
    /** The issue description as a Prosemirror document. */
    descriptionData?: Maybe<Scalars["JSON"]>;
    /** Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=application` mode. */
    displayIconUrl?: Maybe<Scalars["String"]>;
    /** The date at which the issue is due. */
    dueDate?: Maybe<Scalars["TimelessDate"]>;
    /** The estimated complexity of the issue. */
    estimate?: Maybe<Scalars["Int"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifiers of the issue labels associated with this ticket. */
    labelIds?: Maybe<Array<Scalars["String"]>>;
    /** The identifier of the parent issue. */
    parentId?: Maybe<Scalars["String"]>;
    /** The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low. */
    priority?: Maybe<Scalars["Int"]>;
    /** The project associated with the issue. */
    projectId?: Maybe<Scalars["String"]>;
    /** The project milestone associated with the issue. */
    projectMilestoneId?: Maybe<Scalars["String"]>;
    /** The comment the issue is referencing. */
    referenceCommentId?: Maybe<Scalars["String"]>;
    /** [Internal] The timestamp at which an issue will be considered in breach of SLA. */
    slaBreachesAt?: Maybe<Scalars["DateTime"]>;
    /** The position of the issue related to other issues. */
    sortOrder?: Maybe<Scalars["Float"]>;
    /** The team state of the issue. */
    stateId?: Maybe<Scalars["String"]>;
    /** The position of the issue in parent's sub-issue list. */
    subIssueSortOrder?: Maybe<Scalars["Float"]>;
    /** The identifiers of the users subscribing to this ticket. */
    subscriberIds?: Maybe<Array<Scalars["String"]>>;
    /** The identifier or key of the team associated with the issue. */
    teamId: Scalars["String"];
    /** The identifier of a template the issue should be created from. If other values are provided in the input, they will override template values. */
    templateId?: Maybe<Scalars["String"]>;
    /** The title of the issue. */
    title?: Maybe<Scalars["String"]>;
};
/** [Internal] A draft issue. */
export declare type IssueDraft = Node & {
    __typename?: "IssueDraft";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The user assigned to the draft. */
    assigneeId?: Maybe<Scalars["String"]>;
    /** Serialized array of JSONs representing attachments. */
    attachments: Scalars["JSONObject"];
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the draft. */
    creator: User;
    /** The cycle associated with the draft. */
    cycleId?: Maybe<Scalars["String"]>;
    /** The draft's description in markdown format. */
    description?: Maybe<Scalars["String"]>;
    /** [Internal] The draft's description as a Prosemirror document. */
    descriptionData?: Maybe<Scalars["JSON"]>;
    /** The date at which the issue would be due. */
    dueDate?: Maybe<Scalars["TimelessDate"]>;
    /** The estimate of the complexity of the draft. */
    estimate?: Maybe<Scalars["Float"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The parent draft of the draft. */
    parent?: Maybe<IssueDraft>;
    /** The parent issue of the draft. */
    parentIssue?: Maybe<Issue>;
    /** The priority of the draft. */
    priority: Scalars["Float"];
    /** Label for the priority. */
    priorityLabel: Scalars["String"];
    /** The project associated with the draft. */
    projectId?: Maybe<Scalars["String"]>;
    /** The project milestone associated with the draft. */
    projectMilestoneId?: Maybe<Scalars["String"]>;
    /** The workflow state associated with the draft. */
    stateId: Scalars["String"];
    /** The order of items in the sub-draft list. Only set if the draft has `parent` set. */
    subIssueSortOrder?: Maybe<Scalars["Float"]>;
    /** The team associated with the draft. */
    teamId: Scalars["String"];
    /** The draft's title. */
    title: Scalars["String"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type IssueEdge = {
    __typename?: "IssueEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Issue;
};
/** Issue filtering options. */
export declare type IssueFilter = {
    /** Compound filters, all of which need to be matched by the issue. */
    and?: Maybe<Array<IssueFilter>>;
    /** Filters that the issues assignee must satisfy. */
    assignee?: Maybe<NullableUserFilter>;
    /** Filters that the issues attachments must satisfy. */
    attachments?: Maybe<AttachmentCollectionFilter>;
    /** Comparator for the issues auto archived at date. */
    autoArchivedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the issues auto closed at date. */
    autoClosedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the issues canceled at date. */
    canceledAt?: Maybe<NullableDateComparator>;
    /** Filters that the child issues must satisfy. */
    children?: Maybe<IssueCollectionFilter>;
    /** Filters that the issues comments must satisfy. */
    comments?: Maybe<CommentCollectionFilter>;
    /** Comparator for the issues completed at date. */
    completedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the issues creator must satisfy. */
    creator?: Maybe<NullableUserFilter>;
    /** Filters that the issues cycle must satisfy. */
    cycle?: Maybe<NullableCycleFilter>;
    /** Comparator for the issues description. */
    description?: Maybe<NullableStringComparator>;
    /** Comparator for the issues due date. */
    dueDate?: Maybe<NullableTimelessDateComparator>;
    /** Comparator for the issues estimate. */
    estimate?: Maybe<EstimateComparator>;
    /** Comparator for filtering issues which are blocked. */
    hasBlockedByRelations?: Maybe<RelationExistsComparator>;
    /** Comparator for filtering issues which are blocking. */
    hasBlockingRelations?: Maybe<RelationExistsComparator>;
    /** Comparator for filtering issues which are duplicates. */
    hasDuplicateRelations?: Maybe<RelationExistsComparator>;
    /** Comparator for filtering issues with relations. */
    hasRelatedRelations?: Maybe<RelationExistsComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that issue labels must satisfy. */
    labels?: Maybe<IssueLabelCollectionFilter>;
    /** Comparator for the issues number. */
    number?: Maybe<NumberComparator>;
    /** Compound filters, one of which need to be matched by the issue. */
    or?: Maybe<Array<IssueFilter>>;
    /** Filters that the issue parent must satisfy. */
    parent?: Maybe<NullableIssueFilter>;
    /** Comparator for the issues priority. */
    priority?: Maybe<NullableNumberComparator>;
    /** Filters that the issues project must satisfy. */
    project?: Maybe<NullableProjectFilter>;
    /** Filters that the issues project milestone must satisfy. */
    projectMilestone?: Maybe<NullableProjectMilestoneFilter>;
    /** [Internal] Comparator for the issues content. */
    searchableContent?: Maybe<ContentComparator>;
    /** Comparator for the issues sla status. */
    slaStatus?: Maybe<SlaStatusComparator>;
    /** Filters that the issues snoozer must satisfy. */
    snoozedBy?: Maybe<NullableUserFilter>;
    /** Comparator for the issues snoozed until date. */
    snoozedUntilAt?: Maybe<NullableDateComparator>;
    /** Comparator for the issues started at date. */
    startedAt?: Maybe<NullableDateComparator>;
    /** Filters that the issues state must satisfy. */
    state?: Maybe<WorkflowStateFilter>;
    /** Filters that issue subscribers must satisfy. */
    subscribers?: Maybe<UserCollectionFilter>;
    /** Filters that the issues team must satisfy. */
    team?: Maybe<TeamFilter>;
    /** Comparator for the issues title. */
    title?: Maybe<StringComparator>;
    /** Comparator for the issues triaged at date. */
    triagedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type IssueFilterSuggestionPayload = {
    __typename?: "IssueFilterSuggestionPayload";
    /** The json filter that is suggested. */
    filter?: Maybe<Scalars["JSONObject"]>;
};
/** A record of changes to an issue. */
export declare type IssueHistory = Node & {
    __typename?: "IssueHistory";
    /** The user who made these changes. If null, possibly means that the change made by an integration. */
    actor?: Maybe<User>;
    /** The id of user who made these changes. If null, possibly means that the change made by an integration. */
    actorId?: Maybe<Scalars["String"]>;
    /** ID's of labels that were added. */
    addedLabelIds?: Maybe<Array<Scalars["String"]>>;
    /** Whether the issue is archived at the time of this history entry. */
    archived?: Maybe<Scalars["Boolean"]>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The linked attachment. */
    attachment?: Maybe<Attachment>;
    /** The id of linked attachment. */
    attachmentId?: Maybe<Scalars["String"]>;
    /** Whether the issue was auto-archived. */
    autoArchived?: Maybe<Scalars["Boolean"]>;
    /** Whether the issue was auto-closed. */
    autoClosed?: Maybe<Scalars["Boolean"]>;
    /** [Internal] Serialized JSON representing changes for certain non-relational properties. */
    changes?: Maybe<Scalars["JSONObject"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user from whom the issue was re-assigned from. */
    fromAssignee?: Maybe<User>;
    /** The id of user from whom the issue was re-assigned from. */
    fromAssigneeId?: Maybe<Scalars["String"]>;
    /** The previous cycle of the issue. */
    fromCycle?: Maybe<Cycle>;
    /** The id of previous cycle of the issue. */
    fromCycleId?: Maybe<Scalars["String"]>;
    /** What the due date was changed from */
    fromDueDate?: Maybe<Scalars["TimelessDate"]>;
    /** What the estimate was changed from. */
    fromEstimate?: Maybe<Scalars["Float"]>;
    /** The previous parent of the issue. */
    fromParent?: Maybe<Issue>;
    /** The id of previous parent of the issue. */
    fromParentId?: Maybe<Scalars["String"]>;
    /** What the priority was changed from. */
    fromPriority?: Maybe<Scalars["Float"]>;
    /** The previous project of the issue. */
    fromProject?: Maybe<Project>;
    /** The id of previous project of the issue. */
    fromProjectId?: Maybe<Scalars["String"]>;
    /** The previous workflow state of the issue. */
    fromState?: Maybe<WorkflowState>;
    /** The id of previous workflow state of the issue. */
    fromStateId?: Maybe<Scalars["String"]>;
    /** The team from which the issue was moved from. */
    fromTeam?: Maybe<Team>;
    /** The id of team from which the issue was moved from. */
    fromTeamId?: Maybe<Scalars["String"]>;
    /** What the title was changed from. */
    fromTitle?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The issue that was changed. */
    issue: Issue;
    /** The import record. */
    issueImport?: Maybe<IssueImport>;
    /** Changed issue relationships. */
    relationChanges?: Maybe<Array<IssueRelationHistoryPayload>>;
    /** ID's of labels that were removed. */
    removedLabelIds?: Maybe<Array<Scalars["String"]>>;
    /** The user to whom the issue was assigned to. */
    toAssignee?: Maybe<User>;
    /** The id of user to whom the issue was assigned to. */
    toAssigneeId?: Maybe<Scalars["String"]>;
    /** The new project created from the issue. */
    toConvertedProject?: Maybe<Project>;
    /** The id of new project created from the issue. */
    toConvertedProjectId?: Maybe<Scalars["String"]>;
    /** The new cycle of the issue. */
    toCycle?: Maybe<Cycle>;
    /** The id of new cycle of the issue. */
    toCycleId?: Maybe<Scalars["String"]>;
    /** What the due date was changed to */
    toDueDate?: Maybe<Scalars["TimelessDate"]>;
    /** What the estimate was changed to. */
    toEstimate?: Maybe<Scalars["Float"]>;
    /** The new parent of the issue. */
    toParent?: Maybe<Issue>;
    /** The id of new parent of the issue. */
    toParentId?: Maybe<Scalars["String"]>;
    /** What the priority was changed to. */
    toPriority?: Maybe<Scalars["Float"]>;
    /** The new project of the issue. */
    toProject?: Maybe<Project>;
    /** The id of new project of the issue. */
    toProjectId?: Maybe<Scalars["String"]>;
    /** The new workflow state of the issue. */
    toState?: Maybe<WorkflowState>;
    /** The id of new workflow state of the issue. */
    toStateId?: Maybe<Scalars["String"]>;
    /** The team to which the issue was moved to. */
    toTeam?: Maybe<Team>;
    /** The id of team to which the issue was moved to. */
    toTeamId?: Maybe<Scalars["String"]>;
    /** What the title was changed to. */
    toTitle?: Maybe<Scalars["String"]>;
    /** Whether the issue was trashed or un-trashed. */
    trashed?: Maybe<Scalars["Boolean"]>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Whether the issue's description was updated. */
    updatedDescription?: Maybe<Scalars["Boolean"]>;
};
export declare type IssueHistoryConnection = {
    __typename?: "IssueHistoryConnection";
    edges: Array<IssueHistoryEdge>;
    nodes: Array<IssueHistory>;
    pageInfo: PageInfo;
};
export declare type IssueHistoryEdge = {
    __typename?: "IssueHistoryEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: IssueHistory;
};
/** An import job for data from an external service */
export declare type IssueImport = Node & {
    __typename?: "IssueImport";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The id for the user that started the job. */
    creatorId: Scalars["String"];
    /** File URL for the uploaded CSV for the import, if there is one. */
    csvFileUrl?: Maybe<Scalars["String"]>;
    /** User readable error message, if one has occurred during the import. */
    error?: Maybe<Scalars["String"]>;
    /** Error code and metadata, if one has occurred during the import */
    errorMetadata?: Maybe<Scalars["JSONObject"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The data mapping configuration for the import job. */
    mapping?: Maybe<Scalars["JSONObject"]>;
    /** Current step progress in % (0-100). */
    progress?: Maybe<Scalars["Float"]>;
    /** The service from which data will be imported. */
    service: Scalars["String"];
    /** The status for the import job. */
    status: Scalars["String"];
    /** New team's name in cases when teamId not set */
    teamName?: Maybe<Scalars["String"]>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type IssueImportCheckPayload = {
    __typename?: "IssueImportCheckPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type IssueImportDeletePayload = {
    __typename?: "IssueImportDeletePayload";
    /** The import job that was deleted. */
    issueImport?: Maybe<IssueImport>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Issue import mapping input */
export declare type IssueImportMappingInput = {
    /** The mapping configuration for epics */
    epics?: Maybe<Scalars["JSONObject"]>;
    /** The mapping configuration for users */
    users?: Maybe<Scalars["JSONObject"]>;
    /** The mapping configuration for workflow states */
    workflowStates?: Maybe<Scalars["JSONObject"]>;
};
export declare type IssueImportPayload = {
    __typename?: "IssueImportPayload";
    /** The import job that was created or updated. */
    issueImport?: Maybe<IssueImport>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type IssueImportUpdateInput = {
    /** The mapping configuration for the import. */
    mapping: Scalars["JSONObject"];
};
/** Labels that can be associated with issues. */
export declare type IssueLabel = Node & {
    __typename?: "IssueLabel";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** Children of the label. */
    children: IssueLabelConnection;
    /** The label's color as a HEX string. */
    color: Scalars["String"];
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the label. */
    creator?: Maybe<User>;
    /** The label's description. */
    description?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Whether this label is considered to be a group. */
    isGroup: Scalars["Boolean"];
    /** Issues associated with the label. */
    issues: IssueConnection;
    /** The label's name. */
    name: Scalars["String"];
    /** @deprecated Workspace labels are identified by their team being null. */
    organization: Organization;
    /** The parent label. */
    parent?: Maybe<IssueLabel>;
    /** The team that the label is associated with. If null, the label is associated with the global workspace. */
    team?: Maybe<Team>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** Labels that can be associated with issues. */
export declare type IssueLabelChildrenArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** Labels that can be associated with issues. */
export declare type IssueLabelIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** Issue label filtering options. */
export declare type IssueLabelCollectionFilter = {
    /** Compound filters, all of which need to be matched by the label. */
    and?: Maybe<Array<IssueLabelCollectionFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the issue labels creator must satisfy. */
    creator?: Maybe<NullableUserFilter>;
    /** Filters that needs to be matched by all issue labels. */
    every?: Maybe<IssueLabelFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the collection length. */
    length?: Maybe<NumberComparator>;
    /** Comparator for the name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the label. */
    or?: Maybe<Array<IssueLabelCollectionFilter>>;
    /** Filters that the issue label's parent label must satisfy. */
    parent?: Maybe<IssueLabelFilter>;
    /** Filters that needs to be matched by some issue labels. */
    some?: Maybe<IssueLabelFilter>;
    /** Filters that the issue labels team must satisfy. */
    team?: Maybe<NullableTeamFilter>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type IssueLabelConnection = {
    __typename?: "IssueLabelConnection";
    edges: Array<IssueLabelEdge>;
    nodes: Array<IssueLabel>;
    pageInfo: PageInfo;
};
export declare type IssueLabelCreateInput = {
    /** The color of the label. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the label. */
    description?: Maybe<Scalars["String"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The name of the label. */
    name: Scalars["String"];
    /** The identifier of the parent label. */
    parentId?: Maybe<Scalars["String"]>;
    /** The team associated with the label. If not given, the label will be associated with the entire workspace. */
    teamId?: Maybe<Scalars["String"]>;
};
export declare type IssueLabelEdge = {
    __typename?: "IssueLabelEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: IssueLabel;
};
/** Issue label filtering options. */
export declare type IssueLabelFilter = {
    /** Compound filters, all of which need to be matched by the label. */
    and?: Maybe<Array<IssueLabelFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the issue labels creator must satisfy. */
    creator?: Maybe<NullableUserFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the label. */
    or?: Maybe<Array<IssueLabelFilter>>;
    /** Filters that the issue label's parent label must satisfy. */
    parent?: Maybe<IssueLabelFilter>;
    /** Filters that the issue labels team must satisfy. */
    team?: Maybe<NullableTeamFilter>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type IssueLabelPayload = {
    __typename?: "IssueLabelPayload";
    /** The label that was created or updated. */
    issueLabel: IssueLabel;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type IssueLabelUpdateInput = {
    /** The color of the label. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the label. */
    description?: Maybe<Scalars["String"]>;
    /** The name of the label. */
    name?: Maybe<Scalars["String"]>;
    /** The identifier of the parent label. */
    parentId?: Maybe<Scalars["String"]>;
};
/** An issue related notification */
export declare type IssueNotification = Entity & Node & Notification & {
    __typename?: "IssueNotification";
    /** The user that caused the notification. */
    actor?: Maybe<User>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The comment related to the notification. */
    comment?: Maybe<Comment>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /**
     * The time at when an email reminder for this notification was sent to the user. Null, if no email
     *     reminder has been sent.
     */
    emailedAt?: Maybe<Scalars["DateTime"]>;
    /** The external user that caused the notification. */
    externalUserActor?: Maybe<ExternalUser>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The issue related to the notification. */
    issue: Issue;
    /** Name of the reaction emoji related to the notification. */
    reactionEmoji?: Maybe<Scalars["String"]>;
    /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
    readAt?: Maybe<Scalars["DateTime"]>;
    /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
    snoozedUntilAt?: Maybe<Scalars["DateTime"]>;
    /** The team related to the notification. */
    team: Team;
    /** Notification type */
    type: Scalars["String"];
    /** The time at which a notification was unsnoozed.. */
    unsnoozedAt?: Maybe<Scalars["DateTime"]>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user that received the notification. */
    user: User;
};
export declare type IssuePayload = {
    __typename?: "IssuePayload";
    /** The issue that was created or updated. */
    issue?: Maybe<Issue>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type IssuePriorityValue = {
    __typename?: "IssuePriorityValue";
    /** Priority's label. */
    label: Scalars["String"];
    /** Priority's number value. */
    priority: Scalars["Int"];
};
/** A relation between two issues. */
export declare type IssueRelation = Node & {
    __typename?: "IssueRelation";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The issue whose relationship is being described. */
    issue: Issue;
    /** The related issue. */
    relatedIssue: Issue;
    /** The relationship of the issue with the related issue. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type IssueRelationConnection = {
    __typename?: "IssueRelationConnection";
    edges: Array<IssueRelationEdge>;
    nodes: Array<IssueRelation>;
    pageInfo: PageInfo;
};
export declare type IssueRelationCreateInput = {
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifier of the issue that is related to another issue. */
    issueId: Scalars["String"];
    /** The identifier of the related issue. */
    relatedIssueId: Scalars["String"];
    /** The type of relation of the issue to the related issue. */
    type: IssueRelationType;
};
export declare type IssueRelationEdge = {
    __typename?: "IssueRelationEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: IssueRelation;
};
/** Issue relation history's payload */
export declare type IssueRelationHistoryPayload = {
    __typename?: "IssueRelationHistoryPayload";
    /** The identifier of the related issue. */
    identifier: Scalars["String"];
    /** The type of the change. */
    type: Scalars["String"];
};
export declare type IssueRelationPayload = {
    __typename?: "IssueRelationPayload";
    /** The issue relation that was created or updated. */
    issueRelation: IssueRelation;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** The type of the issue relation. */
export declare enum IssueRelationType {
    Blocks = "blocks",
    Duplicate = "duplicate",
    Related = "related"
}
export declare type IssueRelationUpdateInput = {
    /** The identifier of the issue that is related to another issue. */
    issueId?: Maybe<Scalars["String"]>;
    /** The identifier of the related issue. */
    relatedIssueId?: Maybe<Scalars["String"]>;
    /** The type of relation of the issue to the related issue. */
    type?: Maybe<Scalars["String"]>;
};
export declare type IssueSearchPayload = {
    __typename?: "IssueSearchPayload";
    /** Archived entities matching the search term along with all their dependencies. */
    archivePayload: ArchiveResponse;
    edges: Array<IssueSearchResultEdge>;
    nodes: Array<IssueSearchResult>;
    pageInfo: PageInfo;
    /** Total number of results for query without filters applied. */
    totalCount: Scalars["Float"];
};
export declare type IssueSearchResult = Node & {
    __typename?: "IssueSearchResult";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The user to whom the issue is assigned to. */
    assignee?: Maybe<User>;
    /** Attachments associated with the issue. */
    attachments: AttachmentConnection;
    /** The time at which the issue was automatically archived by the auto pruning process. */
    autoArchivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the issue was automatically closed by the auto pruning process. */
    autoClosedAt?: Maybe<Scalars["DateTime"]>;
    /**
     * The order of the item in its column on the board.
     * @deprecated Will be removed in near future, please use `sortOrder` instead
     */
    boardOrder: Scalars["Float"];
    /** Suggested branch name for the issue. */
    branchName: Scalars["String"];
    /** The time at which the issue was moved into canceled state. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** Children of the issue. */
    children: IssueConnection;
    /** Comments associated with the issue. */
    comments: CommentConnection;
    /** The time at which the issue was moved into completed state. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the issue. */
    creator?: Maybe<User>;
    /** Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk). */
    customerTicketCount: Scalars["Int"];
    /** The cycle that the issue is associated with. */
    cycle?: Maybe<Cycle>;
    /** The issue's description in markdown format. */
    description?: Maybe<Scalars["String"]>;
    /** [Internal] The issue's description as a Prosemirror document. */
    descriptionData?: Maybe<Scalars["JSON"]>;
    /** The date at which the issue is due. */
    dueDate?: Maybe<Scalars["TimelessDate"]>;
    /** The estimate of the complexity of the issue.. */
    estimate?: Maybe<Scalars["Float"]>;
    /** [ALPHA] The external user who created the issue. */
    externalUserCreator?: Maybe<ExternalUser>;
    /** The users favorite associated with this issue. */
    favorite?: Maybe<Favorite>;
    /** History entries associated with the issue. */
    history: IssueHistoryConnection;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Issue's human readable identifier (e.g. ENG-123). */
    identifier: Scalars["String"];
    /** Inverse relations associated with this issue. */
    inverseRelations: IssueRelationConnection;
    /** Labels associated with this issue. */
    labels: IssueLabelConnection;
    /** Metadata related to search result */
    metadata: Scalars["JSONObject"];
    /** The issue's unique number. */
    number: Scalars["Float"];
    /** The parent of the issue. */
    parent?: Maybe<Issue>;
    /** Previous identifiers of the issue if it has been moved between teams. */
    previousIdentifiers: Array<Scalars["String"]>;
    /** The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low. */
    priority: Scalars["Float"];
    /** Label for the priority. */
    priorityLabel: Scalars["String"];
    /** The project that the issue is associated with. */
    project?: Maybe<Project>;
    /** The projectMilestone that the issue is associated with. */
    projectMilestone?: Maybe<ProjectMilestone>;
    /** Relations associated with this issue. */
    relations: IssueRelationConnection;
    /** [Internal] The time at which the issue's SLA will breach. */
    slaBreachesAt?: Maybe<Scalars["DateTime"]>;
    /** [Internal] The time at which the issue's SLA began. */
    slaStartedAt?: Maybe<Scalars["DateTime"]>;
    /** The user who snoozed the issue. */
    snoozedBy?: Maybe<User>;
    /** The time until an issue will be snoozed in Triage view. */
    snoozedUntilAt?: Maybe<Scalars["DateTime"]>;
    /** The order of the item in relation to other items in the organization. */
    sortOrder: Scalars["Float"];
    /** The time at which the issue was moved into started state. */
    startedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the issue entered triage. */
    startedTriageAt?: Maybe<Scalars["DateTime"]>;
    /** The workflow state that the issue is associated with. */
    state: WorkflowState;
    /** The order of the item in the sub-issue list. Only set if the issue has a parent. */
    subIssueSortOrder?: Maybe<Scalars["Float"]>;
    /** Users who are subscribed to the issue. */
    subscribers: UserConnection;
    /** The team that the issue is associated with. */
    team: Team;
    /** The issue's title. */
    title: Scalars["String"];
    /** A flag that indicates whether the issue is in the trash bin. */
    trashed?: Maybe<Scalars["Boolean"]>;
    /** The time at which the issue left triage. */
    triagedAt?: Maybe<Scalars["DateTime"]>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Issue URL. */
    url: Scalars["String"];
};
export declare type IssueSearchResultAttachmentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<AttachmentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type IssueSearchResultChildrenArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type IssueSearchResultCommentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CommentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type IssueSearchResultHistoryArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type IssueSearchResultInverseRelationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type IssueSearchResultLabelsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type IssueSearchResultRelationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type IssueSearchResultSubscribersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type IssueSearchResultConnection = {
    __typename?: "IssueSearchResultConnection";
    edges: Array<IssueSearchResultEdge>;
    nodes: Array<IssueSearchResult>;
    pageInfo: PageInfo;
};
export declare type IssueSearchResultEdge = {
    __typename?: "IssueSearchResultEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: IssueSearchResult;
};
export declare type IssueUpdateInput = {
    /** The identifier of the user to assign the issue to. */
    assigneeId?: Maybe<Scalars["String"]>;
    /** The position of the issue in its column on the board view. */
    boardOrder?: Maybe<Scalars["Float"]>;
    /** The identifiers of the companies associated with this ticket. */
    companyIds?: Maybe<Array<Scalars["String"]>>;
    /** The cycle associated with the issue. */
    cycleId?: Maybe<Scalars["String"]>;
    /** The issue description in markdown format. */
    description?: Maybe<Scalars["String"]>;
    /** The issue description as a Prosemirror document. */
    descriptionData?: Maybe<Scalars["JSON"]>;
    /** The date at which the issue is due. */
    dueDate?: Maybe<Scalars["TimelessDate"]>;
    /** The estimated complexity of the issue. */
    estimate?: Maybe<Scalars["Int"]>;
    /** The identifiers of the issue labels associated with this ticket. */
    labelIds?: Maybe<Array<Scalars["String"]>>;
    /** The identifier of the parent issue. */
    parentId?: Maybe<Scalars["String"]>;
    /** The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low. */
    priority?: Maybe<Scalars["Int"]>;
    /** The project associated with the issue. */
    projectId?: Maybe<Scalars["String"]>;
    /** The project milestone associated with the issue. */
    projectMilestoneId?: Maybe<Scalars["String"]>;
    /** [Internal] The timestamp at which an issue will be considered in breach of SLA. */
    slaBreachesAt?: Maybe<Scalars["DateTime"]>;
    /** The identifier of the user who snoozed the issue. */
    snoozedById?: Maybe<Scalars["String"]>;
    /** The time until an issue will be snoozed in Triage view. */
    snoozedUntilAt?: Maybe<Scalars["DateTime"]>;
    /** The position of the issue related to other issues. */
    sortOrder?: Maybe<Scalars["Float"]>;
    /** The team state of the issue. */
    stateId?: Maybe<Scalars["String"]>;
    /** The position of the issue in parent's sub-issue list. */
    subIssueSortOrder?: Maybe<Scalars["Float"]>;
    /** The identifiers of the users subscribing to this ticket. */
    subscriberIds?: Maybe<Array<Scalars["String"]>>;
    /** The identifier or key of the team associated with the issue. */
    teamId?: Maybe<Scalars["String"]>;
    /** The issue title. */
    title?: Maybe<Scalars["String"]>;
    /** Wether the issue has been trashed. */
    trashed?: Maybe<Scalars["Boolean"]>;
};
export declare type JiraConfigurationInput = {
    /** The Jira personal access token. */
    accessToken: Scalars["String"];
    /** The Jira user's email address. */
    email: Scalars["String"];
    /** The Jira installation hostname. */
    hostname: Scalars["String"];
    /** The Jira project keys to scope the integration to. */
    project?: Maybe<Scalars["String"]>;
};
/** Tuple for mapping Jira projects to Linear teams. */
export declare type JiraLinearMapping = {
    __typename?: "JiraLinearMapping";
    /** The Jira id for this project. */
    jiraProjectId: Scalars["String"];
    /** The Linear team id to map to the given project. */
    linearTeamId: Scalars["String"];
};
export declare type JiraLinearMappingInput = {
    /** The Jira id for this project. */
    jiraProjectId: Scalars["String"];
    /** The Linear team id to map to the given project. */
    linearTeamId: Scalars["String"];
};
/** Metadata about a Jira project. */
export declare type JiraProjectData = {
    __typename?: "JiraProjectData";
    /** The Jira id for this project. */
    id: Scalars["String"];
    /** The Jira key for this project, such as ENG. */
    key: Scalars["String"];
    /** The Jira name for this project, such as Engineering. */
    name: Scalars["String"];
};
export declare type JiraProjectDataInput = {
    /** The Jira id for this project. */
    id: Scalars["String"];
    /** The Jira key for this project, such as ENG. */
    key: Scalars["String"];
    /** The Jira name for this project, such as Engineering. */
    name: Scalars["String"];
};
/** Jira specific settings. */
export declare type JiraSettings = {
    __typename?: "JiraSettings";
    /** The mapping of Jira project id => Linear team id. */
    projectMapping?: Maybe<Array<JiraLinearMapping>>;
    /** The Jira projects for the organization. */
    projects: Array<JiraProjectData>;
};
export declare type JiraSettingsInput = {
    /** The mapping of Jira project id => Linear team id. */
    projectMapping?: Maybe<Array<JiraLinearMappingInput>>;
    /** The Jira projects for the organization. */
    projects: Array<JiraProjectDataInput>;
};
export declare type JoinOrganizationInput = {
    /** The identifier of the organization. */
    organizationId: Scalars["String"];
};
/** A label notification subscription. */
export declare type LabelNotificationSubscription = Entity & Node & NotificationSubscription & {
    __typename?: "LabelNotificationSubscription";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The type of view to which the notification subscription context is associated with. */
    contextViewType?: Maybe<ContextViewType>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The contextual custom view associated with the notification subscription. */
    customView?: Maybe<CustomView>;
    /** The contextual cycle view associated with the notification subscription. */
    cycle?: Maybe<Cycle>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The label subscribed to. */
    label: IssueLabel;
    /** The type of subscription. */
    notificationSubscriptionTypes: Array<Scalars["String"]>;
    /** The contextual project view associated with the notification subscription. */
    project?: Maybe<Project>;
    /** The user that subscribed to receive notifications. */
    subscriber: User;
    /** The team associated with the notification subscription. */
    team?: Maybe<Team>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user view associated with the notification subscription. */
    user?: Maybe<User>;
    /** The type of user view to which the notification subscription context is associated with. */
    userContextViewType?: Maybe<UserContextViewType>;
};
export declare type LogoutResponse = {
    __typename?: "LogoutResponse";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type Mutation = {
    __typename?: "Mutation";
    /** Creates an integration api key for Airbyte to connect with Linear */
    airbyteIntegrationConnect: IntegrationPayload;
    /** Creates a new API key. */
    apiKeyCreate: ApiKeyPayload;
    /** Deletes an API key. */
    apiKeyDelete: DeletePayload;
    /**
     * [DEPRECATED] Archives an issue attachment.
     * @deprecated This mutation is deprecated, please use `attachmentDelete` instead
     */
    attachmentArchive: AttachmentArchivePayload;
    /** Creates a new attachment, or updates existing if the same `url` and `issueId` is used. */
    attachmentCreate: AttachmentPayload;
    /** Deletes an issue attachment. */
    attachmentDelete: DeletePayload;
    /** Link an existing Discord message to an issue. */
    attachmentLinkDiscord: AttachmentPayload;
    /** Link an existing Front conversation to an issue. */
    attachmentLinkFront: FrontAttachmentPayload;
    /** Link an existing Intercom conversation to an issue. */
    attachmentLinkIntercom: AttachmentPayload;
    /** Link an existing Jira issue to an issue. */
    attachmentLinkJiraIssue: AttachmentPayload;
    /** Link an existing Slack message to an issue. */
    attachmentLinkSlack: AttachmentPayload;
    /** Link any url to an issue. */
    attachmentLinkURL: AttachmentPayload;
    /** Link an existing Zendesk ticket to an issue. */
    attachmentLinkZendesk: AttachmentPayload;
    /** Unsyncs an existing synced Slack attachment. */
    attachmentUnsyncSlack: AttachmentPayload;
    /** Updates an existing issue attachment. */
    attachmentUpdate: AttachmentPayload;
    /** Creates a new comment. */
    commentCreate: CommentPayload;
    /** Deletes a comment. */
    commentDelete: DeletePayload;
    /** Updates a comment. */
    commentUpdate: CommentPayload;
    /** Saves user message. */
    contactCreate: ContactPayload;
    /** [INTERNAL] Saves sales pricing inquiry to Front. */
    contactSalesCreate: ContactPayload;
    /** Create CSV export report for the organization. */
    createCsvExportReport: CreateCsvExportReportPayload;
    /** Creates an organization from onboarding. */
    createOrganizationFromOnboarding: CreateOrJoinOrganizationResponse;
    /** Creates a new custom view. */
    customViewCreate: CustomViewPayload;
    /** Deletes a custom view. */
    customViewDelete: DeletePayload;
    /** Updates a custom view. */
    customViewUpdate: CustomViewPayload;
    /** Archives a cycle. */
    cycleArchive: CycleArchivePayload;
    /** Creates a new cycle. */
    cycleCreate: CyclePayload;
    /** Updates a cycle. */
    cycleUpdate: CyclePayload;
    /** Creates a new document. */
    documentCreate: DocumentPayload;
    /** Deletes a document. */
    documentDelete: DeletePayload;
    /** Updates a document. */
    documentUpdate: DocumentPayload;
    /** [INTERNAL] Subscribes the email to the newsletter. */
    emailSubscribe: EmailSubscribePayload;
    /** Authenticates a user account via email and authentication token. */
    emailTokenUserAccountAuth: AuthResolverResponse;
    /** Unsubscribes the user from one type of emails. */
    emailUnsubscribe: EmailUnsubscribePayload;
    /** Finds or creates a new user account by email and sends an email with token. */
    emailUserAccountAuthChallenge: EmailUserAccountAuthChallengeResponse;
    /** Creates a custom emoji. */
    emojiCreate: EmojiPayload;
    /** Deletes an emoji. */
    emojiDelete: DeletePayload;
    /** Creates a new favorite (project, cycle etc). */
    favoriteCreate: FavoritePayload;
    /** Deletes a favorite reference. */
    favoriteDelete: DeletePayload;
    /** Updates a favorite. */
    favoriteUpdate: FavoritePayload;
    /** XHR request payload to upload an images, video and other attachments directly to Linear's cloud storage. */
    fileUpload: UploadPayload;
    /** Authenticate user account through Google OAuth. This is the 2nd step of OAuth flow. */
    googleUserAccountAuth: AuthResolverResponse;
    /** Upload an image from an URL to Linear. */
    imageUploadFromUrl: ImageUploadFromUrlPayload;
    /** XHR request payload to upload a file for import, directly to Linear's cloud storage. */
    importFileUpload: UploadPayload;
    /** Deletes an integration. */
    integrationDelete: DeletePayload;
    /** Integrates the organization with Discord. */
    integrationDiscord: IntegrationPayload;
    /** Integrates the organization with Figma. */
    integrationFigma: IntegrationPayload;
    /** Integrates the organization with Front. */
    integrationFront: IntegrationPayload;
    /** Generates a webhook for the GitHub commit integration. */
    integrationGithubCommitCreate: GitHubCommitIntegrationPayload;
    /** Connects the organization with the GitHub App. */
    integrationGithubConnect: IntegrationPayload;
    /** Connects the organization with a GitLab Access Token. */
    integrationGitlabConnect: IntegrationPayload;
    /** Integrates the organization with Google Sheets. */
    integrationGoogleSheets: IntegrationPayload;
    /** Integrates the organization with Intercom. */
    integrationIntercom: IntegrationPayload;
    /** Disconnects the organization from Intercom. */
    integrationIntercomDelete: IntegrationPayload;
    /**
     * [DEPRECATED] Updates settings on the Intercom integration.
     * @deprecated This mutation is deprecated, please use `integrationSettingsUpdate` instead
     */
    integrationIntercomSettingsUpdate: IntegrationPayload;
    /**
     * Enables Loom integration for the organization.
     * @deprecated Not available.
     */
    integrationLoom: IntegrationPayload;
    /** [INTERNAL] Integrates the organization with PagerDuty. */
    integrationPageDutyConnect: IntegrationPayload;
    /** Requests a currently unavailable integration. */
    integrationRequest: IntegrationRequestPayload;
    /** Integrates the organization with Sentry. */
    integrationSentryConnect: IntegrationPayload;
    /** [INTERNAL] Updates the integration. */
    integrationSettingsUpdate: IntegrationPayload;
    /** Integrates the organization with Slack. */
    integrationSlack: IntegrationPayload;
    /** Integrates the organization with the Slack Asks app */
    integrationSlackAsks: IntegrationPayload;
    /** Imports custom emojis from your Slack workspace. */
    integrationSlackImportEmojis: IntegrationPayload;
    /** Slack integration for organization level project update notifications. */
    integrationSlackOrgProjectUpdatesPost: IntegrationPayload;
    /** Integrates your personal notifications with Slack. */
    integrationSlackPersonal: IntegrationPayload;
    /** Slack webhook integration. */
    integrationSlackPost: IntegrationPayload;
    /** Slack integration for project notifications. */
    integrationSlackProjectPost: IntegrationPayload;
    /** Creates a new integrationTemplate join. */
    integrationTemplateCreate: IntegrationTemplatePayload;
    /** Deletes a integrationTemplate. */
    integrationTemplateDelete: DeletePayload;
    /** Updates the organization's Slack integration. */
    integrationUpdateSlack: IntegrationPayload;
    /** Integrates the organization with Zendesk. */
    integrationZendesk: IntegrationPayload;
    /** Creates new settings for one or more integrations. */
    integrationsSettingsCreate: IntegrationsSettingsPayload;
    /** Updates settings related to integrations for a project or a team. */
    integrationsSettingsUpdate: IntegrationsSettingsPayload;
    /** Archives an issue. */
    issueArchive: IssueArchivePayload;
    /** Updates multiple issues at once. */
    issueBatchUpdate: IssueBatchPayload;
    /** Creates a new issue. */
    issueCreate: IssuePayload;
    /** Deletes (trashes) an issue. */
    issueDelete: IssueArchivePayload;
    /** [INTERNAL] Updates an issue description from the Front app to handle Front attachments correctly. */
    issueDescriptionUpdateFromFront: IssuePayload;
    /** Kicks off an Asana import job. */
    issueImportCreateAsana: IssueImportPayload;
    /** Kicks off a Jira import job from a CSV. */
    issueImportCreateCSVJira: IssueImportPayload;
    /** Kicks off a Shortcut (formerly Clubhouse) import job. */
    issueImportCreateClubhouse: IssueImportPayload;
    /** Kicks off a GitHub import job. */
    issueImportCreateGithub: IssueImportPayload;
    /** Kicks off a Jira import job. */
    issueImportCreateJira: IssueImportPayload;
    /** Deletes an import job. */
    issueImportDelete: IssueImportDeletePayload;
    /** Kicks off import processing. */
    issueImportProcess: IssueImportPayload;
    /** Updates the mapping for the issue import. */
    issueImportUpdate: IssueImportPayload;
    /** Creates a new label. */
    issueLabelCreate: IssueLabelPayload;
    /** Deletes an issue label. */
    issueLabelDelete: DeletePayload;
    /** Updates an label. */
    issueLabelUpdate: IssueLabelPayload;
    /** Creates a new issue relation. */
    issueRelationCreate: IssueRelationPayload;
    /** Deletes an issue relation. */
    issueRelationDelete: DeletePayload;
    /** Updates an issue relation. */
    issueRelationUpdate: IssueRelationPayload;
    /** Adds an issue reminder. Will cause a notification to be sent when the issue reminder time is reached. */
    issueReminder: IssuePayload;
    /** Unarchives an issue. */
    issueUnarchive: IssueArchivePayload;
    /** Updates an issue. */
    issueUpdate: IssuePayload;
    /** [INTERNAL] Connects the organization with a Jira Personal Access Token. */
    jiraIntegrationConnect: IntegrationPayload;
    /** Join an organization from onboarding. */
    joinOrganizationFromOnboarding: CreateOrJoinOrganizationResponse;
    /** Leave an organization. */
    leaveOrganization: CreateOrJoinOrganizationResponse;
    /** Logout of all clients. */
    logout: LogoutResponse;
    /** Archives a notification. */
    notificationArchive: NotificationArchivePayload;
    /** Archives all of the user's past notifications for the associated entity. */
    notificationArchiveAll: NotificationBatchActionPayload;
    /** Marks all past notifications for the associated entity as read. */
    notificationMarkReadAll: NotificationBatchActionPayload;
    /** Marks all past notifications for the associated entity as unread. */
    notificationMarkUnreadAll: NotificationBatchActionPayload;
    /** Snoozes a notification and all past notifications for the associated entity. */
    notificationSnoozeAll: NotificationBatchActionPayload;
    /** Creates a new notification subscription for a cycle, custom view, label, project or team. */
    notificationSubscriptionCreate: NotificationSubscriptionPayload;
    /** Deletes a notification subscription reference. */
    notificationSubscriptionDelete: DeletePayload;
    /** Updates a notification subscription. */
    notificationSubscriptionUpdate: NotificationSubscriptionPayload;
    /** Unarchives a notification. */
    notificationUnarchive: NotificationArchivePayload;
    /** Unsnoozes a notification and all past notifications for the associated entity. */
    notificationUnsnoozeAll: NotificationBatchActionPayload;
    /** Updates a notification. */
    notificationUpdate: NotificationPayload;
    /** Cancels the deletion of an organization. Administrator privileges required. */
    organizationCancelDelete: OrganizationCancelDeletePayload;
    /** Delete's an organization. Administrator privileges required. */
    organizationDelete: OrganizationDeletePayload;
    /** Get an organization's delete confirmation token. Administrator privileges required. */
    organizationDeleteChallenge: OrganizationDeletePayload;
    /** [INTERNAL] Verifies a domain claim. */
    organizationDomainClaim: OrganizationDomainSimplePayload;
    /** [INTERNAL] Adds a domain to be allowed for an organization. */
    organizationDomainCreate: OrganizationDomainPayload;
    /** Deletes a domain. */
    organizationDomainDelete: DeletePayload;
    /** [INTERNAL] Verifies a domain to be added to an organization. */
    organizationDomainVerify: OrganizationDomainPayload;
    /** Creates a new organization invite. */
    organizationInviteCreate: OrganizationInvitePayload;
    /** Deletes an organization invite. */
    organizationInviteDelete: DeletePayload;
    /** Updates an organization invite. */
    organizationInviteUpdate: OrganizationInvitePayload;
    /** Starts a plus trial for the organization. Administrator privileges required. */
    organizationStartPlusTrial: OrganizationStartPlusTrialPayload;
    /** Updates the user's organization. */
    organizationUpdate: OrganizationPayload;
    /**
     * Archives a project.
     * @deprecated Deprecated in favor of projectDelete.
     */
    projectArchive: ProjectArchivePayload;
    /** Creates a new project. */
    projectCreate: ProjectPayload;
    /** Deletes a project. All issues will be disassociated from the deleted project. */
    projectDelete: DeletePayload;
    /** Creates a new project link. */
    projectLinkCreate: ProjectLinkPayload;
    /** Deletes a project link. */
    projectLinkDelete: DeletePayload;
    /** Updates a project link. */
    projectLinkUpdate: ProjectLinkPayload;
    /** Creates a new project milestone. */
    projectMilestoneCreate: ProjectMilestonePayload;
    /** Deletes a project milestone. */
    projectMilestoneDelete: DeletePayload;
    /** Updates a project milestone. */
    projectMilestoneUpdate: ProjectMilestonePayload;
    /** Unarchives a project. */
    projectUnarchive: ProjectArchivePayload;
    /** Updates a project. */
    projectUpdate: ProjectPayload;
    /** Creates a new project update. */
    projectUpdateCreate: ProjectUpdatePayload;
    /** Deletes a project update. */
    projectUpdateDelete: DeletePayload;
    /** Creates a new interaction on a project update. */
    projectUpdateInteractionCreate: ProjectUpdateInteractionPayload;
    /** Mark a project update as read. */
    projectUpdateMarkAsRead: ProjectUpdateWithInteractionPayload;
    /** Updates a project update. */
    projectUpdateUpdate: ProjectUpdatePayload;
    /** Creates a push subscription. */
    pushSubscriptionCreate: PushSubscriptionPayload;
    /** Deletes a push subscription. */
    pushSubscriptionDelete: PushSubscriptionPayload;
    /** Creates a new reaction. */
    reactionCreate: ReactionPayload;
    /** Deletes a reaction. */
    reactionDelete: DeletePayload;
    /** Manually update Google Sheets data. */
    refreshGoogleSheetsData: IntegrationPayload;
    /** Re-send an organization invite. */
    resendOrganizationInvite: DeletePayload;
    /** Archives a roadmap. */
    roadmapArchive: RoadmapArchivePayload;
    /** Creates a new roadmap. */
    roadmapCreate: RoadmapPayload;
    /** Deletes a roadmap. */
    roadmapDelete: DeletePayload;
    /** Creates a new roadmapToProject join. */
    roadmapToProjectCreate: RoadmapToProjectPayload;
    /** Deletes a roadmapToProject. */
    roadmapToProjectDelete: DeletePayload;
    /** Updates a roadmapToProject. */
    roadmapToProjectUpdate: RoadmapToProjectPayload;
    /** Unarchives a roadmap. */
    roadmapUnarchive: RoadmapArchivePayload;
    /** Updates a roadmap. */
    roadmapUpdate: RoadmapPayload;
    /** Authenticates a user account via email and authentication token for SAML. */
    samlTokenUserAccountAuth: AuthResolverResponse;
    /** Creates a new team. The user who creates the team will automatically be added as a member to the newly created team. */
    teamCreate: TeamPayload;
    /** Deletes team's cycles data */
    teamCyclesDelete: TeamPayload;
    /** Deletes a team. */
    teamDelete: DeletePayload;
    /** Deletes a previously used team key. */
    teamKeyDelete: DeletePayload;
    /** Creates a new team membership. */
    teamMembershipCreate: TeamMembershipPayload;
    /** Deletes a team membership. */
    teamMembershipDelete: DeletePayload;
    /** Updates a team membership. */
    teamMembershipUpdate: TeamMembershipPayload;
    /** Updates a team. */
    teamUpdate: TeamPayload;
    /** Creates a new template. */
    templateCreate: TemplatePayload;
    /** Deletes a template. */
    templateDelete: DeletePayload;
    /** Updates an existing template. */
    templateUpdate: TemplatePayload;
    /** Makes user a regular user. Can only be called by an admin. */
    userDemoteAdmin: UserAdminPayload;
    /** Makes user a guest. Can only be called by an admin. */
    userDemoteMember: UserAdminPayload;
    /** Connects the Discord user to this Linear account via OAuth2. */
    userDiscordConnect: UserPayload;
    /** Disconnects the external user from this Linear account. */
    userExternalUserDisconnect: UserPayload;
    /** Updates a user's settings flag. */
    userFlagUpdate: UserSettingsFlagPayload;
    /** Connects the GitHub user to this Linear account via OAuth2. */
    userGitHubConnect: UserPayload;
    /** Connects the Google Calendar to the user to this Linear account via OAuth2. */
    userGoogleCalendarConnect: UserPayload;
    /** Connects the Jira user to this Linear account via OAuth2. */
    userJiraConnect: UserPayload;
    /** Makes user an admin. Can only be called by an admin. */
    userPromoteAdmin: UserAdminPayload;
    /** Makes user a regular user. Can only be called by an admin. */
    userPromoteMember: UserAdminPayload;
    /** [Deprecated] Updates a user's settings flag. */
    userSettingsFlagIncrement: UserSettingsFlagPayload;
    /** Resets user's setting flags. */
    userSettingsFlagsReset: UserSettingsFlagsResetPayload;
    /** Updates the user's settings. */
    userSettingsUpdate: UserSettingsPayload;
    /** Suspends a user. Can only be called by an admin. */
    userSuspend: UserAdminPayload;
    /** Un-suspends a user. Can only be called by an admin. */
    userUnsuspend: UserAdminPayload;
    /** Updates a user. Only available to organization admins and the user themselves. */
    userUpdate: UserPayload;
    /** Creates a new ViewPreferences object. */
    viewPreferencesCreate: ViewPreferencesPayload;
    /** Deletes a ViewPreferences. */
    viewPreferencesDelete: DeletePayload;
    /** Updates an existing ViewPreferences object. */
    viewPreferencesUpdate: ViewPreferencesPayload;
    /** Creates a new webhook. */
    webhookCreate: WebhookPayload;
    /** Deletes a Webhook. */
    webhookDelete: DeletePayload;
    /** Updates an existing Webhook. */
    webhookUpdate: WebhookPayload;
    /** Archives a state. Only states with issues that have all been archived can be archived. */
    workflowStateArchive: WorkflowStateArchivePayload;
    /** Creates a new state, adding it to the workflow of a team. */
    workflowStateCreate: WorkflowStatePayload;
    /** Updates a state. */
    workflowStateUpdate: WorkflowStatePayload;
};
export declare type MutationAirbyteIntegrationConnectArgs = {
    input: AirbyteConfigurationInput;
};
export declare type MutationApiKeyCreateArgs = {
    input: ApiKeyCreateInput;
};
export declare type MutationApiKeyDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationAttachmentArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationAttachmentCreateArgs = {
    input: AttachmentCreateInput;
};
export declare type MutationAttachmentDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationAttachmentLinkDiscordArgs = {
    channelId: Scalars["String"];
    issueId: Scalars["String"];
    messageId: Scalars["String"];
    url: Scalars["String"];
};
export declare type MutationAttachmentLinkFrontArgs = {
    conversationId: Scalars["String"];
    issueId: Scalars["String"];
};
export declare type MutationAttachmentLinkIntercomArgs = {
    conversationId: Scalars["String"];
    issueId: Scalars["String"];
};
export declare type MutationAttachmentLinkJiraIssueArgs = {
    issueId: Scalars["String"];
    jiraIssueId: Scalars["String"];
};
export declare type MutationAttachmentLinkSlackArgs = {
    channel: Scalars["String"];
    id?: Maybe<Scalars["String"]>;
    issueId: Scalars["String"];
    latest: Scalars["String"];
    title?: Maybe<Scalars["String"]>;
    ts?: Maybe<Scalars["String"]>;
    url: Scalars["String"];
};
export declare type MutationAttachmentLinkUrlArgs = {
    id?: Maybe<Scalars["String"]>;
    issueId: Scalars["String"];
    title?: Maybe<Scalars["String"]>;
    url: Scalars["String"];
};
export declare type MutationAttachmentLinkZendeskArgs = {
    issueId: Scalars["String"];
    ticketId: Scalars["String"];
};
export declare type MutationAttachmentUnsyncSlackArgs = {
    id: Scalars["String"];
};
export declare type MutationAttachmentUpdateArgs = {
    id: Scalars["String"];
    input: AttachmentUpdateInput;
};
export declare type MutationCommentCreateArgs = {
    input: CommentCreateInput;
};
export declare type MutationCommentDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationCommentUpdateArgs = {
    id: Scalars["String"];
    input: CommentUpdateInput;
};
export declare type MutationContactCreateArgs = {
    input: ContactCreateInput;
};
export declare type MutationContactSalesCreateArgs = {
    input: ContactSalesCreateInput;
};
export declare type MutationCreateCsvExportReportArgs = {
    includePrivateTeamIds?: Maybe<Array<Scalars["String"]>>;
};
export declare type MutationCreateOrganizationFromOnboardingArgs = {
    input: CreateOrganizationInput;
    survey?: Maybe<OnboardingCustomerSurvey>;
};
export declare type MutationCustomViewCreateArgs = {
    input: CustomViewCreateInput;
};
export declare type MutationCustomViewDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationCustomViewUpdateArgs = {
    id: Scalars["String"];
    input: CustomViewUpdateInput;
};
export declare type MutationCycleArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationCycleCreateArgs = {
    input: CycleCreateInput;
};
export declare type MutationCycleUpdateArgs = {
    id: Scalars["String"];
    input: CycleUpdateInput;
};
export declare type MutationDocumentCreateArgs = {
    input: DocumentCreateInput;
};
export declare type MutationDocumentDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationDocumentUpdateArgs = {
    id: Scalars["String"];
    input: DocumentUpdateInput;
};
export declare type MutationEmailSubscribeArgs = {
    input: EmailSubscribeInput;
};
export declare type MutationEmailTokenUserAccountAuthArgs = {
    input: TokenUserAccountAuthInput;
};
export declare type MutationEmailUnsubscribeArgs = {
    input: EmailUnsubscribeInput;
};
export declare type MutationEmailUserAccountAuthChallengeArgs = {
    input: EmailUserAccountAuthChallengeInput;
};
export declare type MutationEmojiCreateArgs = {
    input: EmojiCreateInput;
};
export declare type MutationEmojiDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationFavoriteCreateArgs = {
    input: FavoriteCreateInput;
};
export declare type MutationFavoriteDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationFavoriteUpdateArgs = {
    id: Scalars["String"];
    input: FavoriteUpdateInput;
};
export declare type MutationFileUploadArgs = {
    contentType: Scalars["String"];
    filename: Scalars["String"];
    makePublic?: Maybe<Scalars["Boolean"]>;
    metaData?: Maybe<Scalars["JSON"]>;
    size: Scalars["Int"];
};
export declare type MutationGoogleUserAccountAuthArgs = {
    input: GoogleUserAccountAuthInput;
};
export declare type MutationImageUploadFromUrlArgs = {
    url: Scalars["String"];
};
export declare type MutationImportFileUploadArgs = {
    contentType: Scalars["String"];
    filename: Scalars["String"];
    metaData?: Maybe<Scalars["JSON"]>;
    size: Scalars["Int"];
};
export declare type MutationIntegrationDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationIntegrationDiscordArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationFigmaArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationFrontArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationGithubConnectArgs = {
    installationId: Scalars["String"];
};
export declare type MutationIntegrationGitlabConnectArgs = {
    accessToken: Scalars["String"];
    gitlabUrl: Scalars["String"];
};
export declare type MutationIntegrationGoogleSheetsArgs = {
    code: Scalars["String"];
};
export declare type MutationIntegrationIntercomArgs = {
    code: Scalars["String"];
    domainUrl?: Maybe<Scalars["String"]>;
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationIntercomSettingsUpdateArgs = {
    input: IntercomSettingsInput;
};
export declare type MutationIntegrationPageDutyConnectArgs = {
    apiToken: Scalars["String"];
};
export declare type MutationIntegrationRequestArgs = {
    input: IntegrationRequestInput;
};
export declare type MutationIntegrationSentryConnectArgs = {
    code: Scalars["String"];
    installationId: Scalars["String"];
    organizationSlug: Scalars["String"];
};
export declare type MutationIntegrationSettingsUpdateArgs = {
    id: Scalars["String"];
    input: IntegrationSettingsInput;
};
export declare type MutationIntegrationSlackArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    shouldUseV2Auth?: Maybe<Scalars["Boolean"]>;
};
export declare type MutationIntegrationSlackAsksArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationSlackImportEmojisArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationSlackOrgProjectUpdatesPostArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationSlackPersonalArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationSlackPostArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    shouldUseV2Auth?: Maybe<Scalars["Boolean"]>;
    teamId: Scalars["String"];
};
export declare type MutationIntegrationSlackProjectPostArgs = {
    code: Scalars["String"];
    projectId: Scalars["String"];
    redirectUri: Scalars["String"];
    service: Scalars["String"];
};
export declare type MutationIntegrationTemplateCreateArgs = {
    input: IntegrationTemplateCreateInput;
};
export declare type MutationIntegrationTemplateDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationIntegrationUpdateSlackArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationIntegrationZendeskArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    scope: Scalars["String"];
    subdomain: Scalars["String"];
};
export declare type MutationIntegrationsSettingsCreateArgs = {
    input: IntegrationsSettingsCreateInput;
};
export declare type MutationIntegrationsSettingsUpdateArgs = {
    id: Scalars["String"];
    input: IntegrationsSettingsUpdateInput;
};
export declare type MutationIssueArchiveArgs = {
    id: Scalars["String"];
    trash?: Maybe<Scalars["Boolean"]>;
};
export declare type MutationIssueBatchUpdateArgs = {
    ids: Array<Scalars["UUID"]>;
    input: IssueUpdateInput;
};
export declare type MutationIssueCreateArgs = {
    input: IssueCreateInput;
};
export declare type MutationIssueDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationIssueDescriptionUpdateFromFrontArgs = {
    description: Scalars["String"];
    id: Scalars["String"];
};
export declare type MutationIssueImportCreateAsanaArgs = {
    asanaTeamName: Scalars["String"];
    asanaToken: Scalars["String"];
    id?: Maybe<Scalars["String"]>;
    includeClosedIssues?: Maybe<Scalars["Boolean"]>;
    instantProcess?: Maybe<Scalars["Boolean"]>;
    organizationId?: Maybe<Scalars["String"]>;
    teamId?: Maybe<Scalars["String"]>;
    teamName?: Maybe<Scalars["String"]>;
};
export declare type MutationIssueImportCreateCsvJiraArgs = {
    csvUrl: Scalars["String"];
    jiraEmail?: Maybe<Scalars["String"]>;
    jiraHostname?: Maybe<Scalars["String"]>;
    jiraToken?: Maybe<Scalars["String"]>;
    organizationId?: Maybe<Scalars["String"]>;
    teamId?: Maybe<Scalars["String"]>;
    teamName?: Maybe<Scalars["String"]>;
};
export declare type MutationIssueImportCreateClubhouseArgs = {
    clubhouseGroupName: Scalars["String"];
    clubhouseToken: Scalars["String"];
    id?: Maybe<Scalars["String"]>;
    includeClosedIssues?: Maybe<Scalars["Boolean"]>;
    instantProcess?: Maybe<Scalars["Boolean"]>;
    organizationId?: Maybe<Scalars["String"]>;
    teamId?: Maybe<Scalars["String"]>;
    teamName?: Maybe<Scalars["String"]>;
};
export declare type MutationIssueImportCreateGithubArgs = {
    githubRepoName: Scalars["String"];
    githubRepoOwner: Scalars["String"];
    githubShouldImportOrgProjects?: Maybe<Scalars["Boolean"]>;
    githubToken: Scalars["String"];
    id?: Maybe<Scalars["String"]>;
    includeClosedIssues?: Maybe<Scalars["Boolean"]>;
    instantProcess?: Maybe<Scalars["Boolean"]>;
    organizationId?: Maybe<Scalars["String"]>;
    teamId?: Maybe<Scalars["String"]>;
    teamName?: Maybe<Scalars["String"]>;
};
export declare type MutationIssueImportCreateJiraArgs = {
    id?: Maybe<Scalars["String"]>;
    includeClosedIssues?: Maybe<Scalars["Boolean"]>;
    instantProcess?: Maybe<Scalars["Boolean"]>;
    jiraEmail: Scalars["String"];
    jiraHostname: Scalars["String"];
    jiraProject: Scalars["String"];
    jiraToken: Scalars["String"];
    organizationId?: Maybe<Scalars["String"]>;
    teamId?: Maybe<Scalars["String"]>;
    teamName?: Maybe<Scalars["String"]>;
};
export declare type MutationIssueImportDeleteArgs = {
    issueImportId: Scalars["String"];
};
export declare type MutationIssueImportProcessArgs = {
    issueImportId: Scalars["String"];
    mapping: Scalars["JSONObject"];
};
export declare type MutationIssueImportUpdateArgs = {
    id: Scalars["String"];
    input: IssueImportUpdateInput;
};
export declare type MutationIssueLabelCreateArgs = {
    input: IssueLabelCreateInput;
    replaceTeamLabels?: Maybe<Scalars["Boolean"]>;
};
export declare type MutationIssueLabelDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationIssueLabelUpdateArgs = {
    id: Scalars["String"];
    input: IssueLabelUpdateInput;
};
export declare type MutationIssueRelationCreateArgs = {
    input: IssueRelationCreateInput;
};
export declare type MutationIssueRelationDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationIssueRelationUpdateArgs = {
    id: Scalars["String"];
    input: IssueRelationUpdateInput;
};
export declare type MutationIssueReminderArgs = {
    id: Scalars["String"];
    reminderAt: Scalars["DateTime"];
};
export declare type MutationIssueUnarchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationIssueUpdateArgs = {
    id: Scalars["String"];
    input: IssueUpdateInput;
};
export declare type MutationJiraIntegrationConnectArgs = {
    input: JiraConfigurationInput;
};
export declare type MutationJoinOrganizationFromOnboardingArgs = {
    input: JoinOrganizationInput;
};
export declare type MutationLeaveOrganizationArgs = {
    organizationId: Scalars["String"];
};
export declare type MutationNotificationArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationNotificationArchiveAllArgs = {
    input: NotificationEntityInput;
};
export declare type MutationNotificationMarkReadAllArgs = {
    input: NotificationEntityInput;
    readAt: Scalars["DateTime"];
};
export declare type MutationNotificationMarkUnreadAllArgs = {
    input: NotificationEntityInput;
};
export declare type MutationNotificationSnoozeAllArgs = {
    input: NotificationEntityInput;
    snoozedUntilAt: Scalars["DateTime"];
};
export declare type MutationNotificationSubscriptionCreateArgs = {
    input: NotificationSubscriptionCreateInput;
};
export declare type MutationNotificationSubscriptionDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationNotificationSubscriptionUpdateArgs = {
    id: Scalars["String"];
    input: NotificationSubscriptionUpdateInput;
};
export declare type MutationNotificationUnarchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationNotificationUnsnoozeAllArgs = {
    input: NotificationEntityInput;
    unsnoozedAt: Scalars["DateTime"];
};
export declare type MutationNotificationUpdateArgs = {
    id: Scalars["String"];
    input: NotificationUpdateInput;
};
export declare type MutationOrganizationDeleteArgs = {
    input: DeleteOrganizationInput;
};
export declare type MutationOrganizationDomainClaimArgs = {
    id: Scalars["String"];
};
export declare type MutationOrganizationDomainCreateArgs = {
    input: OrganizationDomainCreateInput;
    triggerEmailVerification?: Maybe<Scalars["Boolean"]>;
};
export declare type MutationOrganizationDomainDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationOrganizationDomainVerifyArgs = {
    input: OrganizationDomainVerificationInput;
};
export declare type MutationOrganizationInviteCreateArgs = {
    input: OrganizationInviteCreateInput;
};
export declare type MutationOrganizationInviteDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationOrganizationInviteUpdateArgs = {
    id: Scalars["String"];
    input: OrganizationInviteUpdateInput;
};
export declare type MutationOrganizationUpdateArgs = {
    input: UpdateOrganizationInput;
};
export declare type MutationProjectArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationProjectCreateArgs = {
    input: ProjectCreateInput;
};
export declare type MutationProjectDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationProjectLinkCreateArgs = {
    input: ProjectLinkCreateInput;
};
export declare type MutationProjectLinkDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationProjectLinkUpdateArgs = {
    id: Scalars["String"];
    input: ProjectLinkUpdateInput;
};
export declare type MutationProjectMilestoneCreateArgs = {
    input: ProjectMilestoneCreateInput;
};
export declare type MutationProjectMilestoneDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationProjectMilestoneUpdateArgs = {
    id: Scalars["String"];
    input: ProjectMilestoneUpdateInput;
};
export declare type MutationProjectUnarchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationProjectUpdateArgs = {
    id: Scalars["String"];
    input: ProjectUpdateInput;
};
export declare type MutationProjectUpdateCreateArgs = {
    input: ProjectUpdateCreateInput;
};
export declare type MutationProjectUpdateDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationProjectUpdateInteractionCreateArgs = {
    input: ProjectUpdateInteractionCreateInput;
};
export declare type MutationProjectUpdateMarkAsReadArgs = {
    id: Scalars["String"];
};
export declare type MutationProjectUpdateUpdateArgs = {
    id: Scalars["String"];
    input: ProjectUpdateUpdateInput;
};
export declare type MutationPushSubscriptionCreateArgs = {
    input: PushSubscriptionCreateInput;
};
export declare type MutationPushSubscriptionDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationReactionCreateArgs = {
    input: ReactionCreateInput;
};
export declare type MutationReactionDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationRefreshGoogleSheetsDataArgs = {
    id: Scalars["String"];
};
export declare type MutationResendOrganizationInviteArgs = {
    id: Scalars["String"];
};
export declare type MutationRoadmapArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationRoadmapCreateArgs = {
    input: RoadmapCreateInput;
};
export declare type MutationRoadmapDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationRoadmapToProjectCreateArgs = {
    input: RoadmapToProjectCreateInput;
};
export declare type MutationRoadmapToProjectDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationRoadmapToProjectUpdateArgs = {
    id: Scalars["String"];
    input: RoadmapToProjectUpdateInput;
};
export declare type MutationRoadmapUnarchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationRoadmapUpdateArgs = {
    id: Scalars["String"];
    input: RoadmapUpdateInput;
};
export declare type MutationSamlTokenUserAccountAuthArgs = {
    input: TokenUserAccountAuthInput;
};
export declare type MutationTeamCreateArgs = {
    copySettingsFromTeamId?: Maybe<Scalars["String"]>;
    input: TeamCreateInput;
};
export declare type MutationTeamCyclesDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationTeamDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationTeamKeyDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationTeamMembershipCreateArgs = {
    input: TeamMembershipCreateInput;
};
export declare type MutationTeamMembershipDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationTeamMembershipUpdateArgs = {
    id: Scalars["String"];
    input: TeamMembershipUpdateInput;
};
export declare type MutationTeamUpdateArgs = {
    id: Scalars["String"];
    input: TeamUpdateInput;
};
export declare type MutationTemplateCreateArgs = {
    input: TemplateCreateInput;
};
export declare type MutationTemplateDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationTemplateUpdateArgs = {
    id: Scalars["String"];
    input: TemplateUpdateInput;
};
export declare type MutationUserDemoteAdminArgs = {
    id: Scalars["String"];
};
export declare type MutationUserDemoteMemberArgs = {
    id: Scalars["String"];
};
export declare type MutationUserDiscordConnectArgs = {
    code: Scalars["String"];
    redirectUri: Scalars["String"];
};
export declare type MutationUserExternalUserDisconnectArgs = {
    service: Scalars["String"];
};
export declare type MutationUserFlagUpdateArgs = {
    flag: UserFlagType;
    operation: UserFlagUpdateOperation;
};
export declare type MutationUserGitHubConnectArgs = {
    code: Scalars["String"];
};
export declare type MutationUserGoogleCalendarConnectArgs = {
    code: Scalars["String"];
};
export declare type MutationUserJiraConnectArgs = {
    code: Scalars["String"];
};
export declare type MutationUserPromoteAdminArgs = {
    id: Scalars["String"];
};
export declare type MutationUserPromoteMemberArgs = {
    id: Scalars["String"];
};
export declare type MutationUserSettingsFlagIncrementArgs = {
    flag: Scalars["String"];
};
export declare type MutationUserSettingsFlagsResetArgs = {
    flags?: Maybe<Array<UserFlagType>>;
};
export declare type MutationUserSettingsUpdateArgs = {
    id: Scalars["String"];
    input: UserSettingsUpdateInput;
};
export declare type MutationUserSuspendArgs = {
    id: Scalars["String"];
};
export declare type MutationUserUnsuspendArgs = {
    id: Scalars["String"];
};
export declare type MutationUserUpdateArgs = {
    id: Scalars["String"];
    input: UpdateUserInput;
};
export declare type MutationViewPreferencesCreateArgs = {
    input: ViewPreferencesCreateInput;
};
export declare type MutationViewPreferencesDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationViewPreferencesUpdateArgs = {
    id: Scalars["String"];
    input: ViewPreferencesUpdateInput;
};
export declare type MutationWebhookCreateArgs = {
    input: WebhookCreateInput;
};
export declare type MutationWebhookDeleteArgs = {
    id: Scalars["String"];
};
export declare type MutationWebhookUpdateArgs = {
    id: Scalars["String"];
    input: WebhookUpdateInput;
};
export declare type MutationWorkflowStateArchiveArgs = {
    id: Scalars["String"];
};
export declare type MutationWorkflowStateCreateArgs = {
    input: WorkflowStateCreateInput;
};
export declare type MutationWorkflowStateUpdateArgs = {
    id: Scalars["String"];
    input: WorkflowStateUpdateInput;
};
export declare type Node = {
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
};
/** A notification sent to a user. */
export declare type Notification = {
    /** The user that caused the notification. */
    actor?: Maybe<User>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /**
     * The time at when an email reminder for this notification was sent to the user. Null, if no email
     *     reminder has been sent.
     */
    emailedAt?: Maybe<Scalars["DateTime"]>;
    /** The external user that caused the notification. */
    externalUserActor?: Maybe<ExternalUser>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
    readAt?: Maybe<Scalars["DateTime"]>;
    /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
    snoozedUntilAt?: Maybe<Scalars["DateTime"]>;
    /** Notification type */
    type: Scalars["String"];
    /** The time at which a notification was unsnoozed.. */
    unsnoozedAt?: Maybe<Scalars["DateTime"]>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user that received the notification. */
    user: User;
};
/** A generic payload return from entity archive mutations. */
export declare type NotificationArchivePayload = ArchivePayload & {
    __typename?: "NotificationArchivePayload";
    /** The archived/unarchived entity. Null if entity was deleted. */
    entity?: Maybe<Notification>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type NotificationBatchActionPayload = {
    __typename?: "NotificationBatchActionPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The notifications that were updated. */
    notifications: Array<Notification>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type NotificationConnection = {
    __typename?: "NotificationConnection";
    edges: Array<NotificationEdge>;
    nodes: Array<Notification>;
    pageInfo: PageInfo;
};
export declare type NotificationEdge = {
    __typename?: "NotificationEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Notification;
};
/** Describes the type and id of the entity to target for notifications. */
export declare type NotificationEntityInput = {
    /** The id of the issue related to the notification. */
    issueId?: Maybe<Scalars["String"]>;
    /** The id of the OAuth client approval related to the notification. */
    oauthClientApprovalId?: Maybe<Scalars["String"]>;
    /** The id of the project related to the notification. */
    projectId?: Maybe<Scalars["String"]>;
    /** The id of the project update related to the notification. */
    projectUpdateId?: Maybe<Scalars["String"]>;
};
export declare type NotificationPayload = {
    __typename?: "NotificationPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The notification that was created or updated. */
    notification: Notification;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Notification subscriptions for models. */
export declare type NotificationSubscription = {
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The type of view to which the notification subscription context is associated with. */
    contextViewType?: Maybe<ContextViewType>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The contextual custom view associated with the notification subscription. */
    customView?: Maybe<CustomView>;
    /** The contextual cycle view associated with the notification subscription. */
    cycle?: Maybe<Cycle>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The contextual label view associated with the notification subscription. */
    label?: Maybe<IssueLabel>;
    /** The contextual project view associated with the notification subscription. */
    project?: Maybe<Project>;
    /** The user that subscribed to receive notifications. */
    subscriber: User;
    /** The team associated with the notification subscription. */
    team?: Maybe<Team>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user view associated with the notification subscription. */
    user?: Maybe<User>;
    /** The type of user view to which the notification subscription context is associated with. */
    userContextViewType?: Maybe<UserContextViewType>;
};
export declare type NotificationSubscriptionConnection = {
    __typename?: "NotificationSubscriptionConnection";
    edges: Array<NotificationSubscriptionEdge>;
    nodes: Array<NotificationSubscription>;
    pageInfo: PageInfo;
};
export declare type NotificationSubscriptionCreateInput = {
    /** The type of view to which the notification subscription context is associated with. */
    contextViewType?: Maybe<ContextViewType>;
    /** The identifier of the custom view to subscribe to. */
    customViewId?: Maybe<Scalars["String"]>;
    /** The identifier of the cycle to subscribe to. */
    cycleId?: Maybe<Scalars["String"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifier of the label to subscribe to. */
    labelId?: Maybe<Scalars["String"]>;
    /** The types of notifications of the subscription. */
    notificationSubscriptionTypes?: Maybe<Array<Scalars["String"]>>;
    /** The identifier of the project to subscribe to. */
    projectId?: Maybe<Scalars["String"]>;
    /** The identifier of the team to subscribe to. */
    teamId?: Maybe<Scalars["String"]>;
    /** The type of user view to which the notification subscription context is associated with. */
    userContextViewType?: Maybe<UserContextViewType>;
    /** The identifier of the user to subscribe to. */
    userId?: Maybe<Scalars["String"]>;
};
export declare type NotificationSubscriptionEdge = {
    __typename?: "NotificationSubscriptionEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: NotificationSubscription;
};
export declare type NotificationSubscriptionPayload = {
    __typename?: "NotificationSubscriptionPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The notification subscription that was created or updated. */
    notificationSubscription: NotificationSubscription;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type NotificationSubscriptionUpdateInput = {
    /** The types of notifications of the subscription. */
    notificationSubscriptionTypes?: Maybe<Array<Scalars["String"]>>;
};
export declare type NotificationUpdateInput = {
    /** The id of the project update related to the notification. */
    projectUpdateId?: Maybe<Scalars["String"]>;
    /** The time when notification was marked as read. */
    readAt?: Maybe<Scalars["DateTime"]>;
    /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
    snoozedUntilAt?: Maybe<Scalars["DateTime"]>;
};
/** Notion specific settings. */
export declare type NotionSettings = {
    __typename?: "NotionSettings";
    /** The ID of the Notion workspace being connected. */
    workspaceId: Scalars["String"];
    /** The name of the Notion workspace being connected. */
    workspaceName: Scalars["String"];
};
export declare type NotionSettingsInput = {
    /** The ID of the Notion workspace being connected. */
    workspaceId: Scalars["String"];
    /** The name of the Notion workspace being connected. */
    workspaceName: Scalars["String"];
};
/** Cycle filtering options. */
export declare type NullableCycleFilter = {
    /** Compound filters, one of which need to be matched by the cycle. */
    and?: Maybe<Array<NullableCycleFilter>>;
    /** Comparator for the cycle completed at date. */
    completedAt?: Maybe<DateComparator>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the cycle ends at date. */
    endsAt?: Maybe<DateComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the filtering active cycle. */
    isActive?: Maybe<BooleanComparator>;
    /** Comparator for the filtering future cycles. */
    isFuture?: Maybe<BooleanComparator>;
    /** Comparator for the filtering next cycle. */
    isNext?: Maybe<BooleanComparator>;
    /** Comparator for the filtering past cycles. */
    isPast?: Maybe<BooleanComparator>;
    /** Comparator for the filtering previous cycle. */
    isPrevious?: Maybe<BooleanComparator>;
    /** Filters that the cycles issues must satisfy. */
    issues?: Maybe<IssueCollectionFilter>;
    /** Comparator for the cycle name. */
    name?: Maybe<StringComparator>;
    /** Filter based on the existence of the relation. */
    null?: Maybe<Scalars["Boolean"]>;
    /** Comparator for the cycle number. */
    number?: Maybe<NumberComparator>;
    /** Compound filters, one of which need to be matched by the cycle. */
    or?: Maybe<Array<NullableCycleFilter>>;
    /** Comparator for the cycle start date. */
    startsAt?: Maybe<DateComparator>;
    /** Filters that the cycles team must satisfy. */
    team?: Maybe<TeamFilter>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
/** Comparator for optional dates. */
export declare type NullableDateComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["DateTime"]>;
    /** Greater-than constraint. Matches any values that are greater than the given value. */
    gt?: Maybe<Scalars["DateTime"]>;
    /** Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value. */
    gte?: Maybe<Scalars["DateTime"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["DateTime"]>>;
    /** Less-than constraint. Matches any values that are less than the given value. */
    lt?: Maybe<Scalars["DateTime"]>;
    /** Less-than-or-equal constraint. Matches any values that are less than or equal to the given value. */
    lte?: Maybe<Scalars["DateTime"]>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["DateTime"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["DateTime"]>>;
    /** Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values. */
    null?: Maybe<Scalars["Boolean"]>;
};
/** Issue filtering options. */
export declare type NullableIssueFilter = {
    /** Compound filters, all of which need to be matched by the issue. */
    and?: Maybe<Array<NullableIssueFilter>>;
    /** Filters that the issues assignee must satisfy. */
    assignee?: Maybe<NullableUserFilter>;
    /** Filters that the issues attachments must satisfy. */
    attachments?: Maybe<AttachmentCollectionFilter>;
    /** Comparator for the issues auto archived at date. */
    autoArchivedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the issues auto closed at date. */
    autoClosedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the issues canceled at date. */
    canceledAt?: Maybe<NullableDateComparator>;
    /** Filters that the child issues must satisfy. */
    children?: Maybe<IssueCollectionFilter>;
    /** Filters that the issues comments must satisfy. */
    comments?: Maybe<CommentCollectionFilter>;
    /** Comparator for the issues completed at date. */
    completedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the issues creator must satisfy. */
    creator?: Maybe<NullableUserFilter>;
    /** Filters that the issues cycle must satisfy. */
    cycle?: Maybe<NullableCycleFilter>;
    /** Comparator for the issues description. */
    description?: Maybe<NullableStringComparator>;
    /** Comparator for the issues due date. */
    dueDate?: Maybe<NullableTimelessDateComparator>;
    /** Comparator for the issues estimate. */
    estimate?: Maybe<EstimateComparator>;
    /** Comparator for filtering issues which are blocked. */
    hasBlockedByRelations?: Maybe<RelationExistsComparator>;
    /** Comparator for filtering issues which are blocking. */
    hasBlockingRelations?: Maybe<RelationExistsComparator>;
    /** Comparator for filtering issues which are duplicates. */
    hasDuplicateRelations?: Maybe<RelationExistsComparator>;
    /** Comparator for filtering issues with relations. */
    hasRelatedRelations?: Maybe<RelationExistsComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that issue labels must satisfy. */
    labels?: Maybe<IssueLabelCollectionFilter>;
    /** Filter based on the existence of the relation. */
    null?: Maybe<Scalars["Boolean"]>;
    /** Comparator for the issues number. */
    number?: Maybe<NumberComparator>;
    /** Compound filters, one of which need to be matched by the issue. */
    or?: Maybe<Array<NullableIssueFilter>>;
    /** Filters that the issue parent must satisfy. */
    parent?: Maybe<NullableIssueFilter>;
    /** Comparator for the issues priority. */
    priority?: Maybe<NullableNumberComparator>;
    /** Filters that the issues project must satisfy. */
    project?: Maybe<NullableProjectFilter>;
    /** Filters that the issues project milestone must satisfy. */
    projectMilestone?: Maybe<NullableProjectMilestoneFilter>;
    /** [Internal] Comparator for the issues content. */
    searchableContent?: Maybe<ContentComparator>;
    /** Comparator for the issues sla status. */
    slaStatus?: Maybe<SlaStatusComparator>;
    /** Filters that the issues snoozer must satisfy. */
    snoozedBy?: Maybe<NullableUserFilter>;
    /** Comparator for the issues snoozed until date. */
    snoozedUntilAt?: Maybe<NullableDateComparator>;
    /** Comparator for the issues started at date. */
    startedAt?: Maybe<NullableDateComparator>;
    /** Filters that the issues state must satisfy. */
    state?: Maybe<WorkflowStateFilter>;
    /** Filters that issue subscribers must satisfy. */
    subscribers?: Maybe<UserCollectionFilter>;
    /** Filters that the issues team must satisfy. */
    team?: Maybe<TeamFilter>;
    /** Comparator for the issues title. */
    title?: Maybe<StringComparator>;
    /** Comparator for the issues triaged at date. */
    triagedAt?: Maybe<NullableDateComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
/** Comparator for optional numbers. */
export declare type NullableNumberComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["Float"]>;
    /** Greater-than constraint. Matches any values that are greater than the given value. */
    gt?: Maybe<Scalars["Float"]>;
    /** Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value. */
    gte?: Maybe<Scalars["Float"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["Float"]>>;
    /** Less-than constraint. Matches any values that are less than the given value. */
    lt?: Maybe<Scalars["Float"]>;
    /** Less-than-or-equal constraint. Matches any values that are less than or equal to the given value. */
    lte?: Maybe<Scalars["Float"]>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["Float"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["Float"]>>;
    /** Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values. */
    null?: Maybe<Scalars["Boolean"]>;
};
/** Project filtering options. */
export declare type NullableProjectFilter = {
    /** Filters that the project's team must satisfy. */
    accessibleTeams?: Maybe<TeamCollectionFilter>;
    /** Compound filters, all of which need to be matched by the project. */
    and?: Maybe<Array<NullableProjectFilter>>;
    /** Comparator for the project completion date. */
    completedAt?: Maybe<NullableDateComparator>;
    /** Filters that the project's completed milestones must satisfy. */
    completedProjectMilestones?: Maybe<ProjectMilestoneCollectionFilter>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the projects creator must satisfy. */
    creator?: Maybe<UserFilter>;
    /** Comparator for the project health. */
    health?: Maybe<StringComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the projects issues must satisfy. */
    issues?: Maybe<IssueCollectionFilter>;
    /** Filters that the projects lead must satisfy. */
    lead?: Maybe<NullableUserFilter>;
    /** Filters that the projects members must satisfy. */
    members?: Maybe<UserFilter>;
    /** Comparator for the project name. */
    name?: Maybe<StringComparator>;
    /** Filters that the project's next milestone must satisfy. */
    nextProjectMilestone?: Maybe<ProjectMilestoneFilter>;
    /** Filter based on the existence of the relation. */
    null?: Maybe<Scalars["Boolean"]>;
    /** Compound filters, one of which need to be matched by the project. */
    or?: Maybe<Array<NullableProjectFilter>>;
    /** Filters that the project's milestones must satisfy. */
    projectMilestones?: Maybe<ProjectMilestoneCollectionFilter>;
    /** Filters that the projects roadmaps must satisfy. */
    roadmaps?: Maybe<RoadmapCollectionFilter>;
    /** [Internal] Comparator for the projects content. */
    searchableContent?: Maybe<ContentComparator>;
    /** Comparator for the project slug ID. */
    slugId?: Maybe<StringComparator>;
    /** Comparator for the project start date. */
    startDate?: Maybe<NullableDateComparator>;
    /** Comparator for the project state. */
    state?: Maybe<StringComparator>;
    /** Comparator for the project target date. */
    targetDate?: Maybe<NullableDateComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
/** Project milestone filtering options. */
export declare type NullableProjectMilestoneFilter = {
    /** Compound filters, all of which need to be matched by the project milestone. */
    and?: Maybe<Array<NullableProjectMilestoneFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the project milestone name. */
    name?: Maybe<StringComparator>;
    /** Filter based on the existence of the relation. */
    null?: Maybe<Scalars["Boolean"]>;
    /** Compound filters, one of which need to be matched by the project milestone. */
    or?: Maybe<Array<NullableProjectMilestoneFilter>>;
    /** Comparator for the project milestone target date. */
    targetDate?: Maybe<NullableDateComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
/** Comparator for optional strings. */
export declare type NullableStringComparator = {
    /** Contains constraint. Matches any values that contain the given string. */
    contains?: Maybe<Scalars["String"]>;
    /** Contains case insensitive constraint. Matches any values that contain the given string case insensitive. */
    containsIgnoreCase?: Maybe<Scalars["String"]>;
    /** Ends with constraint. Matches any values that end with the given string. */
    endsWith?: Maybe<Scalars["String"]>;
    /** Equals constraint. */
    eq?: Maybe<Scalars["String"]>;
    /** Equals case insensitive. Matches any values that matches the given string case insensitive. */
    eqIgnoreCase?: Maybe<Scalars["String"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["String"]>>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["String"]>;
    /** Not-equals case insensitive. Matches any values that don't match the given string case insensitive. */
    neqIgnoreCase?: Maybe<Scalars["String"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["String"]>>;
    /** Doesn't contain constraint. Matches any values that don't contain the given string. */
    notContains?: Maybe<Scalars["String"]>;
    /** Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive. */
    notContainsIgnoreCase?: Maybe<Scalars["String"]>;
    /** Doesn't end with constraint. Matches any values that don't end with the given string. */
    notEndsWith?: Maybe<Scalars["String"]>;
    /** Doesn't start with constraint. Matches any values that don't start with the given string. */
    notStartsWith?: Maybe<Scalars["String"]>;
    /** Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values. */
    null?: Maybe<Scalars["Boolean"]>;
    /** Starts with constraint. Matches any values that start with the given string. */
    startsWith?: Maybe<Scalars["String"]>;
    /** Starts with case insensitive constraint. Matches any values that start with the given string. */
    startsWithIgnoreCase?: Maybe<Scalars["String"]>;
};
/** Team filtering options. */
export declare type NullableTeamFilter = {
    /** Compound filters, all of which need to be matched by the team. */
    and?: Maybe<Array<NullableTeamFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the team description. */
    description?: Maybe<NullableStringComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the teams issues must satisfy. */
    issues?: Maybe<IssueCollectionFilter>;
    /** Comparator for the team key. */
    key?: Maybe<StringComparator>;
    /** Comparator for the team name. */
    name?: Maybe<StringComparator>;
    /** Filter based on the existence of the relation. */
    null?: Maybe<Scalars["Boolean"]>;
    /** Compound filters, one of which need to be matched by the team. */
    or?: Maybe<Array<NullableTeamFilter>>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type NullableTimelessDateComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["TimelessDate"]>;
    /** Greater-than constraint. Matches any values that are greater than the given value. */
    gt?: Maybe<Scalars["TimelessDate"]>;
    /** Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value. */
    gte?: Maybe<Scalars["TimelessDate"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["TimelessDate"]>>;
    /** Less-than constraint. Matches any values that are less than the given value. */
    lt?: Maybe<Scalars["TimelessDate"]>;
    /** Less-than-or-equal constraint. Matches any values that are less than or equal to the given value. */
    lte?: Maybe<Scalars["TimelessDate"]>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["TimelessDate"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["TimelessDate"]>>;
    /** Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values. */
    null?: Maybe<Scalars["Boolean"]>;
};
/** User filtering options. */
export declare type NullableUserFilter = {
    /** Comparator for the user's activity status. */
    active?: Maybe<BooleanComparator>;
    /** Comparator for the user's admin status. */
    admin?: Maybe<BooleanComparator>;
    /** Compound filters, all of which need to be matched by the user. */
    and?: Maybe<Array<NullableUserFilter>>;
    /** Filters that the users assigned issues must satisfy. */
    assignedIssues?: Maybe<IssueCollectionFilter>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the user's display name. */
    displayName?: Maybe<StringComparator>;
    /** Comparator for the user's email. */
    email?: Maybe<StringComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user. */
    isMe?: Maybe<BooleanComparator>;
    /** Comparator for the user's name. */
    name?: Maybe<StringComparator>;
    /** Filter based on the existence of the relation. */
    null?: Maybe<Scalars["Boolean"]>;
    /** Compound filters, one of which need to be matched by the user. */
    or?: Maybe<Array<NullableUserFilter>>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
/** Comparator for numbers. */
export declare type NumberComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["Float"]>;
    /** Greater-than constraint. Matches any values that are greater than the given value. */
    gt?: Maybe<Scalars["Float"]>;
    /** Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value. */
    gte?: Maybe<Scalars["Float"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["Float"]>>;
    /** Less-than constraint. Matches any values that are less than the given value. */
    lt?: Maybe<Scalars["Float"]>;
    /** Less-than-or-equal constraint. Matches any values that are less than or equal to the given value. */
    lte?: Maybe<Scalars["Float"]>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["Float"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["Float"]>>;
};
/** The different requests statuses possible for an OAuth client approval request */
export declare enum OAuthClientApprovalStatus {
    Approved = "approved",
    Denied = "denied",
    Requested = "requested"
}
/** OAuth2 client application */
export declare type OauthClient = Node & {
    __typename?: "OauthClient";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** OAuth application's client ID. */
    clientId: Scalars["String"];
    /** OAuth application's client secret. */
    clientSecret: Scalars["String"];
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the OAuthClient. */
    creator: User;
    /** Information about the application. */
    description?: Maybe<Scalars["String"]>;
    /** Name of the developer. */
    developer: Scalars["String"];
    /** Url of the developer. */
    developerUrl: Scalars["String"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Image of the application. */
    imageUrl?: Maybe<Scalars["String"]>;
    /** OAuth application's client name. */
    name: Scalars["String"];
    /** The organization that the OAuthClient is associated with. */
    organization: Organization;
    /** Whether the OAuth application is publicly visible, or only visible to the creating workspace. */
    publicEnabled: Scalars["Boolean"];
    /** List of allowed redirect URIs for the application. */
    redirectUris: Array<Scalars["String"]>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The resource types to request when creating new webhooks. */
    webhookResourceTypes: Array<Scalars["String"]>;
    /** Webhook secret token for verifying the origin on the recipient side. */
    webhookSecret?: Maybe<Scalars["String"]>;
    /** Webhook URL */
    webhookUrl?: Maybe<Scalars["String"]>;
};
/** Request to install OAuth clients on organizations and the response to the request. */
export declare type OauthClientApproval = Node & {
    __typename?: "OauthClientApproval";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The reason the request for the OAuth client approval was denied. */
    denyReason?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The uuid of the OAuth client being requested for installation. */
    oauthClientId: Scalars["String"];
    /** The reason the person wants to install this OAuth client. */
    requestReason?: Maybe<Scalars["String"]>;
    /** The person who requested installing the OAuth client. */
    requesterId: Scalars["String"];
    /** The person who responded to the request to install the OAuth client. */
    responderId?: Maybe<Scalars["String"]>;
    /** The scopes the app has requested. */
    scopes: Array<Scalars["String"]>;
    /** The status for the OAuth client approval request. */
    status: OAuthClientApprovalStatus;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** An oauth client approval related notification */
export declare type OauthClientApprovalNotification = Entity & Node & Notification & {
    __typename?: "OauthClientApprovalNotification";
    /** The user that caused the notification. */
    actor?: Maybe<User>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /**
     * The time at when an email reminder for this notification was sent to the user. Null, if no email
     *     reminder has been sent.
     */
    emailedAt?: Maybe<Scalars["DateTime"]>;
    /** The external user that caused the notification. */
    externalUserActor?: Maybe<ExternalUser>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The OAuth client approval request related to the notification. */
    oauthClientApproval: OauthClientApproval;
    /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
    readAt?: Maybe<Scalars["DateTime"]>;
    /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
    snoozedUntilAt?: Maybe<Scalars["DateTime"]>;
    /** Notification type */
    type: Scalars["String"];
    /** The time at which a notification was unsnoozed.. */
    unsnoozedAt?: Maybe<Scalars["DateTime"]>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user that received the notification. */
    user: User;
};
export declare type OauthClientConnection = {
    __typename?: "OauthClientConnection";
    edges: Array<OauthClientEdge>;
    nodes: Array<OauthClient>;
    pageInfo: PageInfo;
};
export declare type OauthClientEdge = {
    __typename?: "OauthClientEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: OauthClient;
};
export declare type OnboardingCustomerSurvey = {
    companyRole?: Maybe<Scalars["String"]>;
    companySize?: Maybe<Scalars["String"]>;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type Organization = Node & {
    __typename?: "Organization";
    /** Allowed authentication providers, empty array means all are allowed */
    allowedAuthServices: Array<Scalars["String"]>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Number of issues in the organization. */
    createdIssueCount: Scalars["Int"];
    /** The time at which deletion of the organization was requested. */
    deletionRequestedAt?: Maybe<Scalars["DateTime"]>;
    /** How git branches are formatted. If null, default formatting will be used. */
    gitBranchFormat?: Maybe<Scalars["String"]>;
    /** Whether the Git integration linkback messages should be sent to private repositories. */
    gitLinkbackMessagesEnabled: Scalars["Boolean"];
    /** Whether the Git integration linkback messages should be sent to public repositories. */
    gitPublicLinkbackMessagesEnabled: Scalars["Boolean"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Integrations associated with the organization. */
    integrations: IntegrationConnection;
    /** Labels associated with the organization. */
    labels: IssueLabelConnection;
    /** The organization's logo URL. */
    logoUrl?: Maybe<Scalars["String"]>;
    /** The organization's name. */
    name: Scalars["String"];
    /** Rolling 30-day total upload volume for the organization, in megabytes. */
    periodUploadVolume: Scalars["Float"];
    /** Previously used URL keys for the organization (last 3 are kept and redirected). */
    previousUrlKeys: Array<Scalars["String"]>;
    /** The day at which to prompt for project updates. */
    projectUpdateRemindersDay: Day;
    /** The hour at which to prompt for project updates. */
    projectUpdateRemindersHour: Scalars["Float"];
    /** The frequency at which to prompt for project updates. */
    projectUpdatesReminderFrequency: ProjectUpdateReminderFrequency;
    /** The feature release channel the organization belongs to. */
    releaseChannel: ReleaseChannel;
    /** Whether the organization is using a roadmap. */
    roadmapEnabled: Scalars["Boolean"];
    /** Whether SAML authentication is enabled for organization. */
    samlEnabled: Scalars["Boolean"];
    /** Whether SCIM provisioning is enabled for organization. */
    scimEnabled: Scalars["Boolean"];
    /** The organization's subscription to a paid plan. */
    subscription?: Maybe<PaidSubscription>;
    /** Teams associated with the organization. */
    teams: TeamConnection;
    /** Templates associated with the organization. */
    templates: TemplateConnection;
    /** The time at which the trial of the plus plan will end. */
    trialEndsAt?: Maybe<Scalars["DateTime"]>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The organization's unique URL key. */
    urlKey: Scalars["String"];
    /** Number of active users in the organization. */
    userCount: Scalars["Int"];
    /** Users associated with the organization. */
    users: UserConnection;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type OrganizationIntegrationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type OrganizationLabelsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type OrganizationTeamsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type OrganizationTemplatesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organization. Organizations are root-level objects that contain user accounts and teams. */
export declare type OrganizationUsersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type OrganizationAcceptedOrExpiredInviteDetailsPayload = {
    __typename?: "OrganizationAcceptedOrExpiredInviteDetailsPayload";
    /** The status of the invite */
    status: OrganizationInviteStatus;
};
export declare type OrganizationCancelDeletePayload = {
    __typename?: "OrganizationCancelDeletePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type OrganizationDeletePayload = {
    __typename?: "OrganizationDeletePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Defines the use of a domain by an organization. */
export declare type OrganizationDomain = Node & {
    __typename?: "OrganizationDomain";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** What type of auth is the domain used for */
    authType: OrganizationDomainAuthType;
    /** Whether the domains was claimed by the organization through DNS verification. */
    claimed?: Maybe<Scalars["Boolean"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who added the domain. */
    creator?: Maybe<User>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Domain name */
    name: Scalars["String"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** E-mail used to verify this domain */
    verificationEmail?: Maybe<Scalars["String"]>;
    /** Is this domain verified */
    verified: Scalars["Boolean"];
};
/** What type of auth is the domain used for. */
export declare enum OrganizationDomainAuthType {
    General = "general",
    Saml = "saml"
}
/** [INTERNAL] Domain claim request response. */
export declare type OrganizationDomainClaimPayload = {
    __typename?: "OrganizationDomainClaimPayload";
    /** String to put into DNS for verification. */
    verificationString: Scalars["String"];
};
export declare type OrganizationDomainCreateInput = {
    /** The authentication type this domain is for. */
    authType?: Maybe<Scalars["String"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The domain name to add. */
    name: Scalars["String"];
    /** The email address to which to send the verification code. */
    verificationEmail?: Maybe<Scalars["String"]>;
};
/** [INTERNAL] Organization domain operation response. */
export declare type OrganizationDomainPayload = {
    __typename?: "OrganizationDomainPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The organization domain that was created or updated. */
    organizationDomain: OrganizationDomain;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** [INTERNAL] Organization domain operation response. */
export declare type OrganizationDomainSimplePayload = {
    __typename?: "OrganizationDomainSimplePayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type OrganizationDomainVerificationInput = {
    /** The identifier in UUID v4 format of the domain being verified. */
    organizationDomainId: Scalars["String"];
    /** The verification code sent via email. */
    verificationCode: Scalars["String"];
};
export declare type OrganizationExistsPayload = {
    __typename?: "OrganizationExistsPayload";
    /** Whether the organization exists. */
    exists: Scalars["Boolean"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** An invitation to the organization that has been sent via email. */
export declare type OrganizationInvite = Node & {
    __typename?: "OrganizationInvite";
    /** The time at which the invite was accepted. Null, if the invite hasn't been accepted */
    acceptedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The invitees email address. */
    email: Scalars["String"];
    /** The time at which the invite will be expiring. Null, if the invite shouldn't expire */
    expiresAt?: Maybe<Scalars["DateTime"]>;
    /** The invite was sent to external address. */
    external: Scalars["Boolean"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The user who has accepted the invite. Null, if the invite hasn't been accepted. */
    invitee?: Maybe<User>;
    /** The user who created the invitation. */
    inviter: User;
    /** The organization that the invite is associated with. */
    organization: Organization;
    /** The user role that the invitee will receive upon accepting the invite. */
    role: UserRoleType;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type OrganizationInviteConnection = {
    __typename?: "OrganizationInviteConnection";
    edges: Array<OrganizationInviteEdge>;
    nodes: Array<OrganizationInvite>;
    pageInfo: PageInfo;
};
export declare type OrganizationInviteCreateInput = {
    /** The email of the invitee. */
    email: Scalars["String"];
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The message to send to the invitee. */
    message?: Maybe<Scalars["String"]>;
    /** What user role the invite should grant. */
    role?: Maybe<UserRoleType>;
    /** The teams that the user has been invited to. */
    teamIds?: Maybe<Array<Scalars["String"]>>;
};
export declare type OrganizationInviteDetailsPayload = OrganizationAcceptedOrExpiredInviteDetailsPayload | OrganizationInviteFullDetailsPayload;
export declare type OrganizationInviteEdge = {
    __typename?: "OrganizationInviteEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: OrganizationInvite;
};
export declare type OrganizationInviteFullDetailsPayload = {
    __typename?: "OrganizationInviteFullDetailsPayload";
    /** Whether the invite has already been accepted. */
    accepted: Scalars["Boolean"];
    /** When the invite was created. */
    createdAt: Scalars["DateTime"];
    /** The email of the invitee */
    email: Scalars["String"];
    /** Whether the invite has expired. */
    expired: Scalars["Boolean"];
    /** The name of the inviter */
    inviter: Scalars["String"];
    /** ID of the workspace the invite is for. */
    organizationId: Scalars["String"];
    /** URL of the workspace logo the invite is for. */
    organizationLogoUrl?: Maybe<Scalars["String"]>;
    /** Name of the workspace the invite is for. */
    organizationName: Scalars["String"];
    /** What user role the invite should grant. */
    role: UserRoleType;
    /** The status of the invite */
    status: OrganizationInviteStatus;
};
export declare type OrganizationInvitePayload = {
    __typename?: "OrganizationInvitePayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The organization invite that was created or updated. */
    organizationInvite: OrganizationInvite;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** The different statuses possible for an organization invite. */
export declare enum OrganizationInviteStatus {
    Accepted = "accepted",
    Expired = "expired",
    Pending = "pending"
}
export declare type OrganizationInviteUpdateInput = {
    /** The teams that the user has been invited to. */
    teamIds: Array<Scalars["String"]>;
};
export declare type OrganizationPayload = {
    __typename?: "OrganizationPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The organization that was created or updated. */
    organization?: Maybe<Organization>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type OrganizationStartPlusTrialPayload = {
    __typename?: "OrganizationStartPlusTrialPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type PageInfo = {
    __typename?: "PageInfo";
    /** Cursor representing the last result in the paginated results. */
    endCursor?: Maybe<Scalars["String"]>;
    /** Indicates if there are more results when paginating forward. */
    hasNextPage: Scalars["Boolean"];
    /** Indicates if there are more results when paginating backward. */
    hasPreviousPage: Scalars["Boolean"];
    /** Cursor representing the first result in the paginated results. */
    startCursor?: Maybe<Scalars["String"]>;
};
export declare type PagerDutyInput = {
    /** The mapping of PagerDuty schedule id to names. */
    scheduleMapping: Array<PagerDutyScheduleMappingInput>;
};
/** Tuple for mapping PagerDuty schedule id to names. */
export declare type PagerDutyScheduleMapping = {
    __typename?: "PagerDutyScheduleMapping";
    /** The PagerDuty schedule id. */
    scheduleId: Scalars["String"];
    /** The PagerDuty schedule name. */
    scheduleName: Scalars["String"];
};
export declare type PagerDutyScheduleMappingInput = {
    /** The PagerDuty schedule id. */
    scheduleId: Scalars["String"];
    /** The PagerDuty schedule name. */
    scheduleName: Scalars["String"];
};
/** PagerDuty specific settings. */
export declare type PagerDutySettings = {
    __typename?: "PagerDutySettings";
    /** The mapping of PagerDuty schedule id to names. */
    scheduleMapping: Array<PagerDutyScheduleMapping>;
};
/** By which field should the pagination order by */
export declare enum PaginationOrderBy {
    CreatedAt = "createdAt",
    UpdatedAt = "updatedAt"
}
/** The paid subscription of an organization. */
export declare type PaidSubscription = Node & {
    __typename?: "PaidSubscription";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The date the subscription was canceled, if any. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The creator of the subscription. */
    creator?: Maybe<User>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The date the subscription will be billed next. */
    nextBillingAt?: Maybe<Scalars["DateTime"]>;
    /** The organization that the subscription is associated with. */
    organization: Organization;
    /** The subscription type of a pending change. Null if no change pending. */
    pendingChangeType?: Maybe<Scalars["String"]>;
    /** The number of seats in the subscription. */
    seats: Scalars["Float"];
    /** The maximum number of seats that will be billed in the subscription. */
    seatsMaximum?: Maybe<Scalars["Float"]>;
    /** The minimum number of seats that will be billed in the subscription. */
    seatsMinimum?: Maybe<Scalars["Float"]>;
    /** The subscription type. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** A project. */
export declare type Project = Node & {
    __typename?: "Project";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the project was automatically archived by the auto pruning process. */
    autoArchivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the project was moved into canceled state. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** The project's color. */
    color: Scalars["String"];
    /** The time at which the project was moved into completed state. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The number of completed issues in the project after each week. */
    completedIssueCountHistory: Array<Scalars["Float"]>;
    /** The number of completed estimation points after each week. */
    completedScopeHistory: Array<Scalars["Float"]>;
    /** The project was created based on this issue. */
    convertedFromIssue?: Maybe<Issue>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the project. */
    creator: User;
    /** The project's description. */
    description: Scalars["String"];
    /** Documents associated with the project. */
    documents: DocumentConnection;
    /** The icon of the project. */
    icon?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The number of in progress estimation points after each week. */
    inProgressScopeHistory: Array<Scalars["Float"]>;
    /** Settings for all integrations associated with that project. */
    integrationsSettings?: Maybe<IntegrationsSettings>;
    /** The total number of issues in the project after each week. */
    issueCountHistory: Array<Scalars["Float"]>;
    /** Issues associated with the project. */
    issues: IssueConnection;
    /** The project lead. */
    lead?: Maybe<User>;
    /** Links associated with the project. */
    links: ProjectLinkConnection;
    /** Users that are members of the project. */
    members: UserConnection;
    /** The project's name. */
    name: Scalars["String"];
    /** The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points. */
    progress: Scalars["Float"];
    /** Milestones associated with the project. */
    projectMilestones: ProjectMilestoneConnection;
    /** The time until which project update reminders are paused. */
    projectUpdateRemindersPausedUntilAt?: Maybe<Scalars["DateTime"]>;
    /** Project updates associated with the project. */
    projectUpdates: ProjectUpdateConnection;
    /** The overall scope (total estimate points) of the project. */
    scope: Scalars["Float"];
    /** The total number of estimation points after each week. */
    scopeHistory: Array<Scalars["Float"]>;
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments: Scalars["Boolean"];
    /** Whether to send new issue status updates to Slack. */
    slackIssueStatuses: Scalars["Boolean"];
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue: Scalars["Boolean"];
    /** The project's unique URL slug. */
    slugId: Scalars["String"];
    /** The sort order for the project within the organization. */
    sortOrder: Scalars["Float"];
    /** The estimated start date of the project. */
    startDate?: Maybe<Scalars["TimelessDate"]>;
    /** The time at which the project was moved into started state. */
    startedAt?: Maybe<Scalars["DateTime"]>;
    /** The type of the state. */
    state: Scalars["String"];
    /** The estimated completion date of the project. */
    targetDate?: Maybe<Scalars["TimelessDate"]>;
    /** Teams associated with this project. */
    teams: TeamConnection;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Project URL. */
    url: Scalars["String"];
};
/** A project. */
export declare type ProjectDocumentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A project. */
export declare type ProjectIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A project. */
export declare type ProjectLinksArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A project. */
export declare type ProjectMembersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A project. */
export declare type ProjectProjectMilestonesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A project. */
export declare type ProjectProjectUpdatesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A project. */
export declare type ProjectTeamsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A generic payload return from entity archive mutations. */
export declare type ProjectArchivePayload = ArchivePayload & {
    __typename?: "ProjectArchivePayload";
    /** The archived/unarchived entity. Null if entity was deleted. */
    entity?: Maybe<Project>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Project filtering options. */
export declare type ProjectCollectionFilter = {
    /** Filters that the project's team must satisfy. */
    accessibleTeams?: Maybe<TeamCollectionFilter>;
    /** Compound filters, all of which need to be matched by the project. */
    and?: Maybe<Array<ProjectCollectionFilter>>;
    /** Comparator for the project completion date. */
    completedAt?: Maybe<NullableDateComparator>;
    /** Filters that the project's completed milestones must satisfy. */
    completedProjectMilestones?: Maybe<ProjectMilestoneCollectionFilter>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the projects creator must satisfy. */
    creator?: Maybe<UserFilter>;
    /** Filters that needs to be matched by all projects. */
    every?: Maybe<ProjectFilter>;
    /** Comparator for the project health. */
    health?: Maybe<StringComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the projects issues must satisfy. */
    issues?: Maybe<IssueCollectionFilter>;
    /** Filters that the projects lead must satisfy. */
    lead?: Maybe<NullableUserFilter>;
    /** Comparator for the collection length. */
    length?: Maybe<NumberComparator>;
    /** Filters that the projects members must satisfy. */
    members?: Maybe<UserFilter>;
    /** Comparator for the project name. */
    name?: Maybe<StringComparator>;
    /** Filters that the project's next milestone must satisfy. */
    nextProjectMilestone?: Maybe<ProjectMilestoneFilter>;
    /** Compound filters, one of which need to be matched by the project. */
    or?: Maybe<Array<ProjectCollectionFilter>>;
    /** Filters that the project's milestones must satisfy. */
    projectMilestones?: Maybe<ProjectMilestoneCollectionFilter>;
    /** Filters that the projects roadmaps must satisfy. */
    roadmaps?: Maybe<RoadmapCollectionFilter>;
    /** [Internal] Comparator for the projects content. */
    searchableContent?: Maybe<ContentComparator>;
    /** Comparator for the project slug ID. */
    slugId?: Maybe<StringComparator>;
    /** Filters that needs to be matched by some projects. */
    some?: Maybe<ProjectFilter>;
    /** Comparator for the project start date. */
    startDate?: Maybe<NullableDateComparator>;
    /** Comparator for the project state. */
    state?: Maybe<StringComparator>;
    /** Comparator for the project target date. */
    targetDate?: Maybe<NullableDateComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type ProjectConnection = {
    __typename?: "ProjectConnection";
    edges: Array<ProjectEdge>;
    nodes: Array<Project>;
    pageInfo: PageInfo;
};
export declare type ProjectCreateInput = {
    /** The color of the project. */
    color?: Maybe<Scalars["String"]>;
    /** The ID of the issue from which that project is created. */
    convertedFromIssueId?: Maybe<Scalars["String"]>;
    /** The description for the project. */
    description?: Maybe<Scalars["String"]>;
    /** The icon of the project. */
    icon?: Maybe<Scalars["String"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifier of the project lead. */
    leadId?: Maybe<Scalars["String"]>;
    /** The identifiers of the members of this project. */
    memberIds?: Maybe<Array<Scalars["String"]>>;
    /** The name of the project. */
    name: Scalars["String"];
    /** The sort order for the project within shared views. */
    sortOrder?: Maybe<Scalars["Float"]>;
    /** The planned start date of the project. */
    startDate?: Maybe<Scalars["TimelessDate"]>;
    /** The state of the project. */
    state?: Maybe<Scalars["String"]>;
    /** The planned target date of the project. */
    targetDate?: Maybe<Scalars["TimelessDate"]>;
    /** The identifiers of the teams this project is associated with. */
    teamIds: Array<Scalars["String"]>;
};
export declare type ProjectEdge = {
    __typename?: "ProjectEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Project;
};
/** Project filtering options. */
export declare type ProjectFilter = {
    /** Filters that the project's team must satisfy. */
    accessibleTeams?: Maybe<TeamCollectionFilter>;
    /** Compound filters, all of which need to be matched by the project. */
    and?: Maybe<Array<ProjectFilter>>;
    /** Comparator for the project completion date. */
    completedAt?: Maybe<NullableDateComparator>;
    /** Filters that the project's completed milestones must satisfy. */
    completedProjectMilestones?: Maybe<ProjectMilestoneCollectionFilter>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the projects creator must satisfy. */
    creator?: Maybe<UserFilter>;
    /** Comparator for the project health. */
    health?: Maybe<StringComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the projects issues must satisfy. */
    issues?: Maybe<IssueCollectionFilter>;
    /** Filters that the projects lead must satisfy. */
    lead?: Maybe<NullableUserFilter>;
    /** Filters that the projects members must satisfy. */
    members?: Maybe<UserFilter>;
    /** Comparator for the project name. */
    name?: Maybe<StringComparator>;
    /** Filters that the project's next milestone must satisfy. */
    nextProjectMilestone?: Maybe<ProjectMilestoneFilter>;
    /** Compound filters, one of which need to be matched by the project. */
    or?: Maybe<Array<ProjectFilter>>;
    /** Filters that the project's milestones must satisfy. */
    projectMilestones?: Maybe<ProjectMilestoneCollectionFilter>;
    /** Filters that the projects roadmaps must satisfy. */
    roadmaps?: Maybe<RoadmapCollectionFilter>;
    /** [Internal] Comparator for the projects content. */
    searchableContent?: Maybe<ContentComparator>;
    /** Comparator for the project slug ID. */
    slugId?: Maybe<StringComparator>;
    /** Comparator for the project start date. */
    startDate?: Maybe<NullableDateComparator>;
    /** Comparator for the project state. */
    state?: Maybe<StringComparator>;
    /** Comparator for the project target date. */
    targetDate?: Maybe<NullableDateComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type ProjectFilterSuggestionPayload = {
    __typename?: "ProjectFilterSuggestionPayload";
    /** The json filter that is suggested. */
    filter?: Maybe<Scalars["JSONObject"]>;
};
/** An external link for a project. */
export declare type ProjectLink = Node & {
    __typename?: "ProjectLink";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the link. */
    creator: User;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The link's label. */
    label: Scalars["String"];
    /** The project that the link is associated with. */
    project: Project;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The link's URL. */
    url: Scalars["String"];
};
export declare type ProjectLinkConnection = {
    __typename?: "ProjectLinkConnection";
    edges: Array<ProjectLinkEdge>;
    nodes: Array<ProjectLink>;
    pageInfo: PageInfo;
};
export declare type ProjectLinkCreateInput = {
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The label for the link. */
    label: Scalars["String"];
    /** Related project for the link. */
    projectId: Scalars["String"];
    /** The URL of the link. */
    url: Scalars["String"];
};
export declare type ProjectLinkEdge = {
    __typename?: "ProjectLinkEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: ProjectLink;
};
export declare type ProjectLinkPayload = {
    __typename?: "ProjectLinkPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The project that was created or updated. */
    projectLink: ProjectLink;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type ProjectLinkUpdateInput = {
    /** The label for the link. */
    label?: Maybe<Scalars["String"]>;
    /** The URL of the link. */
    url?: Maybe<Scalars["String"]>;
};
/** A milestone for a project. */
export declare type ProjectMilestone = Node & {
    __typename?: "ProjectMilestone";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The description of the project milestone. */
    description?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The name of the project milestone. */
    name: Scalars["String"];
    /** The project of the milestone. */
    project: Project;
    /** The order of the milestone in relation to other milestones within a project. */
    sortOrder: Scalars["Float"];
    /** The planned completion date of the milestone. */
    targetDate?: Maybe<Scalars["TimelessDate"]>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** Milestone collection filtering options. */
export declare type ProjectMilestoneCollectionFilter = {
    /** Compound filters, all of which need to be matched by the milestone. */
    and?: Maybe<Array<ProjectMilestoneCollectionFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that needs to be matched by all milestones. */
    every?: Maybe<ProjectMilestoneFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the collection length. */
    length?: Maybe<NumberComparator>;
    /** Comparator for the project milestone name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the milestone. */
    or?: Maybe<Array<ProjectMilestoneCollectionFilter>>;
    /** Filters that needs to be matched by some milestones. */
    some?: Maybe<ProjectMilestoneFilter>;
    /** Comparator for the project milestone target date. */
    targetDate?: Maybe<NullableDateComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type ProjectMilestoneConnection = {
    __typename?: "ProjectMilestoneConnection";
    edges: Array<ProjectMilestoneEdge>;
    nodes: Array<ProjectMilestone>;
    pageInfo: PageInfo;
};
export declare type ProjectMilestoneCreateInput = {
    /** The description of the project milestone. */
    description?: Maybe<Scalars["String"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The name of the project milestone. */
    name: Scalars["String"];
    /** Related project for the project milestone. */
    projectId: Scalars["String"];
    /** The sort order for the project milestone within a project. */
    sortOrder?: Maybe<Scalars["Float"]>;
    /** The planned target date of the project milestone. */
    targetDate?: Maybe<Scalars["TimelessDate"]>;
};
export declare type ProjectMilestoneEdge = {
    __typename?: "ProjectMilestoneEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: ProjectMilestone;
};
/** Project milestone filtering options. */
export declare type ProjectMilestoneFilter = {
    /** Compound filters, all of which need to be matched by the project milestone. */
    and?: Maybe<Array<ProjectMilestoneFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the project milestone name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the project milestone. */
    or?: Maybe<Array<ProjectMilestoneFilter>>;
    /** Comparator for the project milestone target date. */
    targetDate?: Maybe<NullableDateComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type ProjectMilestonePayload = {
    __typename?: "ProjectMilestonePayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The project milestone that was created or updated. */
    projectMilestone: ProjectMilestone;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type ProjectMilestoneUpdateInput = {
    /** The description of the project milestone. */
    description?: Maybe<Scalars["String"]>;
    /** The name of the project milestone. */
    name?: Maybe<Scalars["String"]>;
    /** Related project for the project milestone. */
    projectId?: Maybe<Scalars["String"]>;
    /** The sort order for the project milestone within a project. */
    sortOrder?: Maybe<Scalars["Float"]>;
    /** The planned target date of the project milestone. */
    targetDate?: Maybe<Scalars["TimelessDate"]>;
};
/** A project related notification */
export declare type ProjectNotification = Entity & Node & Notification & {
    __typename?: "ProjectNotification";
    /** The user that caused the notification. */
    actor?: Maybe<User>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /**
     * The time at when an email reminder for this notification was sent to the user. Null, if no email
     *     reminder has been sent.
     */
    emailedAt?: Maybe<Scalars["DateTime"]>;
    /** The external user that caused the notification. */
    externalUserActor?: Maybe<ExternalUser>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The project related to the notification. */
    project: Project;
    /** The project update related to the notification. */
    projectUpdate?: Maybe<ProjectUpdate>;
    /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
    readAt?: Maybe<Scalars["DateTime"]>;
    /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
    snoozedUntilAt?: Maybe<Scalars["DateTime"]>;
    /** Notification type */
    type: Scalars["String"];
    /** The time at which a notification was unsnoozed.. */
    unsnoozedAt?: Maybe<Scalars["DateTime"]>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user that received the notification. */
    user: User;
};
/** A project notification subscription. */
export declare type ProjectNotificationSubscription = Entity & Node & NotificationSubscription & {
    __typename?: "ProjectNotificationSubscription";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The type of view to which the notification subscription context is associated with. */
    contextViewType?: Maybe<ContextViewType>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The contextual custom view associated with the notification subscription. */
    customView?: Maybe<CustomView>;
    /** The contextual cycle view associated with the notification subscription. */
    cycle?: Maybe<Cycle>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The contextual label view associated with the notification subscription. */
    label?: Maybe<IssueLabel>;
    /** The type of subscription. */
    notificationSubscriptionTypes: Array<Scalars["String"]>;
    /** The project subscribed to. */
    project: Project;
    /** The user that subscribed to receive notifications. */
    subscriber: User;
    /** The team associated with the notification subscription. */
    team?: Maybe<Team>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user view associated with the notification subscription. */
    user?: Maybe<User>;
    /** The type of user view to which the notification subscription context is associated with. */
    userContextViewType?: Maybe<UserContextViewType>;
};
export declare type ProjectPayload = {
    __typename?: "ProjectPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The project that was created or updated. */
    project?: Maybe<Project>;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type ProjectSearchPayload = {
    __typename?: "ProjectSearchPayload";
    /** Archived entities matching the search term along with all their dependencies. */
    archivePayload: ArchiveResponse;
    edges: Array<ProjectSearchResultEdge>;
    nodes: Array<ProjectSearchResult>;
    pageInfo: PageInfo;
    /** Total number of results for query without filters applied. */
    totalCount: Scalars["Float"];
};
export declare type ProjectSearchResult = Node & {
    __typename?: "ProjectSearchResult";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the project was automatically archived by the auto pruning process. */
    autoArchivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the project was moved into canceled state. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** The project's color. */
    color: Scalars["String"];
    /** The time at which the project was moved into completed state. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The number of completed issues in the project after each week. */
    completedIssueCountHistory: Array<Scalars["Float"]>;
    /** The number of completed estimation points after each week. */
    completedScopeHistory: Array<Scalars["Float"]>;
    /** The project was created based on this issue. */
    convertedFromIssue?: Maybe<Issue>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the project. */
    creator: User;
    /** The project's description. */
    description: Scalars["String"];
    /** Documents associated with the project. */
    documents: DocumentConnection;
    /** The icon of the project. */
    icon?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The number of in progress estimation points after each week. */
    inProgressScopeHistory: Array<Scalars["Float"]>;
    /** Settings for all integrations associated with that project. */
    integrationsSettings?: Maybe<IntegrationsSettings>;
    /** The total number of issues in the project after each week. */
    issueCountHistory: Array<Scalars["Float"]>;
    /** Issues associated with the project. */
    issues: IssueConnection;
    /** The project lead. */
    lead?: Maybe<User>;
    /** Links associated with the project. */
    links: ProjectLinkConnection;
    /** Users that are members of the project. */
    members: UserConnection;
    /** Metadata related to search result */
    metadata: Scalars["JSONObject"];
    /** The project's name. */
    name: Scalars["String"];
    /** The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points. */
    progress: Scalars["Float"];
    /** Milestones associated with the project. */
    projectMilestones: ProjectMilestoneConnection;
    /** The time until which project update reminders are paused. */
    projectUpdateRemindersPausedUntilAt?: Maybe<Scalars["DateTime"]>;
    /** Project updates associated with the project. */
    projectUpdates: ProjectUpdateConnection;
    /** The overall scope (total estimate points) of the project. */
    scope: Scalars["Float"];
    /** The total number of estimation points after each week. */
    scopeHistory: Array<Scalars["Float"]>;
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments: Scalars["Boolean"];
    /** Whether to send new issue status updates to Slack. */
    slackIssueStatuses: Scalars["Boolean"];
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue: Scalars["Boolean"];
    /** The project's unique URL slug. */
    slugId: Scalars["String"];
    /** The sort order for the project within the organization. */
    sortOrder: Scalars["Float"];
    /** The estimated start date of the project. */
    startDate?: Maybe<Scalars["TimelessDate"]>;
    /** The time at which the project was moved into started state. */
    startedAt?: Maybe<Scalars["DateTime"]>;
    /** The type of the state. */
    state: Scalars["String"];
    /** The estimated completion date of the project. */
    targetDate?: Maybe<Scalars["TimelessDate"]>;
    /** Teams associated with this project. */
    teams: TeamConnection;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Project URL. */
    url: Scalars["String"];
};
export declare type ProjectSearchResultDocumentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type ProjectSearchResultIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type ProjectSearchResultLinksArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type ProjectSearchResultMembersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type ProjectSearchResultProjectMilestonesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type ProjectSearchResultProjectUpdatesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type ProjectSearchResultTeamsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type ProjectSearchResultConnection = {
    __typename?: "ProjectSearchResultConnection";
    edges: Array<ProjectSearchResultEdge>;
    nodes: Array<ProjectSearchResult>;
    pageInfo: PageInfo;
};
export declare type ProjectSearchResultEdge = {
    __typename?: "ProjectSearchResultEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: ProjectSearchResult;
};
/** A update associated with an project. */
export declare type ProjectUpdate = Node & {
    __typename?: "ProjectUpdate";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The update content in markdown format. */
    body: Scalars["String"];
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The time the project update was edited. */
    editedAt?: Maybe<Scalars["DateTime"]>;
    /** The health of the project at the time of the update. */
    health: ProjectUpdateHealthType;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** [Internal] Serialized JSON representing current state of the project properties when posting the project update. */
    infoSnapshot?: Maybe<Scalars["JSONObject"]>;
    /** The project that the update is associated with. */
    project: Project;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The URL to the project update. */
    url: Scalars["String"];
    /** The user who wrote the update. */
    user: User;
};
export declare type ProjectUpdateConnection = {
    __typename?: "ProjectUpdateConnection";
    edges: Array<ProjectUpdateEdge>;
    nodes: Array<ProjectUpdate>;
    pageInfo: PageInfo;
};
export declare type ProjectUpdateCreateInput = {
    /** The content of the project update in markdown format. */
    body?: Maybe<Scalars["String"]>;
    /** The content of the project update as a Prosemirror document. */
    bodyData?: Maybe<Scalars["JSON"]>;
    /** The health of the project at the time of the update. */
    health?: Maybe<ProjectUpdateHealthType>;
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The project to associate the project update with. */
    projectId: Scalars["String"];
};
export declare type ProjectUpdateEdge = {
    __typename?: "ProjectUpdateEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: ProjectUpdate;
};
/** The health type of a project when the update is created. */
export declare enum ProjectUpdateHealthType {
    AtRisk = "atRisk",
    OffTrack = "offTrack",
    OnTrack = "onTrack"
}
export declare type ProjectUpdateInput = {
    /** The date when the project was canceled. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** The color of the project. */
    color?: Maybe<Scalars["String"]>;
    /** The date when the project was completed. */
    completedAt?: Maybe<Scalars["DateTime"]>;
    /** The ID of the issue from which that project is created. */
    convertedFromIssueId?: Maybe<Scalars["String"]>;
    /** The description for the project. */
    description?: Maybe<Scalars["String"]>;
    /** The icon of the project. */
    icon?: Maybe<Scalars["String"]>;
    /** The identifier of the project lead. */
    leadId?: Maybe<Scalars["String"]>;
    /** The identifiers of the members of this project. */
    memberIds?: Maybe<Array<Scalars["String"]>>;
    /** The name of the project. */
    name?: Maybe<Scalars["String"]>;
    /** The time until which project update reminders are paused. */
    projectUpdateRemindersPausedUntilAt?: Maybe<Scalars["DateTime"]>;
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments?: Maybe<Scalars["Boolean"]>;
    /** Whether to send issue status update notifications to Slack. */
    slackIssueStatuses?: Maybe<Scalars["Boolean"]>;
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue?: Maybe<Scalars["Boolean"]>;
    /** The sort order for the project in shared views. */
    sortOrder?: Maybe<Scalars["Float"]>;
    /** The planned start date of the project. */
    startDate?: Maybe<Scalars["TimelessDate"]>;
    /** The state of the project. */
    state?: Maybe<Scalars["String"]>;
    /** The planned target date of the project. */
    targetDate?: Maybe<Scalars["TimelessDate"]>;
    /** The identifiers of the teams this project is associated with. */
    teamIds?: Maybe<Array<Scalars["String"]>>;
};
/** Holds information about when a user has interacted with a project update. */
export declare type ProjectUpdateInteraction = Node & {
    __typename?: "ProjectUpdateInteraction";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The project update that has been interacted with. */
    projectUpdate: ProjectUpdate;
    /** The time at which the user read the project update. */
    readAt: Scalars["DateTime"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user that has interacted with the project update. */
    user: User;
};
export declare type ProjectUpdateInteractionConnection = {
    __typename?: "ProjectUpdateInteractionConnection";
    edges: Array<ProjectUpdateInteractionEdge>;
    nodes: Array<ProjectUpdateInteraction>;
    pageInfo: PageInfo;
};
export declare type ProjectUpdateInteractionCreateInput = {
    /** The identifier. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The id of the project update that has been interacted with. */
    projectUpdateId: Scalars["String"];
    /** The time at which the user read the project update. */
    readAt: Scalars["DateTime"];
};
export declare type ProjectUpdateInteractionEdge = {
    __typename?: "ProjectUpdateInteractionEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: ProjectUpdateInteraction;
};
export declare type ProjectUpdateInteractionPayload = {
    __typename?: "ProjectUpdateInteractionPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The project update interaction that was created or updated. */
    projectUpdateInteraction: ProjectUpdateInteraction;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type ProjectUpdatePayload = {
    __typename?: "ProjectUpdatePayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The project update that was created or updated. */
    projectUpdate: ProjectUpdate;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** The frequency at which to send project update reminders. */
export declare enum ProjectUpdateReminderFrequency {
    Never = "never",
    TwoWeeks = "twoWeeks",
    Week = "week"
}
export declare type ProjectUpdateUpdateInput = {
    /** The content of the project update in markdown format. */
    body?: Maybe<Scalars["String"]>;
    /** The content of the project update as a Prosemirror document. */
    bodyData?: Maybe<Scalars["JSON"]>;
    /** The health of the project at the time of the update. */
    health?: Maybe<ProjectUpdateHealthType>;
};
export declare type ProjectUpdateWithInteractionPayload = {
    __typename?: "ProjectUpdateWithInteractionPayload";
    /** The project update that was created or updated. */
    interaction: ProjectUpdateInteraction;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The project update that was created or updated. */
    projectUpdate: ProjectUpdate;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** A user's web browser push notification subscription. */
export declare type PushSubscription = Node & {
    __typename?: "PushSubscription";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type PushSubscriptionConnection = {
    __typename?: "PushSubscriptionConnection";
    edges: Array<PushSubscriptionEdge>;
    nodes: Array<PushSubscription>;
    pageInfo: PageInfo;
};
export declare type PushSubscriptionCreateInput = {
    /** The data of the subscription in stringified JSON format. */
    data: Scalars["String"];
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** Whether this is a subscription payload for Google Cloud Messaging or Apple Push Notification service */
    type?: Maybe<PushSubscriptionType>;
    /** The user identifier of the subscription. */
    userId: Scalars["String"];
};
export declare type PushSubscriptionEdge = {
    __typename?: "PushSubscriptionEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: PushSubscription;
};
export declare type PushSubscriptionPayload = {
    __typename?: "PushSubscriptionPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type PushSubscriptionTestPayload = {
    __typename?: "PushSubscriptionTestPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** The different push subscription types */
export declare enum PushSubscriptionType {
    Apple = "apple",
    Web = "web"
}
export declare type Query = {
    __typename?: "Query";
    /** One specific project milestone. */
    ProjectMilestone: ProjectMilestone;
    /** All milestones for the project. */
    ProjectMilestones: ProjectMilestoneConnection;
    /** All teams you the user can administrate. Administrable teams are teams whose settings the user can change, but to whose issues the user doesn't necessarily have access to. */
    administrableTeams: TeamConnection;
    /** All API keys for the user. */
    apiKeys: ApiKeyConnection;
    /** Get basic information for an application. */
    applicationInfo: Application;
    /** [INTERNAL] Get basic information for a list of applications */
    applicationInfoByIds: Array<Application>;
    /** Get information for an application and whether a user has approved it for the given scopes. */
    applicationWithAuthorization: UserAuthorizedApplication;
    /**
     * One specific issue attachment.
     * [Deprecated] 'url' can no longer be used as the 'id' parameter. Use 'attachmentsForUrl' instead
     */
    attachment: Attachment;
    /**
     * Query an issue by its associated attachment, and its id.
     * @deprecated Will be removed in near future, please use `attachmentsForURL` to get attachments and their issues instead.
     */
    attachmentIssue: Issue;
    /** [Internal] Get a list of all unique attachment sources in the workspace */
    attachmentSources: AttachmentSourcesPayload;
    /**
     * All issue attachments.
     *
     * To get attachments for a given URL, use `attachmentsForURL` query.
     */
    attachments: AttachmentConnection;
    /** Returns issue attachments for a given `url`. */
    attachmentsForURL: AttachmentConnection;
    /** All audit log entries. */
    auditEntries: AuditEntryConnection;
    /** List of audit entry types. */
    auditEntryTypes: Array<AuditEntryType>;
    /** [INTERNAL] Get all authorized applications for a user */
    authorizedApplications: Array<AuthorizedApplication>;
    /** Fetch users belonging to this user account. */
    availableUsers: AuthResolverResponse;
    /** A specific comment. */
    comment: Comment;
    /** All comments. */
    comments: CommentConnection;
    /** One specific custom view. */
    customView: CustomView;
    /** [INTERNAL] Suggests metadata for a view based on it's filters. */
    customViewDetailsSuggestion: CustomViewSuggestionPayload;
    /** Custom views for the user. */
    customViews: CustomViewConnection;
    /** One specific cycle. */
    cycle: Cycle;
    /** All cycles. */
    cycles: CycleConnection;
    /** One specific document. */
    document: Document;
    /** All documents for the project. */
    documents: DocumentConnection;
    /** Returns embed info for any url */
    embedInfo: EmbedPayload;
    /** A specific emoji. */
    emoji: Emoji;
    /** All custom emojis. */
    emojis: EmojiConnection;
    /** One specific external user. */
    externalUser: ExternalUser;
    /** All external users for the organization. */
    externalUsers: ExternalUserConnection;
    /** One specific favorite. */
    favorite: Favorite;
    /** The user's favorites. */
    favorites: FavoriteConnection;
    /** Fetch Figma screenshot and other information with file and node identifiers. */
    figmaEmbedInfo: FigmaEmbedPayload;
    /** One specific integration. */
    integration: Integration;
    /** One specific integrationTemplate. */
    integrationTemplate: IntegrationTemplate;
    /** Template and integration connections. */
    integrationTemplates: IntegrationTemplateConnection;
    /** All integrations. */
    integrations: IntegrationConnection;
    /** One specific set of settings. */
    integrationsSettings: IntegrationsSettings;
    /** One specific issue. */
    issue: Issue;
    /** Find issues that are related to a given Figma file key. */
    issueFigmaFileKeySearch: IssueConnection;
    /** Suggests filters for an issue view based on a text prompt. */
    issueFilterSuggestion: IssueFilterSuggestionPayload;
    /** Checks a CSV file validity against a specific import service. */
    issueImportCheckCSV: IssueImportCheckPayload;
    /** Fetches the GitHub token, completing the OAuth flow. */
    issueImportFinishGithubOAuth: GithubOAuthTokenPayload;
    /** One specific label. */
    issueLabel: IssueLabel;
    /** All issue labels. */
    issueLabels: IssueLabelConnection;
    /** Issue priority values and corresponding labels. */
    issuePriorityValues: Array<IssuePriorityValue>;
    /** One specific issue relation. */
    issueRelation: IssueRelation;
    /** All issue relationships. */
    issueRelations: IssueRelationConnection;
    /** [DEPRECATED] Search issues. This endpoint is deprecated and will be removed in the future  use `searchIssues` instead. */
    issueSearch: IssueConnection;
    /** Find issue based on the VCS branch name. */
    issueVcsBranchSearch?: Maybe<Issue>;
    /** All issues. */
    issues: IssueConnection;
    /** One specific notification. */
    notification: Notification;
    /** One specific notification subscription. */
    notificationSubscription: NotificationSubscription;
    /** The user's notification subscriptions. */
    notificationSubscriptions: NotificationSubscriptionConnection;
    /** All notifications. */
    notifications: NotificationConnection;
    /** The user's organization. */
    organization: Organization;
    /** [INTERNAL] Checks whether the domain can be claimed. */
    organizationDomainClaimRequest: OrganizationDomainClaimPayload;
    /** Does the organization exist. */
    organizationExists: OrganizationExistsPayload;
    /** One specific organization invite. */
    organizationInvite: OrganizationInvite;
    /** One specific organization invite. */
    organizationInviteDetails: OrganizationInviteDetailsPayload;
    /** All invites for the organization. */
    organizationInvites: OrganizationInviteConnection;
    /** One specific project. */
    project: Project;
    /** Suggests filters for a project view based on a text prompt. */
    projectFilterSuggestion: ProjectFilterSuggestionPayload;
    /** One specific project link. */
    projectLink: ProjectLink;
    /** All links for the project. */
    projectLinks: ProjectLinkConnection;
    /** A specific project update. */
    projectUpdate: ProjectUpdate;
    /** A specific interaction on a project update. */
    projectUpdateInteraction: ProjectUpdateInteraction;
    /** All interactions on project updates. */
    projectUpdateInteractions: ProjectUpdateInteractionConnection;
    /** All project updates. */
    projectUpdates: ProjectUpdateConnection;
    /** All projects. */
    projects: ProjectConnection;
    /** Sends a test push message. */
    pushSubscriptionTest: PushSubscriptionTestPayload;
    /** The status of the rate limiter. */
    rateLimitStatus: RateLimitPayload;
    /** One specific roadmap. */
    roadmap: Roadmap;
    /** One specific roadmapToProject. */
    roadmapToProject: RoadmapToProject;
    /** Custom views for the user. */
    roadmapToProjects: RoadmapToProjectConnection;
    /** All roadmaps in the workspace. */
    roadmaps: RoadmapConnection;
    /** Search documents. */
    searchDocuments: DocumentSearchPayload;
    /** Search issues. */
    searchIssues: IssueSearchPayload;
    /** Search projects. */
    searchProjects: ProjectSearchPayload;
    /** Fetch SSO login URL for the email provided. */
    ssoUrlFromEmail: SsoUrlFromEmailResponse;
    /** One specific team. */
    team: Team;
    /** One specific team membership. */
    teamMembership: TeamMembership;
    /** All team memberships. */
    teamMemberships: TeamMembershipConnection;
    /** All teams whose issues can be accessed by the user. This might be different from `administrableTeams`, which also includes teams whose settings can be changed by the user. */
    teams: TeamConnection;
    /** A specific template. */
    template: Template;
    /** All templates from all users. */
    templates: Array<Template>;
    /** Returns all templates that are associated with the integration type. */
    templatesForIntegration: Array<Template>;
    /** One specific user. */
    user: User;
    /** Finds a user account by email. */
    userAccountExists?: Maybe<UserAccountExistsPayload>;
    /** The user's settings. */
    userSettings: UserSettings;
    /** All users for the organization. */
    users: UserConnection;
    /** The currently authenticated user. */
    viewer: User;
    /** A specific webhook. */
    webhook: Webhook;
    /** All webhooks. */
    webhooks: WebhookConnection;
    /** One specific state. */
    workflowState: WorkflowState;
    /** All issue workflow states. */
    workflowStates: WorkflowStateConnection;
    /** [INTERNAL] Get all authorized applications (with limited fields) for a workspace */
    workspaceAuthorizedApplications: Array<WorkspaceAuthorizedApplication>;
};
export declare type QueryProjectMilestoneArgs = {
    id: Scalars["String"];
};
export declare type QueryProjectMilestonesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<ProjectMilestoneFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryAdministrableTeamsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryApiKeysArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryApplicationInfoArgs = {
    clientId: Scalars["String"];
};
export declare type QueryApplicationInfoByIdsArgs = {
    ids: Array<Scalars["String"]>;
};
export declare type QueryApplicationWithAuthorizationArgs = {
    actor?: Maybe<Scalars["String"]>;
    clientId: Scalars["String"];
    redirectUri?: Maybe<Scalars["String"]>;
    scope: Array<Scalars["String"]>;
};
export declare type QueryAttachmentArgs = {
    id: Scalars["String"];
};
export declare type QueryAttachmentIssueArgs = {
    id: Scalars["String"];
};
export declare type QueryAttachmentSourcesArgs = {
    teamId?: Maybe<Scalars["String"]>;
};
export declare type QueryAttachmentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<AttachmentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryAttachmentsForUrlArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    url: Scalars["String"];
};
export declare type QueryAuditEntriesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<AuditEntryFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryCommentArgs = {
    id: Scalars["String"];
};
export declare type QueryCommentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CommentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryCustomViewArgs = {
    id: Scalars["String"];
};
export declare type QueryCustomViewDetailsSuggestionArgs = {
    filter: Scalars["JSONObject"];
    modelName?: Maybe<Scalars["String"]>;
};
export declare type QueryCustomViewsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryCycleArgs = {
    id: Scalars["String"];
};
export declare type QueryCyclesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CycleFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryDocumentArgs = {
    id: Scalars["String"];
};
export declare type QueryDocumentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryEmbedInfoArgs = {
    url: Scalars["String"];
};
export declare type QueryEmojiArgs = {
    id: Scalars["String"];
};
export declare type QueryEmojisArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryExternalUserArgs = {
    id: Scalars["String"];
};
export declare type QueryExternalUsersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryFavoriteArgs = {
    id: Scalars["String"];
};
export declare type QueryFavoritesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryFigmaEmbedInfoArgs = {
    fileId: Scalars["String"];
    nodeId?: Maybe<Scalars["String"]>;
};
export declare type QueryIntegrationArgs = {
    id: Scalars["String"];
};
export declare type QueryIntegrationTemplateArgs = {
    id: Scalars["String"];
};
export declare type QueryIntegrationTemplatesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryIntegrationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryIntegrationsSettingsArgs = {
    id: Scalars["String"];
};
export declare type QueryIssueArgs = {
    id: Scalars["String"];
};
export declare type QueryIssueFigmaFileKeySearchArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    fileKey: Scalars["String"];
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryIssueFilterSuggestionArgs = {
    prompt: Scalars["String"];
};
export declare type QueryIssueImportCheckCsvArgs = {
    csvUrl: Scalars["String"];
    service: Scalars["String"];
};
export declare type QueryIssueImportFinishGithubOAuthArgs = {
    code: Scalars["String"];
};
export declare type QueryIssueLabelArgs = {
    id: Scalars["String"];
};
export declare type QueryIssueLabelsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryIssueRelationArgs = {
    id: Scalars["String"];
};
export declare type QueryIssueRelationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryIssueSearchArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    query?: Maybe<Scalars["String"]>;
};
export declare type QueryIssueVcsBranchSearchArgs = {
    branchName: Scalars["String"];
};
export declare type QueryIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryNotificationArgs = {
    id: Scalars["String"];
};
export declare type QueryNotificationSubscriptionArgs = {
    id: Scalars["String"];
};
export declare type QueryNotificationSubscriptionsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryNotificationsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryOrganizationDomainClaimRequestArgs = {
    id: Scalars["String"];
};
export declare type QueryOrganizationExistsArgs = {
    urlKey: Scalars["String"];
};
export declare type QueryOrganizationInviteArgs = {
    id: Scalars["String"];
};
export declare type QueryOrganizationInviteDetailsArgs = {
    id: Scalars["String"];
};
export declare type QueryOrganizationInvitesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryProjectArgs = {
    id: Scalars["String"];
};
export declare type QueryProjectFilterSuggestionArgs = {
    prompt: Scalars["String"];
};
export declare type QueryProjectLinkArgs = {
    id: Scalars["String"];
};
export declare type QueryProjectLinksArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryProjectUpdateArgs = {
    id: Scalars["String"];
};
export declare type QueryProjectUpdateInteractionArgs = {
    id: Scalars["String"];
};
export declare type QueryProjectUpdateInteractionsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryProjectUpdatesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryProjectsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<ProjectFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryRoadmapArgs = {
    id: Scalars["String"];
};
export declare type QueryRoadmapToProjectArgs = {
    id: Scalars["String"];
};
export declare type QueryRoadmapToProjectsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryRoadmapsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QuerySearchDocumentsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    term: Scalars["String"];
};
export declare type QuerySearchIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    term: Scalars["String"];
};
export declare type QuerySearchProjectsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    term: Scalars["String"];
};
export declare type QuerySsoUrlFromEmailArgs = {
    email: Scalars["String"];
    isDesktop?: Maybe<Scalars["Boolean"]>;
};
export declare type QueryTeamArgs = {
    id: Scalars["String"];
};
export declare type QueryTeamMembershipArgs = {
    id: Scalars["String"];
};
export declare type QueryTeamMembershipsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryTeamsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryTemplateArgs = {
    id: Scalars["String"];
};
export declare type QueryTemplatesForIntegrationArgs = {
    integrationType: Scalars["String"];
};
export declare type QueryUserArgs = {
    id: Scalars["String"];
};
export declare type QueryUserAccountExistsArgs = {
    email: Scalars["String"];
};
export declare type QueryUsersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryWebhookArgs = {
    id: Scalars["String"];
};
export declare type QueryWebhooksArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type QueryWorkflowStateArgs = {
    id: Scalars["String"];
};
export declare type QueryWorkflowStatesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<WorkflowStateFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
export declare type RateLimitPayload = {
    __typename?: "RateLimitPayload";
    /** The identifier we rate limit on. */
    identifier?: Maybe<Scalars["String"]>;
    /** The kind of rate limit selected for this request. */
    kind: Scalars["String"];
    /** The state of the rate limit. */
    limits: Array<RateLimitResultPayload>;
};
export declare type RateLimitResultPayload = {
    __typename?: "RateLimitResultPayload";
    /** The total allowed quantity for this type of limit. */
    allowedAmount: Scalars["Float"];
    /** The period in which the rate limit is fully replenished in ms. */
    period: Scalars["Float"];
    /** The remaining quantity for this type of limit after this request. */
    remainingAmount: Scalars["Float"];
    /** The requested quantity for this type of limit. */
    requestedAmount: Scalars["Float"];
    /** The timestamp after the rate limit is fully replenished as a UNIX timestamp. */
    reset: Scalars["Float"];
    /** What is being rate limited. */
    type: Scalars["String"];
};
/** A reaction associated with a comment or a project update. */
export declare type Reaction = Node & {
    __typename?: "Reaction";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Name of the reaction's emoji. */
    emoji: Scalars["String"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user who reacted. */
    user?: Maybe<User>;
};
export declare type ReactionConnection = {
    __typename?: "ReactionConnection";
    edges: Array<ReactionEdge>;
    nodes: Array<Reaction>;
    pageInfo: PageInfo;
};
export declare type ReactionCreateInput = {
    /** The comment to associate the reaction with. */
    commentId?: Maybe<Scalars["String"]>;
    /** The emoji the user reacted with. */
    emoji?: Maybe<Scalars["String"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one */
    id?: Maybe<Scalars["String"]>;
    /** The issue to associate the reaction with. */
    issueId?: Maybe<Scalars["String"]>;
    /** The project update to associate the reaction with. */
    projectUpdateId?: Maybe<Scalars["String"]>;
};
export declare type ReactionEdge = {
    __typename?: "ReactionEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Reaction;
};
export declare type ReactionPayload = {
    __typename?: "ReactionPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    reaction: Reaction;
    success: Scalars["Boolean"];
};
/** Comparator for relation existence. */
export declare type RelationExistsComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["Boolean"]>;
    /** Not equals constraint. */
    neq?: Maybe<Scalars["Boolean"]>;
};
/** Features release channel */
export declare enum ReleaseChannel {
    Beta = "beta",
    Internal = "internal",
    PreRelease = "preRelease",
    Public = "public"
}
/** A roadmap for projects. */
export declare type Roadmap = Node & {
    __typename?: "Roadmap";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The roadmap's color. */
    color?: Maybe<Scalars["String"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the roadmap. */
    creator: User;
    /** The description of the roadmap. */
    description?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The name of the roadmap. */
    name: Scalars["String"];
    /** The organization of the roadmap. */
    organization: Organization;
    /** The user who owns the roadmap. */
    owner: User;
    /** Projects associated with the roadmap. */
    projects: ProjectConnection;
    /** The roadmap's unique URL slug. */
    slugId: Scalars["String"];
    /** The sort order of the roadmap within the organization. */
    sortOrder: Scalars["Float"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** A roadmap for projects. */
export declare type RoadmapProjectsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<ProjectFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A generic payload return from entity archive mutations. */
export declare type RoadmapArchivePayload = ArchivePayload & {
    __typename?: "RoadmapArchivePayload";
    /** The archived/unarchived entity. Null if entity was deleted. */
    entity?: Maybe<Roadmap>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Roadmap collection filtering options. */
export declare type RoadmapCollectionFilter = {
    /** Compound filters, all of which need to be matched by the roadmap. */
    and?: Maybe<Array<RoadmapCollectionFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the roadmap creator must satisfy. */
    creator?: Maybe<UserFilter>;
    /** Filters that needs to be matched by all roadmaps. */
    every?: Maybe<RoadmapFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the collection length. */
    length?: Maybe<NumberComparator>;
    /** Comparator for the roadmap name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the roadmap. */
    or?: Maybe<Array<RoadmapCollectionFilter>>;
    /** Comparator for the roadmap slug ID. */
    slugId?: Maybe<StringComparator>;
    /** Filters that needs to be matched by some roadmaps. */
    some?: Maybe<RoadmapFilter>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type RoadmapConnection = {
    __typename?: "RoadmapConnection";
    edges: Array<RoadmapEdge>;
    nodes: Array<Roadmap>;
    pageInfo: PageInfo;
};
export declare type RoadmapCreateInput = {
    /** The roadmap's color. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the roadmap. */
    description?: Maybe<Scalars["String"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The name of the roadmap. */
    name: Scalars["String"];
    /** The owner of the roadmap */
    ownerId?: Maybe<Scalars["String"]>;
    /** The sort order of the roadmap within the organization. */
    sortOrder?: Maybe<Scalars["Float"]>;
};
export declare type RoadmapEdge = {
    __typename?: "RoadmapEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Roadmap;
};
/** Roadmap filtering options. */
export declare type RoadmapFilter = {
    /** Compound filters, all of which need to be matched by the roadmap. */
    and?: Maybe<Array<RoadmapFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that the roadmap creator must satisfy. */
    creator?: Maybe<UserFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the roadmap name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the roadmap. */
    or?: Maybe<Array<RoadmapFilter>>;
    /** Comparator for the roadmap slug ID. */
    slugId?: Maybe<StringComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type RoadmapPayload = {
    __typename?: "RoadmapPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The roadmap that was created or updated. */
    roadmap: Roadmap;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Join table between projects and roadmaps */
export declare type RoadmapToProject = Node & {
    __typename?: "RoadmapToProject";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The project that the roadmap is associated with. */
    project: Project;
    /** The roadmap that the project is associated with. */
    roadmap: Roadmap;
    /** The sort order of the project within the roadmap. */
    sortOrder: Scalars["String"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type RoadmapToProjectConnection = {
    __typename?: "RoadmapToProjectConnection";
    edges: Array<RoadmapToProjectEdge>;
    nodes: Array<RoadmapToProject>;
    pageInfo: PageInfo;
};
export declare type RoadmapToProjectCreateInput = {
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The identifier of the project. */
    projectId: Scalars["String"];
    /** The identifier of the roadmap. */
    roadmapId: Scalars["String"];
    /** The sort order for the project within its organization. */
    sortOrder?: Maybe<Scalars["Float"]>;
};
export declare type RoadmapToProjectEdge = {
    __typename?: "RoadmapToProjectEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: RoadmapToProject;
};
export declare type RoadmapToProjectPayload = {
    __typename?: "RoadmapToProjectPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** The roadmapToProject that was created or updated. */
    roadmapToProject: RoadmapToProject;
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type RoadmapToProjectUpdateInput = {
    /** The sort order for the project within its organization. */
    sortOrder?: Maybe<Scalars["Float"]>;
};
export declare type RoadmapUpdateInput = {
    /** The roadmap's color. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the roadmap. */
    description?: Maybe<Scalars["String"]>;
    /** The name of the roadmap. */
    name?: Maybe<Scalars["String"]>;
    /** The owner of the roadmap */
    ownerId?: Maybe<Scalars["String"]>;
    /** The sort order of the roadmap within the organization. */
    sortOrder?: Maybe<Scalars["Float"]>;
};
export declare type SamlConfiguration = {
    __typename?: "SamlConfiguration";
    /** The issuer's custom entity ID. */
    issuerEntityId?: Maybe<Scalars["String"]>;
    /** Binding method for authentication call. Can be either `post` (default) or `redirect`. */
    ssoBinding?: Maybe<Scalars["String"]>;
    /** Sign in endpoint URL for the identity provider. */
    ssoEndpoint?: Maybe<Scalars["String"]>;
    /** The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`. */
    ssoSignAlgo?: Maybe<Scalars["String"]>;
    /** X.509 Signing Certificate in string form. */
    ssoSigningCert?: Maybe<Scalars["String"]>;
};
export declare type SamlConfigurationInput = {
    /** The issuer's custom entity ID. */
    issuerEntityId?: Maybe<Scalars["String"]>;
    /** Binding method for authentication call. Can be either `post` (default) or `redirect`. */
    ssoBinding?: Maybe<Scalars["String"]>;
    /** Sign in endpoint URL for the identity provider. */
    ssoEndpoint?: Maybe<Scalars["String"]>;
    /** The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`. */
    ssoSignAlgo?: Maybe<Scalars["String"]>;
    /** X.509 Signing Certificate in string form. */
    ssoSigningCert?: Maybe<Scalars["String"]>;
};
/** The organization's SAML configuration */
export declare type SamlConfigurationPayload = {
    __typename?: "SamlConfigurationPayload";
    /** The issuer's custom entity ID. */
    issuerEntityId?: Maybe<Scalars["String"]>;
    /** Binding method for authentication call. Can be either `post` (default) or `redirect`. */
    ssoBinding?: Maybe<Scalars["String"]>;
    /** Sign in endpoint URL for the identity provider. */
    ssoEndpoint?: Maybe<Scalars["String"]>;
    /** The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`. */
    ssoSignAlgo?: Maybe<Scalars["String"]>;
};
/** Sentry specific settings. */
export declare type SentrySettings = {
    __typename?: "SentrySettings";
    /** The slug of the Sentry organization being connected. */
    organizationSlug: Scalars["String"];
};
export declare type SentrySettingsInput = {
    /** The slug of the Sentry organization being connected. */
    organizationSlug: Scalars["String"];
};
export declare enum SlaStatus {
    Breached = "Breached",
    Completed = "Completed",
    Failed = "Failed",
    HighRisk = "HighRisk",
    LowRisk = "LowRisk",
    MediumRisk = "MediumRisk"
}
/** Comparator for sla status. */
export declare type SlaStatusComparator = {
    /** Equals constraint. */
    eq?: Maybe<SlaStatus>;
    /** In-array constraint. */
    in?: Maybe<Array<SlaStatus>>;
    /** Not-equals constraint. */
    neq?: Maybe<SlaStatus>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<SlaStatus>>;
    /** Null constraint. Matches any non-null values if the given value is false, otherwise it matches null values. */
    null?: Maybe<Scalars["Boolean"]>;
};
/** Slack notification specific settings. */
export declare type SlackPostSettings = {
    __typename?: "SlackPostSettings";
    channel: Scalars["String"];
    channelId: Scalars["String"];
    configurationUrl: Scalars["String"];
};
export declare type SlackPostSettingsInput = {
    channel: Scalars["String"];
    channelId: Scalars["String"];
    configurationUrl: Scalars["String"];
};
/** Comparator for `sourceType` field. */
export declare type SourceTypeComparator = {
    /** Contains constraint. Matches any values that contain the given string. */
    contains?: Maybe<Scalars["String"]>;
    /** Contains case insensitive constraint. Matches any values that contain the given string case insensitive. */
    containsIgnoreCase?: Maybe<Scalars["String"]>;
    /** Ends with constraint. Matches any values that end with the given string. */
    endsWith?: Maybe<Scalars["String"]>;
    /** Equals constraint. */
    eq?: Maybe<Scalars["String"]>;
    /** Equals case insensitive. Matches any values that matches the given string case insensitive. */
    eqIgnoreCase?: Maybe<Scalars["String"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["String"]>>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["String"]>;
    /** Not-equals case insensitive. Matches any values that don't match the given string case insensitive. */
    neqIgnoreCase?: Maybe<Scalars["String"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["String"]>>;
    /** Doesn't contain constraint. Matches any values that don't contain the given string. */
    notContains?: Maybe<Scalars["String"]>;
    /** Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive. */
    notContainsIgnoreCase?: Maybe<Scalars["String"]>;
    /** Doesn't end with constraint. Matches any values that don't end with the given string. */
    notEndsWith?: Maybe<Scalars["String"]>;
    /** Doesn't start with constraint. Matches any values that don't start with the given string. */
    notStartsWith?: Maybe<Scalars["String"]>;
    /** Starts with constraint. Matches any values that start with the given string. */
    startsWith?: Maybe<Scalars["String"]>;
    /** Starts with case insensitive constraint. Matches any values that start with the given string. */
    startsWithIgnoreCase?: Maybe<Scalars["String"]>;
};
export declare type SsoUrlFromEmailResponse = {
    __typename?: "SsoUrlFromEmailResponse";
    /** SAML SSO sign-in URL. */
    samlSsoUrl: Scalars["String"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Comparator for strings. */
export declare type StringComparator = {
    /** Contains constraint. Matches any values that contain the given string. */
    contains?: Maybe<Scalars["String"]>;
    /** Contains case insensitive constraint. Matches any values that contain the given string case insensitive. */
    containsIgnoreCase?: Maybe<Scalars["String"]>;
    /** Ends with constraint. Matches any values that end with the given string. */
    endsWith?: Maybe<Scalars["String"]>;
    /** Equals constraint. */
    eq?: Maybe<Scalars["String"]>;
    /** Equals case insensitive. Matches any values that matches the given string case insensitive. */
    eqIgnoreCase?: Maybe<Scalars["String"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["String"]>>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["String"]>;
    /** Not-equals case insensitive. Matches any values that don't match the given string case insensitive. */
    neqIgnoreCase?: Maybe<Scalars["String"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["String"]>>;
    /** Doesn't contain constraint. Matches any values that don't contain the given string. */
    notContains?: Maybe<Scalars["String"]>;
    /** Doesn't contain case insensitive constraint. Matches any values that don't contain the given string case insensitive. */
    notContainsIgnoreCase?: Maybe<Scalars["String"]>;
    /** Doesn't end with constraint. Matches any values that don't end with the given string. */
    notEndsWith?: Maybe<Scalars["String"]>;
    /** Doesn't start with constraint. Matches any values that don't start with the given string. */
    notStartsWith?: Maybe<Scalars["String"]>;
    /** Starts with constraint. Matches any values that start with the given string. */
    startsWith?: Maybe<Scalars["String"]>;
    /** Starts with case insensitive constraint. Matches any values that start with the given string. */
    startsWithIgnoreCase?: Maybe<Scalars["String"]>;
};
/**
 * Contains either the full serialized state of the application or delta packets that the requester can
 *   apply to the local data set in order to be up-to-date.
 */
export declare type SyncResponse = {
    __typename?: "SyncResponse";
    /** The version of the remote database. Incremented by 1 for each migration run on the database. */
    databaseVersion: Scalars["Float"];
    /**
     * JSON serialized delta changes that the client can apply to its local state
     *     in order to catch up with the state of the world.
     */
    delta?: Maybe<Scalars["String"]>;
    /** The last sync id covered by the response. */
    lastSyncId: Scalars["Float"];
    /**
     * The full state of the organization as a serialized JSON object.
     *     Mutually exclusive with the delta property
     */
    state?: Maybe<Scalars["String"]>;
    /** The sync groups that the user is subscribed to. */
    subscribedSyncGroups: Array<Scalars["String"]>;
};
export declare type SynchronizedPayload = {
    __typename?: "SynchronizedPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
};
/** An organizational unit that contains issues. */
export declare type Team = Node & {
    __typename?: "Team";
    /** Team's currently active cycle. */
    activeCycle?: Maybe<Cycle>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** Period after which automatically closed and completed issues are automatically archived in months. */
    autoArchivePeriod: Scalars["Float"];
    /** Period after which issues are automatically closed in months. Null/undefined means disabled. */
    autoClosePeriod?: Maybe<Scalars["Float"]>;
    /** The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state. */
    autoCloseStateId?: Maybe<Scalars["String"]>;
    /** The team's color. */
    color?: Maybe<Scalars["String"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Calendar feed URL (iCal) for cycles. */
    cycleCalenderUrl: Scalars["String"];
    /** The cooldown time after each cycle in weeks. */
    cycleCooldownTime: Scalars["Float"];
    /** The duration of a cycle in weeks. */
    cycleDuration: Scalars["Float"];
    /** Auto assign completed issues to current cycle. */
    cycleIssueAutoAssignCompleted: Scalars["Boolean"];
    /** Auto assign started issues to current cycle. */
    cycleIssueAutoAssignStarted: Scalars["Boolean"];
    /** Only allow issues issues with cycles in Active Issues. */
    cycleLockToActive: Scalars["Boolean"];
    /** The day of the week that a new cycle starts. */
    cycleStartDay: Scalars["Float"];
    /** Cycles associated with the team. */
    cycles: CycleConnection;
    /** Whether the team uses cycles. */
    cyclesEnabled: Scalars["Boolean"];
    /** What to use as an default estimate for unestimated issues. */
    defaultIssueEstimate: Scalars["Float"];
    /** The default workflow state into which issues are set when they are opened by team members. */
    defaultIssueState?: Maybe<WorkflowState>;
    /** The default template to use for new issues created by members of the team. */
    defaultTemplateForMembers?: Maybe<Template>;
    /**
     * The id of the default template to use for new issues created by members of the team.
     * @deprecated Use defaultTemplateForMembers instead
     */
    defaultTemplateForMembersId?: Maybe<Scalars["String"]>;
    /** The default template to use for new issues created by non-members of the team. */
    defaultTemplateForNonMembers?: Maybe<Template>;
    /**
     * The id of the default template to use for new issues created by non-members of the team.
     * @deprecated Use defaultTemplateForNonMembers instead
     */
    defaultTemplateForNonMembersId?: Maybe<Scalars["String"]>;
    /** The team's description. */
    description?: Maybe<Scalars["String"]>;
    /** The workflow state into which issues are moved when a PR has been opened as draft. */
    draftWorkflowState?: Maybe<WorkflowState>;
    /** Whether to group recent issue history entries. */
    groupIssueHistory: Scalars["Boolean"];
    /** The icon of the team. */
    icon?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Settings for all integrations associated with that team. */
    integrationsSettings?: Maybe<IntegrationsSettings>;
    /** Unique hash for the team to be used in invite URLs. */
    inviteHash: Scalars["String"];
    /** Number of issues in the team. */
    issueCount: Scalars["Int"];
    /** Whether to allow zeros in issues estimates. */
    issueEstimationAllowZero: Scalars["Boolean"];
    /** Whether to add additional points to the estimate scale. */
    issueEstimationExtended: Scalars["Boolean"];
    /** The issue estimation type to use. Must be one of "notUsed", "exponential", "fibonacci", "linear", "tShirt". */
    issueEstimationType: Scalars["String"];
    /** Whether issues without priority should be sorted first. */
    issueOrderingNoPriorityFirst: Scalars["Boolean"];
    /** Whether to move issues to bottom of the column when changing state. */
    issueSortOrderDefaultToBottom: Scalars["Boolean"];
    /** Issues associated with the team. */
    issues: IssueConnection;
    /** The team's unique key. The key is used in URLs. */
    key: Scalars["String"];
    /** Labels associated with the team. */
    labels: IssueLabelConnection;
    /** The workflow state into which issues are moved when they are marked as a duplicate of another issue. Defaults to the first canceled state. */
    markedAsDuplicateWorkflowState?: Maybe<WorkflowState>;
    /** Users who are members of this team. */
    members: UserConnection;
    /** Memberships associated with the team. For easier access of the same data, use `members` query. */
    memberships: TeamMembershipConnection;
    /** The workflow state into which issues are moved when a PR has been merged. */
    mergeWorkflowState?: Maybe<WorkflowState>;
    /** The team's name. */
    name: Scalars["String"];
    /** The organization that the team is associated with. */
    organization: Organization;
    /** Whether the team is private or not. */
    private: Scalars["Boolean"];
    /** Projects associated with the team. */
    projects: ProjectConnection;
    /** Whether an issue needs to have a priority set before leaving triage */
    requirePriorityToLeaveTriage: Scalars["Boolean"];
    /** The workflow state into which issues are moved when a review has been requested for the PR. */
    reviewWorkflowState?: Maybe<WorkflowState>;
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments: Scalars["Boolean"];
    /** Whether to send new issue status updates to Slack. */
    slackIssueStatuses: Scalars["Boolean"];
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue: Scalars["Boolean"];
    /** The workflow state into which issues are moved when a PR has been opened. */
    startWorkflowState?: Maybe<WorkflowState>;
    /** The states that define the workflow associated with the team. */
    states: WorkflowStateConnection;
    /** Templates associated with the team. */
    templates: TemplateConnection;
    /** The timezone of the team. Defaults to "America/Los_Angeles" */
    timezone: Scalars["String"];
    /** Whether triage mode is enabled for the team or not. */
    triageEnabled: Scalars["Boolean"];
    /** The workflow state into which issues are set when they are opened by non-team members or integrations if triage is enabled. */
    triageIssueState?: Maybe<WorkflowState>;
    /** How many upcoming cycles to create. */
    upcomingCycleCount: Scalars["Float"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Webhooks associated with the team. */
    webhooks: WebhookConnection;
};
/** An organizational unit that contains issues. */
export declare type TeamCyclesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CycleFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamIssueCountArgs = {
    includeArchived?: Maybe<Scalars["Boolean"]>;
};
/** An organizational unit that contains issues. */
export declare type TeamIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamLabelsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamMembersArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamMembershipsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamProjectsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<ProjectFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamStatesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<WorkflowStateFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamTemplatesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** An organizational unit that contains issues. */
export declare type TeamWebhooksArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** Roadmap collection filtering options. */
export declare type TeamCollectionFilter = {
    /** Compound filters, all of which need to be matched by the roadmap. */
    and?: Maybe<Array<TeamCollectionFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Filters that needs to be matched by all roadmaps. */
    every?: Maybe<TeamFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Comparator for the collection length. */
    length?: Maybe<NumberComparator>;
    /** Compound filters, one of which need to be matched by the roadmap. */
    or?: Maybe<Array<TeamCollectionFilter>>;
    /** Filters that needs to be matched by some roadmaps. */
    some?: Maybe<TeamFilter>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type TeamConnection = {
    __typename?: "TeamConnection";
    edges: Array<TeamEdge>;
    nodes: Array<Team>;
    pageInfo: PageInfo;
};
export declare type TeamCreateInput = {
    /** Period after which closed and completed issues are automatically archived, in months. 0 means disabled. */
    autoArchivePeriod?: Maybe<Scalars["Float"]>;
    /** Period after which issues are automatically closed, in months. */
    autoClosePeriod?: Maybe<Scalars["Float"]>;
    /** The canceled workflow state which auto closed issues will be set to. */
    autoCloseStateId?: Maybe<Scalars["String"]>;
    /** The color of the team. */
    color?: Maybe<Scalars["String"]>;
    /** The cooldown time after each cycle in weeks. */
    cycleCooldownTime?: Maybe<Scalars["Int"]>;
    /** The duration of each cycle in weeks. */
    cycleDuration?: Maybe<Scalars["Int"]>;
    /** Auto assign completed issues to current active cycle setting. */
    cycleIssueAutoAssignCompleted?: Maybe<Scalars["Boolean"]>;
    /** Auto assign started issues to current active cycle setting. */
    cycleIssueAutoAssignStarted?: Maybe<Scalars["Boolean"]>;
    /** Only allow issues issues with cycles in Active Issues. */
    cycleLockToActive?: Maybe<Scalars["Boolean"]>;
    /** The day of the week that a new cycle starts. */
    cycleStartDay?: Maybe<Scalars["Float"]>;
    /** Whether the team uses cycles. */
    cyclesEnabled?: Maybe<Scalars["Boolean"]>;
    /** What to use as an default estimate for unestimated issues. */
    defaultIssueEstimate?: Maybe<Scalars["Float"]>;
    /** The identifier of the default template for members of this team. */
    defaultTemplateForMembersId?: Maybe<Scalars["String"]>;
    /** The identifier of the default template for non-members of this team. */
    defaultTemplateForNonMembersId?: Maybe<Scalars["String"]>;
    /** The description of the team. */
    description?: Maybe<Scalars["String"]>;
    /** Whether to group recent issue history entries. */
    groupIssueHistory?: Maybe<Scalars["Boolean"]>;
    /** The icon of the team. */
    icon?: Maybe<Scalars["String"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** Whether to allow zeros in issues estimates. */
    issueEstimationAllowZero?: Maybe<Scalars["Boolean"]>;
    /** Whether to add additional points to the estimate scale. */
    issueEstimationExtended?: Maybe<Scalars["Boolean"]>;
    /** The issue estimation type to use. Must be one of "notUsed", "exponential", "fibonacci", "linear", "tShirt". */
    issueEstimationType?: Maybe<Scalars["String"]>;
    /** Whether issues without priority should be sorted first. */
    issueOrderingNoPriorityFirst?: Maybe<Scalars["Boolean"]>;
    /** Whether to move issues to bottom of the column when changing state. */
    issueSortOrderDefaultToBottom?: Maybe<Scalars["Boolean"]>;
    /** The key of the team. If not given, the key will be generated based on the name of the team. */
    key?: Maybe<Scalars["String"]>;
    /** The workflow state into which issues are moved when they are marked as a duplicate of another issue. */
    markedAsDuplicateWorkflowStateId?: Maybe<Scalars["String"]>;
    /** The name of the team. */
    name: Scalars["String"];
    /** The organization associated with the team. */
    organizationId?: Maybe<Scalars["String"]>;
    /** Internal. Whether the team is private or not. */
    private?: Maybe<Scalars["Boolean"]>;
    /** Whether an issue needs to have a priority set before leaving triage. */
    requirePriorityToLeaveTriage?: Maybe<Scalars["Boolean"]>;
    /** The timezone of the team. */
    timezone?: Maybe<Scalars["String"]>;
    /** Whether triage mode is enabled for the team. */
    triageEnabled?: Maybe<Scalars["Boolean"]>;
    /** How many upcoming cycles to create. */
    upcomingCycleCount?: Maybe<Scalars["Float"]>;
};
export declare type TeamEdge = {
    __typename?: "TeamEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Team;
};
/** Team filtering options. */
export declare type TeamFilter = {
    /** Compound filters, all of which need to be matched by the team. */
    and?: Maybe<Array<TeamFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the team description. */
    description?: Maybe<NullableStringComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the teams issues must satisfy. */
    issues?: Maybe<IssueCollectionFilter>;
    /** Comparator for the team key. */
    key?: Maybe<StringComparator>;
    /** Comparator for the team name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the team. */
    or?: Maybe<Array<TeamFilter>>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
/** Defines the membership of a user to a team. */
export declare type TeamMembership = Node & {
    __typename?: "TeamMembership";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Whether the user is the owner of the team */
    owner?: Maybe<Scalars["Boolean"]>;
    /** The order of the item in the users team list. */
    sortOrder: Scalars["Float"];
    /** The team that the membership is associated with. */
    team: Team;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user that the membership is associated with. */
    user: User;
};
export declare type TeamMembershipConnection = {
    __typename?: "TeamMembershipConnection";
    edges: Array<TeamMembershipEdge>;
    nodes: Array<TeamMembership>;
    pageInfo: PageInfo;
};
export declare type TeamMembershipCreateInput = {
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** Internal. Whether the user is the owner of the team. */
    owner?: Maybe<Scalars["Boolean"]>;
    /** The position of the item in the users list. */
    sortOrder?: Maybe<Scalars["Float"]>;
    /** The identifier of the team associated with the membership. */
    teamId: Scalars["String"];
    /** The identifier of the user associated with the membership. */
    userId: Scalars["String"];
};
export declare type TeamMembershipEdge = {
    __typename?: "TeamMembershipEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: TeamMembership;
};
export declare type TeamMembershipPayload = {
    __typename?: "TeamMembershipPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The team membership that was created or updated. */
    teamMembership?: Maybe<TeamMembership>;
};
export declare type TeamMembershipUpdateInput = {
    /** Internal. Whether the user is the owner of the team. */
    owner?: Maybe<Scalars["Boolean"]>;
    /** The position of the item in the users list. */
    sortOrder?: Maybe<Scalars["Float"]>;
};
/** A team notification subscription. */
export declare type TeamNotificationSubscription = Entity & Node & NotificationSubscription & {
    __typename?: "TeamNotificationSubscription";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The type of view to which the notification subscription context is associated with. */
    contextViewType?: Maybe<ContextViewType>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The contextual custom view associated with the notification subscription. */
    customView?: Maybe<CustomView>;
    /** The contextual cycle view associated with the notification subscription. */
    cycle?: Maybe<Cycle>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The contextual label view associated with the notification subscription. */
    label?: Maybe<IssueLabel>;
    /** The type of subscription. */
    notificationSubscriptionTypes: Array<Scalars["String"]>;
    /** The contextual project view associated with the notification subscription. */
    project?: Maybe<Project>;
    /** The user that subscribed to receive notifications. */
    subscriber: User;
    /** The team subscribed to. */
    team: Team;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user view associated with the notification subscription. */
    user?: Maybe<User>;
    /** The type of user view to which the notification subscription context is associated with. */
    userContextViewType?: Maybe<UserContextViewType>;
};
export declare type TeamPayload = {
    __typename?: "TeamPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The team that was created or updated. */
    team?: Maybe<Team>;
};
export declare type TeamUpdateInput = {
    /** Period after which closed and completed issues are automatically archived, in months. */
    autoArchivePeriod?: Maybe<Scalars["Float"]>;
    /** Period after which issues are automatically closed, in months. */
    autoClosePeriod?: Maybe<Scalars["Float"]>;
    /** The canceled workflow state which auto closed issues will be set to. */
    autoCloseStateId?: Maybe<Scalars["String"]>;
    /** The color of the team. */
    color?: Maybe<Scalars["String"]>;
    /** The cooldown time after each cycle in weeks. */
    cycleCooldownTime?: Maybe<Scalars["Int"]>;
    /** The duration of each cycle in weeks. */
    cycleDuration?: Maybe<Scalars["Int"]>;
    /** Whether the first cycle should start in the current or the next week. */
    cycleEnabledStartWeek?: Maybe<Scalars["String"]>;
    /** Auto assign completed issues to current active cycle setting. */
    cycleIssueAutoAssignCompleted?: Maybe<Scalars["Boolean"]>;
    /** Auto assign started issues to current active cycle setting. */
    cycleIssueAutoAssignStarted?: Maybe<Scalars["Boolean"]>;
    /** Only allow issues with cycles in Active Issues. */
    cycleLockToActive?: Maybe<Scalars["Boolean"]>;
    /** The day of the week that a new cycle starts. */
    cycleStartDay?: Maybe<Scalars["Float"]>;
    /** Whether the team uses cycles. */
    cyclesEnabled?: Maybe<Scalars["Boolean"]>;
    /** What to use as an default estimate for unestimated issues. */
    defaultIssueEstimate?: Maybe<Scalars["Float"]>;
    /** Default status for newly created issues. */
    defaultIssueStateId?: Maybe<Scalars["String"]>;
    /** The identifier of the default template for members of this team. */
    defaultTemplateForMembersId?: Maybe<Scalars["String"]>;
    /** The identifier of the default template for non-members of this team. */
    defaultTemplateForNonMembersId?: Maybe<Scalars["String"]>;
    /** The description of the team. */
    description?: Maybe<Scalars["String"]>;
    /** The workflow state into which issues are moved when a draft PR has been opened. */
    draftWorkflowStateId?: Maybe<Scalars["String"]>;
    /** Whether to group recent issue history entries. */
    groupIssueHistory?: Maybe<Scalars["Boolean"]>;
    /** The icon of the team. */
    icon?: Maybe<Scalars["String"]>;
    /** Whether to allow zeros in issues estimates. */
    issueEstimationAllowZero?: Maybe<Scalars["Boolean"]>;
    /** Whether to add additional points to the estimate scale. */
    issueEstimationExtended?: Maybe<Scalars["Boolean"]>;
    /** The issue estimation type to use. Must be one of "notUsed", "exponential", "fibonacci", "linear", "tShirt". */
    issueEstimationType?: Maybe<Scalars["String"]>;
    /** Whether issues without priority should be sorted first. */
    issueOrderingNoPriorityFirst?: Maybe<Scalars["Boolean"]>;
    /** Whether to move issues to bottom of the column when changing state. */
    issueSortOrderDefaultToBottom?: Maybe<Scalars["Boolean"]>;
    /** The key of the team. */
    key?: Maybe<Scalars["String"]>;
    /** The workflow state into which issues are moved when they are marked as a duplicate of another issue. */
    markedAsDuplicateWorkflowStateId?: Maybe<Scalars["String"]>;
    /** The workflow state into which issues are moved when a PR has been merged. */
    mergeWorkflowStateId?: Maybe<Scalars["String"]>;
    /** The name of the team. */
    name?: Maybe<Scalars["String"]>;
    /** Whether the team is private or not. */
    private?: Maybe<Scalars["Boolean"]>;
    /** Whether an issue needs to have a priority set before leaving triage. */
    requirePriorityToLeaveTriage?: Maybe<Scalars["Boolean"]>;
    /** The workflow state into which issues are moved when a review has been requested for the PR. */
    reviewWorkflowStateId?: Maybe<Scalars["String"]>;
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments?: Maybe<Scalars["Boolean"]>;
    /** Whether to send issue status update notifications to Slack. */
    slackIssueStatuses?: Maybe<Scalars["Boolean"]>;
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue?: Maybe<Scalars["Boolean"]>;
    /** The workflow state into which issues are moved when a PR has been opened. */
    startWorkflowStateId?: Maybe<Scalars["String"]>;
    /** The timezone of the team. */
    timezone?: Maybe<Scalars["String"]>;
    /** Whether triage mode is enabled for the team. */
    triageEnabled?: Maybe<Scalars["Boolean"]>;
    /** How many upcoming cycles to create. */
    upcomingCycleCount?: Maybe<Scalars["Float"]>;
};
/** A template object used for creating entities faster. */
export declare type Template = Node & {
    __typename?: "Template";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the template. */
    creator?: Maybe<User>;
    /** Template description. */
    description?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The user who last updated the template. */
    lastUpdatedBy?: Maybe<User>;
    /** The name of the template. */
    name: Scalars["String"];
    /** The organization that the template is associated with. If null, the template is associated with a particular team. */
    organization?: Maybe<Organization>;
    /** The team that the template is associated with. If null, the template is global to the workspace. */
    team?: Maybe<Team>;
    /** Template data. */
    templateData: Scalars["JSON"];
    /** The entity type this template is for. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type TemplateConnection = {
    __typename?: "TemplateConnection";
    edges: Array<TemplateEdge>;
    nodes: Array<Template>;
    pageInfo: PageInfo;
};
export declare type TemplateCreateInput = {
    /** The template description. */
    description?: Maybe<Scalars["String"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The template name. */
    name: Scalars["String"];
    /** The identifier or key of the team associated with the template. If not given, the template will be shared across all teams. */
    teamId?: Maybe<Scalars["String"]>;
    /** The template data as JSON encoded attributes of the type of entity, such as an issue. */
    templateData: Scalars["JSON"];
    /** The template type, e.g. 'issue'. */
    type: Scalars["String"];
};
export declare type TemplateEdge = {
    __typename?: "TemplateEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Template;
};
export declare type TemplatePayload = {
    __typename?: "TemplatePayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The template that was created or updated. */
    template: Template;
};
export declare type TemplateUpdateInput = {
    /** The template description. */
    description?: Maybe<Scalars["String"]>;
    /** The template name. */
    name?: Maybe<Scalars["String"]>;
    /** The identifier or key of the team associated with the template. If set to null, the template will be shared across all teams. */
    teamId?: Maybe<Scalars["String"]>;
    /** The template data as JSON encoded attributes of the type of entity, such as an issue. */
    templateData?: Maybe<Scalars["JSON"]>;
};
/** Comparator for timeless dates. */
export declare type TimelessDateComparator = {
    /** Equals constraint. */
    eq?: Maybe<Scalars["TimelessDate"]>;
    /** Greater-than constraint. Matches any values that are greater than the given value. */
    gt?: Maybe<Scalars["TimelessDate"]>;
    /** Greater-than-or-equal constraint. Matches any values that are greater than or equal to the given value. */
    gte?: Maybe<Scalars["TimelessDate"]>;
    /** In-array constraint. */
    in?: Maybe<Array<Scalars["TimelessDate"]>>;
    /** Less-than constraint. Matches any values that are less than the given value. */
    lt?: Maybe<Scalars["TimelessDate"]>;
    /** Less-than-or-equal constraint. Matches any values that are less than or equal to the given value. */
    lte?: Maybe<Scalars["TimelessDate"]>;
    /** Not-equals constraint. */
    neq?: Maybe<Scalars["TimelessDate"]>;
    /** Not-in-array constraint. */
    nin?: Maybe<Array<Scalars["TimelessDate"]>>;
};
export declare type TokenUserAccountAuthInput = {
    /** The email which to login via the magic login code. */
    email: Scalars["String"];
    /** The identifiers of the teams to auto-join. */
    teamIdsToJoin?: Maybe<Array<Scalars["String"]>>;
    /** The timezone of the user's browser. */
    timezone: Scalars["String"];
    /** The magic login code. */
    token: Scalars["String"];
};
export declare type UpdateOrganizationInput = {
    /** List of services that are allowed to be used for login. */
    allowedAuthServices?: Maybe<Array<Scalars["String"]>>;
    /** How git branches are formatted. If null, default formatting will be used. */
    gitBranchFormat?: Maybe<Scalars["String"]>;
    /** Whether the Git integration linkback messages should be sent for private repositories. */
    gitLinkbackMessagesEnabled?: Maybe<Scalars["Boolean"]>;
    /** Whether the Git integration linkback messages should be sent for public repositories. */
    gitPublicLinkbackMessagesEnabled?: Maybe<Scalars["Boolean"]>;
    /** Linear Preview feature flags */
    linearPreviewFlags?: Maybe<Scalars["JSONObject"]>;
    /** The logo of the organization. */
    logoUrl?: Maybe<Scalars["String"]>;
    /** The name of the organization. */
    name?: Maybe<Scalars["String"]>;
    /** Whether the organization has opted for having to approve all OAuth applications for install. */
    oauthAppReview?: Maybe<Scalars["Boolean"]>;
    /** The day at which project updates are sent. */
    projectUpdateRemindersDay?: Maybe<Day>;
    /** The hour at which project updates are sent. */
    projectUpdateRemindersHour?: Maybe<Scalars["Float"]>;
    /** The frequency at which project updates are sent. */
    projectUpdatesReminderFrequency?: Maybe<ProjectUpdateReminderFrequency>;
    /** Whether the organization has opted for reduced customer support attachment information. */
    reducedPersonalInformation?: Maybe<Scalars["Boolean"]>;
    /** Whether the organization is using roadmap. */
    roadmapEnabled?: Maybe<Scalars["Boolean"]>;
    /** Internal. Whether SLAs have been enabled for the organization. */
    slaEnabled?: Maybe<Scalars["Boolean"]>;
    /** The URL key of the organization. */
    urlKey?: Maybe<Scalars["String"]>;
};
export declare type UpdateUserInput = {
    /** Whether the user account is active. */
    active?: Maybe<Scalars["Boolean"]>;
    /** Whether the user account has admin privileges. */
    admin?: Maybe<Scalars["Boolean"]>;
    /** The avatar image URL of the user. */
    avatarUrl?: Maybe<Scalars["String"]>;
    /** The user description or a short bio. */
    description?: Maybe<Scalars["String"]>;
    /** Reason for deactivation. */
    disableReason?: Maybe<Scalars["String"]>;
    /** The display name of the user. */
    displayName?: Maybe<Scalars["String"]>;
    /** The name of the user. */
    name?: Maybe<Scalars["String"]>;
    /** The emoji part of the user status. */
    statusEmoji?: Maybe<Scalars["String"]>;
    /** The label part of the user status. */
    statusLabel?: Maybe<Scalars["String"]>;
    /** When the user status should be cleared. */
    statusUntilAt?: Maybe<Scalars["DateTime"]>;
    /** The local timezone of the user. */
    timezone?: Maybe<Scalars["String"]>;
};
/** Object representing Google Cloud upload policy, plus additional data. */
export declare type UploadFile = {
    __typename?: "UploadFile";
    /** The asset URL for the uploaded file. (assigned automatically) */
    assetUrl: Scalars["String"];
    /** The content type. */
    contentType: Scalars["String"];
    /** The filename. */
    filename: Scalars["String"];
    headers: Array<UploadFileHeader>;
    metaData?: Maybe<Scalars["JSONObject"]>;
    /** The size of the uploaded file. */
    size: Scalars["Int"];
    /** The signed URL the for the uploaded file. (assigned automatically) */
    uploadUrl: Scalars["String"];
};
export declare type UploadFileHeader = {
    __typename?: "UploadFileHeader";
    /** Upload file header key. */
    key: Scalars["String"];
    /** Upload file header value. */
    value: Scalars["String"];
};
export declare type UploadPayload = {
    __typename?: "UploadPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** Object describing the file to be uploaded. */
    uploadFile?: Maybe<UploadFile>;
};
/** A user that has access to the the resources of an organization. */
export declare type User = Node & {
    __typename?: "User";
    /** Whether the user account is active or disabled (suspended). */
    active: Scalars["Boolean"];
    /** Whether the user is an organization administrator. */
    admin: Scalars["Boolean"];
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** Issues assigned to the user. */
    assignedIssues: IssueConnection;
    /** An URL to the user's avatar image. */
    avatarUrl?: Maybe<Scalars["String"]>;
    /** [DEPRECATED] Hash for the user to be used in calendar URLs. */
    calendarHash?: Maybe<Scalars["String"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Number of issues created. */
    createdIssueCount: Scalars["Int"];
    /** Issues created by the user. */
    createdIssues: IssueConnection;
    /** A short description of the user, either its title or bio. */
    description?: Maybe<Scalars["String"]>;
    /** Reason why is the account disabled. */
    disableReason?: Maybe<Scalars["String"]>;
    /** The user's display (nick) name. Unique within each organization. */
    displayName: Scalars["String"];
    /** The user's email address. */
    email: Scalars["String"];
    /** Whether the user is a guest in the workspace and limited to accessing a subset of teams. */
    guest: Scalars["Boolean"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Unique hash for the user to be used in invite URLs. */
    inviteHash: Scalars["String"];
    /** Whether the user is the currently authenticated user. */
    isMe: Scalars["Boolean"];
    /** The last time the user was seen online. If null, the user is currently online. */
    lastSeen?: Maybe<Scalars["DateTime"]>;
    /** The user's full name. */
    name: Scalars["String"];
    /** Organization the user belongs to. */
    organization: Organization;
    /** The emoji to represent the user current status. */
    statusEmoji?: Maybe<Scalars["String"]>;
    /** The label of the user current status. */
    statusLabel?: Maybe<Scalars["String"]>;
    /** A date at which the user current status should be cleared. */
    statusUntilAt?: Maybe<Scalars["DateTime"]>;
    /** Memberships associated with the user. For easier access of the same data, use `teams` query. */
    teamMemberships: TeamMembershipConnection;
    /** Teams the user is part of. */
    teams: TeamConnection;
    /** The local timezone of the user. */
    timezone?: Maybe<Scalars["String"]>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** User's profile URL. */
    url: Scalars["String"];
};
/** A user that has access to the the resources of an organization. */
export declare type UserAssignedIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A user that has access to the the resources of an organization. */
export declare type UserCreatedIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A user that has access to the the resources of an organization. */
export declare type UserTeamMembershipsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A user that has access to the the resources of an organization. */
export declare type UserTeamsArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A user account. */
export declare type UserAccount = {
    __typename?: "UserAccount";
    /** The time at which the model was archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the model was created. */
    createdAt: Scalars["DateTime"];
    /** The user's email address. */
    email: Scalars["String"];
    /** The models identifier. */
    id: Scalars["ID"];
    /** The user's name. */
    name?: Maybe<Scalars["String"]>;
    /** The authentication service used to create the account. */
    service: Scalars["String"];
    /** The time at which the model was updated. */
    updatedAt: Scalars["DateTime"];
    /** Users belonging to the account. */
    users: Array<User>;
};
/** [INTERNAL] An email change verification challenge. */
export declare type UserAccountEmailChange = {
    __typename?: "UserAccountEmailChange";
    /** The time at which the model was archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The timestamp this verification challenge was canceled at. */
    canceledAt?: Maybe<Scalars["DateTime"]>;
    /** The timestamp the verification codes expire at. */
    expiresAt: Scalars["DateTime"];
    /** The model's identifier. */
    id: Scalars["ID"];
    /** The new email the user account wants to change to. */
    newEmail: Scalars["String"];
    /** The timestamp the new email was verified at. */
    newEmailVerifiedAt?: Maybe<Scalars["DateTime"]>;
    /** The user account's current email. */
    oldEmail: Scalars["String"];
    /** The timestamp the old email was verified at. */
    oldEmailVerifiedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the model was updated. */
    updatedAt: Scalars["DateTime"];
};
/** [INTERNAL] Result of looking up a user account by email. */
export declare type UserAccountExistsPayload = {
    __typename?: "UserAccountExistsPayload";
    /** [INTERNAL] Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type UserAdminPayload = {
    __typename?: "UserAdminPayload";
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
/** Public information of the OAuth application, plus whether the application has been authorized for the given scopes. */
export declare type UserAuthorizedApplication = {
    __typename?: "UserAuthorizedApplication";
    /** Error associated with the application needing to be requested for approval in the workspace */
    approvalErrorCode?: Maybe<Scalars["String"]>;
    /** OAuth application's client ID. */
    clientId: Scalars["String"];
    /** Whether the application was created by Linear. */
    createdByLinear: Scalars["Boolean"];
    /** Information about the application. */
    description?: Maybe<Scalars["String"]>;
    /** Name of the developer. */
    developer: Scalars["String"];
    /** Url of the developer (homepage or docs). */
    developerUrl: Scalars["String"];
    /** OAuth application's ID. */
    id: Scalars["String"];
    /** Image of the application. */
    imageUrl?: Maybe<Scalars["String"]>;
    /** Whether the user has authorized the application for the given scopes. */
    isAuthorized: Scalars["Boolean"];
    /** Application name. */
    name: Scalars["String"];
    /** Whether or not webhooks are enabled for the application. */
    webhooksEnabled: Scalars["Boolean"];
};
/** User filtering options. */
export declare type UserCollectionFilter = {
    /** Comparator for the user's activity status. */
    active?: Maybe<BooleanComparator>;
    /** Comparator for the user's admin status. */
    admin?: Maybe<BooleanComparator>;
    /** Compound filters, all of which need to be matched by the user. */
    and?: Maybe<Array<UserCollectionFilter>>;
    /** Filters that the users assigned issues must satisfy. */
    assignedIssues?: Maybe<IssueCollectionFilter>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the user's display name. */
    displayName?: Maybe<StringComparator>;
    /** Comparator for the user's email. */
    email?: Maybe<StringComparator>;
    /** Filters that needs to be matched by all users. */
    every?: Maybe<UserFilter>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user. */
    isMe?: Maybe<BooleanComparator>;
    /** Comparator for the collection length. */
    length?: Maybe<NumberComparator>;
    /** Comparator for the user's name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the user. */
    or?: Maybe<Array<UserCollectionFilter>>;
    /** Filters that needs to be matched by some users. */
    some?: Maybe<UserFilter>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type UserConnection = {
    __typename?: "UserConnection";
    edges: Array<UserEdge>;
    nodes: Array<User>;
    pageInfo: PageInfo;
};
export declare enum UserContextViewType {
    Assigned = "assigned"
}
export declare type UserEdge = {
    __typename?: "UserEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: User;
};
/** User filtering options. */
export declare type UserFilter = {
    /** Comparator for the user's activity status. */
    active?: Maybe<BooleanComparator>;
    /** Comparator for the user's admin status. */
    admin?: Maybe<BooleanComparator>;
    /** Compound filters, all of which need to be matched by the user. */
    and?: Maybe<Array<UserFilter>>;
    /** Filters that the users assigned issues must satisfy. */
    assignedIssues?: Maybe<IssueCollectionFilter>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the user's display name. */
    displayName?: Maybe<StringComparator>;
    /** Comparator for the user's email. */
    email?: Maybe<StringComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filter based on the currently authenticated user. Set to true to filter for the authenticated user, false for any other user. */
    isMe?: Maybe<BooleanComparator>;
    /** Comparator for the user's name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the user. */
    or?: Maybe<Array<UserFilter>>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
/** The types of flags that the user can have. */
export declare enum UserFlagType {
    All = "all",
    AnalyticsWelcomeDismissed = "analyticsWelcomeDismissed",
    CanPlaySnake = "canPlaySnake",
    CanPlayTetris = "canPlayTetris",
    CompletedOnboarding = "completedOnboarding",
    CycleWelcomeDismissed = "cycleWelcomeDismissed",
    DesktopDownloadToastDismissed = "desktopDownloadToastDismissed",
    DesktopInstalled = "desktopInstalled",
    DesktopTabsOnboardingDismissed = "desktopTabsOnboardingDismissed",
    DueDateShortcutMigration = "dueDateShortcutMigration",
    EmptyActiveIssuesDismissed = "emptyActiveIssuesDismissed",
    EmptyBacklogDismissed = "emptyBacklogDismissed",
    EmptyCustomViewsDismissed = "emptyCustomViewsDismissed",
    EmptyMyIssuesDismissed = "emptyMyIssuesDismissed",
    FigmaPluginBannerDismissed = "figmaPluginBannerDismissed",
    FigmaPromptDismissed = "figmaPromptDismissed",
    ImportBannerDismissed = "importBannerDismissed",
    InsightsHelpDismissed = "insightsHelpDismissed",
    InsightsWelcomeDismissed = "insightsWelcomeDismissed",
    IssueLabelSuggestionUsed = "issueLabelSuggestionUsed",
    IssueMovePromptCompleted = "issueMovePromptCompleted",
    JoinTeamIntroductionDismissed = "joinTeamIntroductionDismissed",
    ListSelectionTip = "listSelectionTip",
    MigrateThemePreference = "migrateThemePreference",
    MilestoneOnboardingIsSeenAndDismissed = "milestoneOnboardingIsSeenAndDismissed",
    ProjectBacklogWelcomeDismissed = "projectBacklogWelcomeDismissed",
    ProjectBoardOnboardingIsSeenAndDismissed = "projectBoardOnboardingIsSeenAndDismissed",
    ProjectUpdatesWelcomeDismissed = "projectUpdatesWelcomeDismissed",
    ProjectWelcomeDismissed = "projectWelcomeDismissed",
    RewindBannerDismissed = "rewindBannerDismissed",
    SlackCommentReactionTipShown = "slackCommentReactionTipShown",
    TeamsPageIntroductionDismissed = "teamsPageIntroductionDismissed",
    ThreadedCommentsNudgeIsSeen = "threadedCommentsNudgeIsSeen",
    TriageWelcomeDismissed = "triageWelcomeDismissed",
    UpdatedSlackThreadSyncIntegration = "updatedSlackThreadSyncIntegration"
}
/** Operations that can be applied to UserFlagType */
export declare enum UserFlagUpdateOperation {
    Clear = "clear",
    Decr = "decr",
    Incr = "incr",
    Lock = "lock"
}
/** A user notification subscription. */
export declare type UserNotificationSubscription = Entity & Node & NotificationSubscription & {
    __typename?: "UserNotificationSubscription";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The type of view to which the notification subscription context is associated with. */
    contextViewType?: Maybe<ContextViewType>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The contextual custom view associated with the notification subscription. */
    customView?: Maybe<CustomView>;
    /** The contextual cycle view associated with the notification subscription. */
    cycle?: Maybe<Cycle>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The contextual label view associated with the notification subscription. */
    label?: Maybe<IssueLabel>;
    /** The type of subscription. */
    notificationSubscriptionTypes: Array<Scalars["String"]>;
    /** The contextual project view associated with the notification subscription. */
    project?: Maybe<Project>;
    /** The user that subscribed to receive notifications. */
    subscriber: User;
    /** The team associated with the notification subscription. */
    team?: Maybe<Team>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user subscribed to. */
    user: User;
    /** The type of user view to which the notification subscription context is associated with. */
    userContextViewType?: Maybe<UserContextViewType>;
};
export declare type UserPayload = {
    __typename?: "UserPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The user that was created or updated. */
    user?: Maybe<User>;
};
/** The different permission roles available to users on an organization */
export declare enum UserRoleType {
    Admin = "admin",
    Guest = "guest",
    User = "user"
}
/** The settings of a user as a JSON object. */
export declare type UserSettings = Node & {
    __typename?: "UserSettings";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** Hash for the user to be used in calendar URLs. */
    calendarHash?: Maybe<Scalars["String"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The notification channel settings the user has selected. */
    notificationPreferences: Scalars["JSONObject"];
    /** Whether to show full user names instead of display names. */
    showFullUserNames: Scalars["Boolean"];
    /** The email types the user has unsubscribed from. */
    unsubscribedFrom: Array<Scalars["String"]>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The user associated with these settings. */
    user: User;
};
export declare type UserSettingsFlagPayload = {
    __typename?: "UserSettingsFlagPayload";
    /** The flag key which was updated. */
    flag: Scalars["String"];
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The flag value after update. */
    value: Scalars["Int"];
};
export declare type UserSettingsFlagsResetPayload = {
    __typename?: "UserSettingsFlagsResetPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type UserSettingsPayload = {
    __typename?: "UserSettingsPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The user's settings. */
    userSettings: UserSettings;
};
export declare type UserSettingsUpdateInput = {
    /** The user's notification preferences. */
    notificationPreferences?: Maybe<Scalars["JSONObject"]>;
    /** The user's settings. */
    settings?: Maybe<Scalars["JSONObject"]>;
    /** The types of emails the user has unsubscribed from. */
    unsubscribedFrom?: Maybe<Array<Scalars["String"]>>;
    /** [Internal] The user's usage warning history. */
    usageWarningHistory?: Maybe<Scalars["JSONObject"]>;
};
/** View preferences. */
export declare type ViewPreferences = Node & {
    __typename?: "ViewPreferences";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The view preference type. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The view type. */
    viewType: Scalars["String"];
};
export declare type ViewPreferencesCreateInput = {
    /** The custom view these view preferences are associated with. */
    customViewId?: Maybe<Scalars["String"]>;
    /** The cycle these view preferences are associated with. */
    cycleId?: Maybe<Scalars["String"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The default parameters for the insight on that view. */
    insights?: Maybe<Scalars["JSONObject"]>;
    /** The label these view preferences are associated with. */
    labelId?: Maybe<Scalars["String"]>;
    /** View preferences object. */
    preferences: Scalars["JSONObject"];
    /** The project these view preferences are associated with. */
    projectId?: Maybe<Scalars["String"]>;
    /** The roadmap these view preferences are associated with. */
    roadmapId?: Maybe<Scalars["String"]>;
    /** The team these view preferences are associated with. */
    teamId?: Maybe<Scalars["String"]>;
    /** The type of view preferences (either user or organization level preferences). */
    type: ViewPreferencesType;
    /** The user profile these view preferences are associated with. */
    userId?: Maybe<Scalars["String"]>;
    /** The view type of the view preferences are associated with. */
    viewType: ViewType;
};
export declare type ViewPreferencesPayload = {
    __typename?: "ViewPreferencesPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The view preferences entity being mutated. */
    viewPreferences: ViewPreferences;
};
/** The type of view preferences (either user or organization level preferences). */
export declare enum ViewPreferencesType {
    Organization = "organization",
    User = "user"
}
export declare type ViewPreferencesUpdateInput = {
    /** The default parameters for the insight on that view. */
    insights?: Maybe<Scalars["JSONObject"]>;
    /** View preferences. */
    preferences?: Maybe<Scalars["JSONObject"]>;
};
/** The client view this custom view is targeting. */
export declare enum ViewType {
    ActiveIssues = "activeIssues",
    AllIssues = "allIssues",
    Archive = "archive",
    Backlog = "backlog",
    Board = "board",
    CompletedCycle = "completedCycle",
    CustomRoadmap = "customRoadmap",
    CustomView = "customView",
    CustomViews = "customViews",
    Cycle = "cycle",
    Inbox = "inbox",
    Label = "label",
    MyIssues = "myIssues",
    MyIssuesActivity = "myIssuesActivity",
    MyIssuesCreatedByMe = "myIssuesCreatedByMe",
    MyIssuesSubscribedTo = "myIssuesSubscribedTo",
    Project = "project",
    Projects = "projects",
    ProjectsAll = "projectsAll",
    ProjectsBacklog = "projectsBacklog",
    ProjectsClosed = "projectsClosed",
    QuickView = "quickView",
    Roadmap = "roadmap",
    RoadmapAll = "roadmapAll",
    RoadmapBacklog = "roadmapBacklog",
    RoadmapClosed = "roadmapClosed",
    Roadmaps = "roadmaps",
    Search = "search",
    Teams = "teams",
    Triage = "triage",
    UserProfile = "userProfile",
    UserProfileCreatedByUser = "userProfileCreatedByUser"
}
/** A webhook used to send HTTP notifications over data updates */
export declare type Webhook = Node & {
    __typename?: "Webhook";
    /** Whether the Webhook is enabled for all public teams, including teams created after the webhook was created. */
    allPublicTeams: Scalars["Boolean"];
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the webhook. */
    creator?: Maybe<User>;
    /** Whether the Webhook is enabled. */
    enabled: Scalars["Boolean"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Webhook label */
    label?: Maybe<Scalars["String"]>;
    /** The resource types this webhook is subscribed to. */
    resourceTypes: Array<Scalars["String"]>;
    /** Secret token for verifying the origin on the recipient side. */
    secret?: Maybe<Scalars["String"]>;
    /** The team that the webhook is associated with. If null, the webhook is associated with all public teams of the organization. */
    team?: Maybe<Team>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** Webhook URL */
    url?: Maybe<Scalars["String"]>;
};
export declare type WebhookConnection = {
    __typename?: "WebhookConnection";
    edges: Array<WebhookEdge>;
    nodes: Array<Webhook>;
    pageInfo: PageInfo;
};
export declare type WebhookCreateInput = {
    /** Whether this webhook is enabled for all public teams. */
    allPublicTeams?: Maybe<Scalars["Boolean"]>;
    /** Whether this webhook is enabled. */
    enabled?: Maybe<Scalars["Boolean"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** Label for the webhook. */
    label?: Maybe<Scalars["String"]>;
    /** List of resources the webhook should subscribe to. */
    resourceTypes: Array<Scalars["String"]>;
    /** A secret token used to sign the webhook payload. */
    secret?: Maybe<Scalars["String"]>;
    /** The identifier or key of the team associated with the Webhook. */
    teamId?: Maybe<Scalars["String"]>;
    /** The URL that will be called on data changes. */
    url: Scalars["String"];
};
export declare type WebhookEdge = {
    __typename?: "WebhookEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: Webhook;
};
export declare type WebhookPayload = {
    __typename?: "WebhookPayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The webhook entity being mutated. */
    webhook: Webhook;
};
export declare type WebhookUpdateInput = {
    /** Whether this webhook is enabled. */
    enabled?: Maybe<Scalars["Boolean"]>;
    /** Label for the webhook. */
    label?: Maybe<Scalars["String"]>;
    /** List of resources the webhook should subscribe to. */
    resourceTypes?: Maybe<Array<Scalars["String"]>>;
    /** A secret token used to sign the webhook payload. */
    secret?: Maybe<Scalars["String"]>;
    /** The URL that will be called on data changes. */
    url?: Maybe<Scalars["String"]>;
};
/** A condition to match for the workflow to be triggered. */
export declare type WorkflowCondition = {
    /** Trigger the workflow when an issue matches the filter. Can only be used when the trigger type is `Issue`. */
    issueFilter?: Maybe<IssueFilter>;
    /** Triggers the workflow when a project matches the filter. Can only be used when the trigger type is `Project`. */
    projectFilter?: Maybe<ProjectFilter>;
};
export declare type WorkflowCronJobDefinition = Node & {
    __typename?: "WorkflowCronJobDefinition";
    /** An array of activities that will be executed as part of the workflow cron job. */
    activities: Scalars["JSONObject"];
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the workflow cron job. */
    creator: User;
    /** The description of the workflow cron job. */
    description?: Maybe<Scalars["String"]>;
    enabled: Scalars["Boolean"];
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The name of the workflow cron job. */
    name: Scalars["String"];
    /** Cron schedule which is used to execute the workflow cron job. */
    schedule: Scalars["JSONObject"];
    /** The sort order of the workflow cron job definition within its siblings. */
    sortOrder: Scalars["String"];
    /** The team associated with the workflow cron job. */
    team: Team;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
export declare type WorkflowCronJobDefinitionConnection = {
    __typename?: "WorkflowCronJobDefinitionConnection";
    edges: Array<WorkflowCronJobDefinitionEdge>;
    nodes: Array<WorkflowCronJobDefinition>;
    pageInfo: PageInfo;
};
export declare type WorkflowCronJobDefinitionEdge = {
    __typename?: "WorkflowCronJobDefinitionEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: WorkflowCronJobDefinition;
};
export declare type WorkflowDefinition = Node & {
    __typename?: "WorkflowDefinition";
    /** An array of activities that will be executed as part of the workflow. */
    activities: Scalars["JSONObject"];
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The conditions that need to be match for the workflow to be triggered. */
    conditions: Scalars["JSONObject"];
    /** The type of view to which this workflow's context is associated with. */
    contextViewType?: Maybe<ContextViewType>;
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** The user who created the workflow. */
    creator: User;
    /** The context custom view associated with the workflow. */
    customView?: Maybe<CustomView>;
    /** The contextual cycle view associated with the workflow. */
    cycle?: Maybe<Cycle>;
    /** The description of the workflow. */
    description?: Maybe<Scalars["String"]>;
    enabled: Scalars["Boolean"];
    /** The name of the group that the workflow belongs to. */
    groupName?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** The contextual label view associated with the workflow. */
    label?: Maybe<IssueLabel>;
    /** The name of the workflow. */
    name: Scalars["String"];
    /** The contextual project view associated with the workflow. */
    project?: Maybe<Project>;
    /** The sort order of the workflow definition within its siblings. */
    sortOrder: Scalars["String"];
    /** The team associated with the workflow. If not set, the workflow is associated with the entire organization. */
    team?: Maybe<Team>;
    /** The type of the event that triggers off the workflow. */
    trigger: WorkflowTrigger;
    /** The object type (e.g. Issue) that triggers this workflow. */
    triggerType: WorkflowTriggerType;
    /** The type of the workflow. */
    type: WorkflowType;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
    /** The contextual user view associated with the workflow. */
    user?: Maybe<User>;
    /** The type of user view to which this workflow's context is associated with. */
    userContextViewType?: Maybe<UserContextViewType>;
};
export declare type WorkflowDefinitionConnection = {
    __typename?: "WorkflowDefinitionConnection";
    edges: Array<WorkflowDefinitionEdge>;
    nodes: Array<WorkflowDefinition>;
    pageInfo: PageInfo;
};
export declare type WorkflowDefinitionEdge = {
    __typename?: "WorkflowDefinitionEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: WorkflowDefinition;
};
/** A state in a team workflow. */
export declare type WorkflowState = Node & {
    __typename?: "WorkflowState";
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Maybe<Scalars["DateTime"]>;
    /** The state's UI color as a HEX string. */
    color: Scalars["String"];
    /** The time at which the entity was created. */
    createdAt: Scalars["DateTime"];
    /** Description of the state. */
    description?: Maybe<Scalars["String"]>;
    /** The unique identifier of the entity. */
    id: Scalars["ID"];
    /** Issues belonging in this state. */
    issues: IssueConnection;
    /** The state's name. */
    name: Scalars["String"];
    /** The position of the state in the team flow. */
    position: Scalars["Float"];
    /** The team to which this state belongs to. */
    team: Team;
    /** The type of the state. */
    type: Scalars["String"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Scalars["DateTime"];
};
/** A state in a team workflow. */
export declare type WorkflowStateIssuesArgs = {
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
};
/** A generic payload return from entity archive mutations. */
export declare type WorkflowStateArchivePayload = ArchivePayload & {
    __typename?: "WorkflowStateArchivePayload";
    /** The archived/unarchived entity. Null if entity was deleted. */
    entity?: Maybe<WorkflowState>;
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
};
export declare type WorkflowStateConnection = {
    __typename?: "WorkflowStateConnection";
    edges: Array<WorkflowStateEdge>;
    nodes: Array<WorkflowState>;
    pageInfo: PageInfo;
};
export declare type WorkflowStateCreateInput = {
    /** The color of the state. */
    color: Scalars["String"];
    /** The description of the state. */
    description?: Maybe<Scalars["String"]>;
    /** The identifier in UUID v4 format. If none is provided, the backend will generate one. */
    id?: Maybe<Scalars["String"]>;
    /** The name of the state. */
    name: Scalars["String"];
    /** The position of the state. */
    position?: Maybe<Scalars["Float"]>;
    /** The team associated with the state. */
    teamId: Scalars["String"];
    /** The workflow type. */
    type: Scalars["String"];
};
export declare type WorkflowStateEdge = {
    __typename?: "WorkflowStateEdge";
    /** Used in `before` and `after` args */
    cursor: Scalars["String"];
    node: WorkflowState;
};
/** Workflow state filtering options. */
export declare type WorkflowStateFilter = {
    /** Compound filters, all of which need to be matched by the workflow state. */
    and?: Maybe<Array<WorkflowStateFilter>>;
    /** Comparator for the created at date. */
    createdAt?: Maybe<DateComparator>;
    /** Comparator for the workflow state description. */
    description?: Maybe<StringComparator>;
    /** Comparator for the identifier. */
    id?: Maybe<IdComparator>;
    /** Filters that the workflow states issues must satisfy. */
    issues?: Maybe<IssueCollectionFilter>;
    /** Comparator for the workflow state name. */
    name?: Maybe<StringComparator>;
    /** Compound filters, one of which need to be matched by the workflow state. */
    or?: Maybe<Array<WorkflowStateFilter>>;
    /** Comparator for the workflow state position. */
    position?: Maybe<NumberComparator>;
    /** Filters that the workflow states team must satisfy. */
    team?: Maybe<TeamFilter>;
    /** Comparator for the workflow state type. */
    type?: Maybe<StringComparator>;
    /** Comparator for the updated at date. */
    updatedAt?: Maybe<DateComparator>;
};
export declare type WorkflowStatePayload = {
    __typename?: "WorkflowStatePayload";
    /** The identifier of the last sync operation. */
    lastSyncId: Scalars["Float"];
    /** Whether the operation was successful. */
    success: Scalars["Boolean"];
    /** The state that was created or updated. */
    workflowState: WorkflowState;
};
export declare type WorkflowStateUpdateInput = {
    /** The color of the state. */
    color?: Maybe<Scalars["String"]>;
    /** The description of the state. */
    description?: Maybe<Scalars["String"]>;
    /** The name of the state. */
    name?: Maybe<Scalars["String"]>;
    /** The position of the state. */
    position?: Maybe<Scalars["Float"]>;
};
export declare enum WorkflowTrigger {
    EntityCreated = "entityCreated",
    EntityCreatedOrUpdated = "entityCreatedOrUpdated",
    EntityRemoved = "entityRemoved",
    EntityUnarchived = "entityUnarchived",
    EntityUpdated = "entityUpdated"
}
export declare enum WorkflowTriggerType {
    Issue = "issue",
    Project = "project"
}
export declare enum WorkflowType {
    Custom = "custom",
    Sla = "sla",
    ViewSubscription = "viewSubscription"
}
/** [INTERNAL] Public information of the OAuth application, plus the userIds and scopes for those users. */
export declare type WorkspaceAuthorizedApplication = {
    __typename?: "WorkspaceAuthorizedApplication";
    /** OAuth application's ID. */
    appId: Scalars["String"];
    /** OAuth application's client ID. */
    clientId: Scalars["String"];
    /** Image of the application. */
    imageUrl?: Maybe<Scalars["String"]>;
    /** UserIds and membership dates of everyone who has authorized the application with the set of scopes */
    memberships: Array<AuthMembership>;
    /** Application name. */
    name: Scalars["String"];
    /** Scopes that are authorized for this application for a given user. */
    scope: Array<Scalars["String"]>;
    /** Total number of members that authorized the application */
    totalMembers: Scalars["Float"];
    /** Whether or not webhooks are enabled for the application. */
    webhooksEnabled: Scalars["Boolean"];
};
/** Zendesk specific settings. */
export declare type ZendeskSettings = {
    __typename?: "ZendeskSettings";
    /** Whether a ticket should be automatically reopened when its linked Linear issue is cancelled. */
    automateTicketReopeningOnCancellation?: Maybe<Scalars["Boolean"]>;
    /** Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue */
    automateTicketReopeningOnComment?: Maybe<Scalars["Boolean"]>;
    /** Whether a ticket should be automatically reopened when its linked Linear issue is completed. */
    automateTicketReopeningOnCompletion?: Maybe<Scalars["Boolean"]>;
    /** The ID of the Linear bot user. */
    botUserId?: Maybe<Scalars["String"]>;
    /** Whether an internal message should be added when someone comments on an issue. */
    sendNoteOnComment?: Maybe<Scalars["Boolean"]>;
    /** Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled). */
    sendNoteOnStatusChange?: Maybe<Scalars["Boolean"]>;
    /** The subdomain of the Zendesk organization being connected. */
    subdomain: Scalars["String"];
    /** The URL of the connected Zendesk organization. */
    url: Scalars["String"];
};
export declare type ZendeskSettingsInput = {
    /** Whether a ticket should be automatically reopened when its linked Linear issue is cancelled. */
    automateTicketReopeningOnCancellation?: Maybe<Scalars["Boolean"]>;
    /** Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue */
    automateTicketReopeningOnComment?: Maybe<Scalars["Boolean"]>;
    /** Whether a ticket should be automatically reopened when its linked Linear issue is completed. */
    automateTicketReopeningOnCompletion?: Maybe<Scalars["Boolean"]>;
    /** The ID of the Linear bot user. */
    botUserId?: Maybe<Scalars["String"]>;
    /** Whether an internal message should be added when someone comments on an issue. */
    sendNoteOnComment?: Maybe<Scalars["Boolean"]>;
    /** Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled). */
    sendNoteOnStatusChange?: Maybe<Scalars["Boolean"]>;
    /** The subdomain of the Zendesk organization being connected. */
    subdomain: Scalars["String"];
    /** The URL of the connected Zendesk organization. */
    url: Scalars["String"];
};
declare type Entity_CustomViewNotificationSubscription_Fragment = {
    __typename: "CustomViewNotificationSubscription";
} & Pick<CustomViewNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "id">;
declare type Entity_CycleNotificationSubscription_Fragment = {
    __typename: "CycleNotificationSubscription";
} & Pick<CycleNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "id">;
declare type Entity_IssueNotification_Fragment = {
    __typename: "IssueNotification";
} & Pick<IssueNotification, "updatedAt" | "archivedAt" | "createdAt" | "id">;
declare type Entity_LabelNotificationSubscription_Fragment = {
    __typename: "LabelNotificationSubscription";
} & Pick<LabelNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "id">;
declare type Entity_OauthClientApprovalNotification_Fragment = {
    __typename: "OauthClientApprovalNotification";
} & Pick<OauthClientApprovalNotification, "updatedAt" | "archivedAt" | "createdAt" | "id">;
declare type Entity_ProjectNotification_Fragment = {
    __typename: "ProjectNotification";
} & Pick<ProjectNotification, "updatedAt" | "archivedAt" | "createdAt" | "id">;
declare type Entity_ProjectNotificationSubscription_Fragment = {
    __typename: "ProjectNotificationSubscription";
} & Pick<ProjectNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "id">;
declare type Entity_TeamNotificationSubscription_Fragment = {
    __typename: "TeamNotificationSubscription";
} & Pick<TeamNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "id">;
declare type Entity_UserNotificationSubscription_Fragment = {
    __typename: "UserNotificationSubscription";
} & Pick<UserNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "id">;
export declare type EntityFragment = Entity_CustomViewNotificationSubscription_Fragment | Entity_CycleNotificationSubscription_Fragment | Entity_IssueNotification_Fragment | Entity_LabelNotificationSubscription_Fragment | Entity_OauthClientApprovalNotification_Fragment | Entity_ProjectNotification_Fragment | Entity_ProjectNotificationSubscription_Fragment | Entity_TeamNotificationSubscription_Fragment | Entity_UserNotificationSubscription_Fragment;
export declare type CommentFragment = {
    __typename: "Comment";
} & Pick<Comment, "url" | "reactionData" | "bodyData" | "body" | "updatedAt" | "archivedAt" | "createdAt" | "editedAt" | "id"> & {
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
    parent?: Maybe<{
        __typename?: "Comment";
    } & Pick<Comment, "id">>;
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type CompanyFragment = {
    __typename: "Company";
} & Pick<Company, "externalId" | "logoUrl" | "name" | "websiteUrl" | "companyProperties" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type EmojiFragment = {
    __typename: "Emoji";
} & Pick<Emoji, "url" | "name" | "updatedAt" | "source" | "archivedAt" | "createdAt" | "id"> & {
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type CustomViewNotificationSubscriptionFragment = {
    __typename: "CustomViewNotificationSubscription";
} & Pick<CustomViewNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "notificationSubscriptionTypes" | "id"> & {
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    label?: Maybe<{
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    customView: {
        __typename?: "CustomView";
    } & Pick<CustomView, "id">;
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    subscriber: {
        __typename?: "User";
    } & Pick<User, "id">;
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type CustomViewFragment = {
    __typename: "CustomView";
} & Pick<CustomView, "color" | "description" | "filterData" | "filters" | "icon" | "updatedAt" | "name" | "archivedAt" | "createdAt" | "id" | "shared"> & {
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type CycleNotificationSubscriptionFragment = {
    __typename: "CycleNotificationSubscription";
} & Pick<CycleNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "notificationSubscriptionTypes" | "id"> & {
    customView?: Maybe<{
        __typename?: "CustomView";
    } & Pick<CustomView, "id">>;
    label?: Maybe<{
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    cycle: {
        __typename?: "Cycle";
    } & Pick<Cycle, "id">;
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    subscriber: {
        __typename?: "User";
    } & Pick<User, "id">;
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type DocumentContentFragment = {
    __typename: "DocumentContent";
} & Pick<DocumentContent, "contentData" | "content" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    issue?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
};
export declare type DocumentFragment = {
    __typename: "Document";
} & Pick<Document, "color" | "contentData" | "content" | "title" | "slugId" | "icon" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    project: {
        __typename?: "Project";
    } & Pick<Project, "id">;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
    updatedBy: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type AttachmentArchivePayloadFragment = {
    __typename: "AttachmentArchivePayload";
} & Pick<AttachmentArchivePayload, "lastSyncId" | "success"> & {
    entity?: Maybe<{
        __typename?: "Attachment";
    } & Pick<Attachment, "id">>;
};
export declare type CycleArchivePayloadFragment = {
    __typename: "CycleArchivePayload";
} & Pick<CycleArchivePayload, "lastSyncId" | "success"> & {
    entity?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
};
export declare type IssueArchivePayloadFragment = {
    __typename: "IssueArchivePayload";
} & Pick<IssueArchivePayload, "lastSyncId" | "success"> & {
    entity?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
};
export declare type NotificationArchivePayloadFragment = {
    __typename: "NotificationArchivePayload";
} & Pick<NotificationArchivePayload, "lastSyncId" | "success"> & {
    entity?: Maybe<({
        __typename?: "IssueNotification";
    } & Notification_IssueNotification_Fragment) | ({
        __typename?: "OauthClientApprovalNotification";
    } & Notification_OauthClientApprovalNotification_Fragment) | ({
        __typename?: "ProjectNotification";
    } & Notification_ProjectNotification_Fragment)>;
};
export declare type ProjectArchivePayloadFragment = {
    __typename: "ProjectArchivePayload";
} & Pick<ProjectArchivePayload, "lastSyncId" | "success"> & {
    entity?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
};
export declare type RoadmapArchivePayloadFragment = {
    __typename: "RoadmapArchivePayload";
} & Pick<RoadmapArchivePayload, "lastSyncId" | "success"> & {
    entity?: Maybe<{
        __typename?: "Roadmap";
    } & Pick<Roadmap, "id">>;
};
export declare type WorkflowStateArchivePayloadFragment = {
    __typename: "WorkflowStateArchivePayload";
} & Pick<WorkflowStateArchivePayload, "lastSyncId" | "success"> & {
    entity?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
};
declare type ArchivePayload_AttachmentArchivePayload_Fragment = {
    __typename: "AttachmentArchivePayload";
} & Pick<AttachmentArchivePayload, "lastSyncId" | "success"> & AttachmentArchivePayloadFragment;
declare type ArchivePayload_CycleArchivePayload_Fragment = {
    __typename: "CycleArchivePayload";
} & Pick<CycleArchivePayload, "lastSyncId" | "success"> & CycleArchivePayloadFragment;
declare type ArchivePayload_DeletePayload_Fragment = {
    __typename: "DeletePayload";
} & Pick<DeletePayload, "lastSyncId" | "success"> & DeletePayloadFragment;
declare type ArchivePayload_IssueArchivePayload_Fragment = {
    __typename: "IssueArchivePayload";
} & Pick<IssueArchivePayload, "lastSyncId" | "success"> & IssueArchivePayloadFragment;
declare type ArchivePayload_NotificationArchivePayload_Fragment = {
    __typename: "NotificationArchivePayload";
} & Pick<NotificationArchivePayload, "lastSyncId" | "success"> & NotificationArchivePayloadFragment;
declare type ArchivePayload_ProjectArchivePayload_Fragment = {
    __typename: "ProjectArchivePayload";
} & Pick<ProjectArchivePayload, "lastSyncId" | "success"> & ProjectArchivePayloadFragment;
declare type ArchivePayload_RoadmapArchivePayload_Fragment = {
    __typename: "RoadmapArchivePayload";
} & Pick<RoadmapArchivePayload, "lastSyncId" | "success"> & RoadmapArchivePayloadFragment;
declare type ArchivePayload_WorkflowStateArchivePayload_Fragment = {
    __typename: "WorkflowStateArchivePayload";
} & Pick<WorkflowStateArchivePayload, "lastSyncId" | "success"> & WorkflowStateArchivePayloadFragment;
export declare type ArchivePayloadFragment = ArchivePayload_AttachmentArchivePayload_Fragment | ArchivePayload_CycleArchivePayload_Fragment | ArchivePayload_DeletePayload_Fragment | ArchivePayload_IssueArchivePayload_Fragment | ArchivePayload_NotificationArchivePayload_Fragment | ArchivePayload_ProjectArchivePayload_Fragment | ArchivePayload_RoadmapArchivePayload_Fragment | ArchivePayload_WorkflowStateArchivePayload_Fragment;
export declare type DeletePayloadFragment = {
    __typename: "DeletePayload";
} & Pick<DeletePayload, "entityId" | "lastSyncId" | "success">;
export declare type LabelNotificationSubscriptionFragment = {
    __typename: "LabelNotificationSubscription";
} & Pick<LabelNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "notificationSubscriptionTypes" | "id"> & {
    customView?: Maybe<{
        __typename?: "CustomView";
    } & Pick<CustomView, "id">>;
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    label: {
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">;
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    subscriber: {
        __typename?: "User";
    } & Pick<User, "id">;
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type ProjectMilestoneFragment = {
    __typename: "ProjectMilestone";
} & Pick<ProjectMilestone, "description" | "updatedAt" | "name" | "sortOrder" | "targetDate" | "archivedAt" | "createdAt" | "id"> & {
    project: {
        __typename?: "Project";
    } & Pick<Project, "id">;
};
declare type Notification_IssueNotification_Fragment = {
    __typename: "IssueNotification";
} & Pick<IssueNotification, "type" | "updatedAt" | "emailedAt" | "readAt" | "unsnoozedAt" | "archivedAt" | "createdAt" | "snoozedUntilAt" | "id"> & {
    actor?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
} & IssueNotificationFragment;
declare type Notification_OauthClientApprovalNotification_Fragment = {
    __typename: "OauthClientApprovalNotification";
} & Pick<OauthClientApprovalNotification, "type" | "updatedAt" | "emailedAt" | "readAt" | "unsnoozedAt" | "archivedAt" | "createdAt" | "snoozedUntilAt" | "id"> & {
    actor?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
} & OauthClientApprovalNotificationFragment;
declare type Notification_ProjectNotification_Fragment = {
    __typename: "ProjectNotification";
} & Pick<ProjectNotification, "type" | "updatedAt" | "emailedAt" | "readAt" | "unsnoozedAt" | "archivedAt" | "createdAt" | "snoozedUntilAt" | "id"> & {
    actor?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
} & ProjectNotificationFragment;
export declare type NotificationFragment = Notification_IssueNotification_Fragment | Notification_OauthClientApprovalNotification_Fragment | Notification_ProjectNotification_Fragment;
export declare type ProjectNotificationSubscriptionFragment = {
    __typename: "ProjectNotificationSubscription";
} & Pick<ProjectNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "notificationSubscriptionTypes" | "id"> & {
    customView?: Maybe<{
        __typename?: "CustomView";
    } & Pick<CustomView, "id">>;
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    label?: Maybe<{
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">>;
    project: {
        __typename?: "Project";
    } & Pick<Project, "id">;
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    subscriber: {
        __typename?: "User";
    } & Pick<User, "id">;
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type ProjectNotificationFragment = {
    __typename: "ProjectNotification";
} & Pick<ProjectNotification, "type" | "updatedAt" | "emailedAt" | "readAt" | "unsnoozedAt" | "archivedAt" | "createdAt" | "snoozedUntilAt" | "id"> & {
    project: {
        __typename?: "Project";
    } & Pick<Project, "id">;
    projectUpdate?: Maybe<{
        __typename?: "ProjectUpdate";
    } & Pick<ProjectUpdate, "id">>;
    actor?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type ProjectFragment = {
    __typename: "Project";
} & Pick<Project, "url" | "targetDate" | "startDate" | "icon" | "updatedAt" | "completedScopeHistory" | "completedIssueCountHistory" | "inProgressScopeHistory" | "progress" | "scope" | "color" | "description" | "name" | "slugId" | "sortOrder" | "archivedAt" | "createdAt" | "autoArchivedAt" | "canceledAt" | "completedAt" | "startedAt" | "projectUpdateRemindersPausedUntilAt" | "scopeHistory" | "issueCountHistory" | "state" | "id" | "slackIssueComments" | "slackNewIssue" | "slackIssueStatuses"> & {
    integrationsSettings?: Maybe<{
        __typename?: "IntegrationsSettings";
    } & Pick<IntegrationsSettings, "id">>;
    lead?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    convertedFromIssue?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type ReactionFragment = {
    __typename: "Reaction";
} & Pick<Reaction, "emoji" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type IssueHistoryFragment = {
    __typename: "IssueHistory";
} & Pick<IssueHistory, "addedLabelIds" | "removedLabelIds" | "attachmentId" | "toCycleId" | "toParentId" | "toConvertedProjectId" | "toProjectId" | "toStateId" | "fromCycleId" | "fromParentId" | "fromProjectId" | "fromStateId" | "fromTeamId" | "toTeamId" | "fromAssigneeId" | "toAssigneeId" | "actorId" | "updatedAt" | "archivedAt" | "createdAt" | "id" | "fromDueDate" | "toDueDate" | "fromEstimate" | "toEstimate" | "fromPriority" | "toPriority" | "fromTitle" | "toTitle" | "archived" | "autoArchived" | "autoClosed" | "trashed" | "updatedDescription"> & {
    relationChanges?: Maybe<Array<{
        __typename?: "IssueRelationHistoryPayload";
    } & IssueRelationHistoryPayloadFragment>>;
    issueImport?: Maybe<{
        __typename?: "IssueImport";
    } & IssueImportFragment>;
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
    attachment?: Maybe<{
        __typename?: "Attachment";
    } & Pick<Attachment, "id">>;
    toCycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    toParent?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
    toConvertedProject?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    toProject?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    toState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    fromCycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    fromParent?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
    fromProject?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    fromState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    fromTeam?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    toTeam?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    fromAssignee?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    toAssignee?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    actor?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type IssueRelationFragment = {
    __typename: "IssueRelation";
} & Pick<IssueRelation, "updatedAt" | "type" | "archivedAt" | "createdAt" | "id"> & {
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
    relatedIssue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
};
export declare type RoadmapFragment = {
    __typename: "Roadmap";
} & Pick<Roadmap, "description" | "updatedAt" | "name" | "color" | "slugId" | "sortOrder" | "archivedAt" | "createdAt" | "id"> & {
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
    owner: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type FirstResponderScheduleFragment = {
    __typename: "FirstResponderSchedule";
} & Pick<FirstResponderSchedule, "scheduleData" | "integrationScheduleId" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    integration: {
        __typename?: "Integration";
    } & Pick<Integration, "id">;
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
};
export declare type CycleFragment = {
    __typename: "Cycle";
} & Pick<Cycle, "completedAt" | "name" | "description" | "endsAt" | "updatedAt" | "completedScopeHistory" | "completedIssueCountHistory" | "inProgressScopeHistory" | "number" | "progress" | "startsAt" | "autoArchivedAt" | "archivedAt" | "createdAt" | "scopeHistory" | "issueCountHistory" | "id"> & {
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
};
export declare type WorkflowStateFragment = {
    __typename: "WorkflowState";
} & Pick<WorkflowState, "description" | "updatedAt" | "position" | "color" | "name" | "archivedAt" | "createdAt" | "type" | "id"> & {
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
};
export declare type TeamNotificationSubscriptionFragment = {
    __typename: "TeamNotificationSubscription";
} & Pick<TeamNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "notificationSubscriptionTypes" | "id"> & {
    customView?: Maybe<{
        __typename?: "CustomView";
    } & Pick<CustomView, "id">>;
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    label?: Maybe<{
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
    subscriber: {
        __typename?: "User";
    } & Pick<User, "id">;
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type TemplateFragment = {
    __typename: "Template";
} & Pick<Template, "templateData" | "description" | "type" | "updatedAt" | "name" | "archivedAt" | "createdAt" | "id"> & {
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    lastUpdatedBy?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type ProjectUpdateFragment = {
    __typename: "ProjectUpdate";
} & Pick<ProjectUpdate, "url" | "updatedAt" | "archivedAt" | "createdAt" | "editedAt" | "id" | "body"> & {
    project: {
        __typename?: "Project";
    } & Pick<Project, "id">;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type UserAccountFragment = {
    __typename: "UserAccount";
} & Pick<UserAccount, "service" | "id" | "archivedAt" | "createdAt" | "updatedAt" | "email" | "name"> & {
    users: Array<{
        __typename?: "User";
    } & UserFragment>;
};
export declare type UserNotificationSubscriptionFragment = {
    __typename: "UserNotificationSubscription";
} & Pick<UserNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "notificationSubscriptionTypes" | "id"> & {
    customView?: Maybe<{
        __typename?: "CustomView";
    } & Pick<CustomView, "id">>;
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    label?: Maybe<{
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
    subscriber: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type UserFragment = {
    __typename: "User";
} & Pick<User, "statusUntilAt" | "description" | "avatarUrl" | "createdIssueCount" | "disableReason" | "statusEmoji" | "statusLabel" | "updatedAt" | "lastSeen" | "timezone" | "archivedAt" | "createdAt" | "id" | "displayName" | "email" | "name" | "inviteHash" | "url" | "active" | "guest" | "admin" | "isMe" | "calendarHash">;
export declare type PushSubscriptionFragment = {
    __typename: "PushSubscription";
} & Pick<PushSubscription, "updatedAt" | "archivedAt" | "createdAt" | "id">;
export declare type WebhookFragment = {
    __typename: "Webhook";
} & Pick<Webhook, "secret" | "updatedAt" | "resourceTypes" | "archivedAt" | "createdAt" | "id" | "url" | "label" | "allPublicTeams" | "enabled"> & {
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type ApiKeyFragment = {
    __typename: "ApiKey";
} & Pick<ApiKey, "label" | "updatedAt" | "archivedAt" | "createdAt" | "id">;
export declare type ProjectLinkFragment = {
    __typename: "ProjectLink";
} & Pick<ProjectLink, "updatedAt" | "url" | "label" | "archivedAt" | "createdAt" | "id"> & {
    project: {
        __typename?: "Project";
    } & Pick<Project, "id">;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type IssueImportFragment = {
    __typename: "IssueImport";
} & Pick<IssueImport, "progress" | "errorMetadata" | "csvFileUrl" | "teamName" | "mapping" | "creatorId" | "updatedAt" | "service" | "status" | "archivedAt" | "createdAt" | "id" | "error">;
export declare type IntegrationFragment = {
    __typename: "Integration";
} & Pick<Integration, "service" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type OrganizationInviteFragment = {
    __typename: "OrganizationInvite";
} & Pick<OrganizationInvite, "external" | "email" | "updatedAt" | "archivedAt" | "createdAt" | "acceptedAt" | "expiresAt" | "id"> & {
    inviter: {
        __typename?: "User";
    } & Pick<User, "id">;
    invitee?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type IssueNotificationFragment = {
    __typename: "IssueNotification";
} & Pick<IssueNotification, "reactionEmoji" | "type" | "updatedAt" | "emailedAt" | "readAt" | "unsnoozedAt" | "archivedAt" | "createdAt" | "snoozedUntilAt" | "id"> & {
    comment?: Maybe<{
        __typename?: "Comment";
    } & Pick<Comment, "id">>;
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
    actor?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type IssueFragment = {
    __typename: "Issue";
} & Pick<Issue, "trashed" | "url" | "identifier" | "priorityLabel" | "previousIdentifiers" | "customerTicketCount" | "branchName" | "dueDate" | "estimate" | "description" | "title" | "number" | "updatedAt" | "boardOrder" | "sortOrder" | "subIssueSortOrder" | "priority" | "archivedAt" | "createdAt" | "startedTriageAt" | "triagedAt" | "autoArchivedAt" | "autoClosedAt" | "canceledAt" | "completedAt" | "startedAt" | "snoozedUntilAt" | "id"> & {
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    parent?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    projectMilestone?: Maybe<{
        __typename?: "ProjectMilestone";
    } & Pick<ProjectMilestone, "id">>;
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
    assignee?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    snoozedBy?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    favorite?: Maybe<{
        __typename?: "Favorite";
    } & Pick<Favorite, "id">>;
    state: {
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">;
};
export declare type OauthClientApprovalNotificationFragment = {
    __typename: "OauthClientApprovalNotification";
} & Pick<OauthClientApprovalNotification, "type" | "updatedAt" | "emailedAt" | "readAt" | "unsnoozedAt" | "archivedAt" | "createdAt" | "snoozedUntilAt" | "id"> & {
    oauthClientApproval: {
        __typename?: "OauthClientApproval";
    } & OauthClientApprovalFragment;
    actor?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type OrganizationFragment = {
    __typename: "Organization";
} & Pick<Organization, "allowedAuthServices" | "gitBranchFormat" | "userCount" | "createdIssueCount" | "previousUrlKeys" | "periodUploadVolume" | "projectUpdateRemindersHour" | "updatedAt" | "logoUrl" | "name" | "urlKey" | "deletionRequestedAt" | "archivedAt" | "createdAt" | "trialEndsAt" | "id" | "samlEnabled" | "scimEnabled" | "gitLinkbackMessagesEnabled" | "gitPublicLinkbackMessagesEnabled" | "roadmapEnabled"> & {
    subscription?: Maybe<{
        __typename?: "PaidSubscription";
    } & PaidSubscriptionFragment>;
};
export declare type TeamFragment = {
    __typename: "Team";
} & Pick<Team, "cycleIssueAutoAssignCompleted" | "cycleIssueAutoAssignStarted" | "cycleCalenderUrl" | "upcomingCycleCount" | "issueCount" | "cycleLockToActive" | "autoArchivePeriod" | "autoClosePeriod" | "autoCloseStateId" | "cycleCooldownTime" | "cycleStartDay" | "cycleDuration" | "icon" | "defaultTemplateForMembersId" | "defaultTemplateForNonMembersId" | "issueEstimationType" | "updatedAt" | "color" | "description" | "name" | "key" | "archivedAt" | "createdAt" | "timezone" | "id" | "inviteHash" | "defaultIssueEstimate" | "requirePriorityToLeaveTriage" | "issueOrderingNoPriorityFirst" | "private" | "cyclesEnabled" | "issueEstimationExtended" | "issueEstimationAllowZero" | "groupIssueHistory" | "issueSortOrderDefaultToBottom" | "slackIssueComments" | "slackNewIssue" | "slackIssueStatuses" | "triageEnabled"> & {
    integrationsSettings?: Maybe<{
        __typename?: "IntegrationsSettings";
    } & Pick<IntegrationsSettings, "id">>;
    activeCycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    defaultTemplateForMembers?: Maybe<{
        __typename?: "Template";
    } & Pick<Template, "id">>;
    defaultTemplateForNonMembers?: Maybe<{
        __typename?: "Template";
    } & Pick<Template, "id">>;
    defaultIssueState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    mergeWorkflowState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    draftWorkflowState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    startWorkflowState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    reviewWorkflowState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    markedAsDuplicateWorkflowState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
    triageIssueState?: Maybe<{
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">>;
};
export declare type SyncResponseFragment = {
    __typename: "SyncResponse";
} & Pick<SyncResponse, "delta" | "state" | "lastSyncId" | "subscribedSyncGroups" | "databaseVersion">;
export declare type ArchiveResponseFragment = {
    __typename: "ArchiveResponse";
} & Pick<ArchiveResponse, "archive" | "totalCount" | "databaseVersion" | "includesDependencies">;
export declare type TeamMembershipFragment = {
    __typename: "TeamMembership";
} & Pick<TeamMembership, "updatedAt" | "sortOrder" | "archivedAt" | "createdAt" | "id" | "owner"> & {
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type OrganizationDomainFragment = {
    __typename: "OrganizationDomain";
} & Pick<OrganizationDomain, "name" | "verificationEmail" | "verified" | "updatedAt" | "archivedAt" | "createdAt" | "id" | "claimed"> & {
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type FrontSettingsFragment = {
    __typename: "FrontSettings";
} & Pick<FrontSettings, "automateTicketReopeningOnComment" | "automateTicketReopeningOnCancellation" | "automateTicketReopeningOnCompletion" | "sendNoteOnStatusChange" | "sendNoteOnComment">;
export declare type GithubOAuthTokenPayloadFragment = {
    __typename: "GithubOAuthTokenPayload";
} & Pick<GithubOAuthTokenPayload, "token"> & {
    organizations?: Maybe<Array<{
        __typename?: "GithubOrg";
    } & GithubOrgFragment>>;
};
export declare type GoogleSheetsSettingsFragment = {
    __typename: "GoogleSheetsSettings";
} & Pick<GoogleSheetsSettings, "sheetId" | "spreadsheetId" | "spreadsheetUrl" | "updatedIssuesAt">;
export declare type ProjectUpdateInteractionFragment = {
    __typename: "ProjectUpdateInteraction";
} & Pick<ProjectUpdateInteraction, "updatedAt" | "archivedAt" | "createdAt" | "readAt" | "id"> & {
    projectUpdate: {
        __typename?: "ProjectUpdate";
    } & Pick<ProjectUpdate, "id">;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type EmbedFragment = {
    __typename: "Embed";
} & Pick<Embed, "html" | "thumbnailUrl" | "url" | "description" | "height" | "thumbnailHeight" | "authorName" | "providerName" | "type" | "width" | "thumbnailWidth" | "title">;
export declare type IntercomSettingsFragment = {
    __typename: "IntercomSettings";
} & Pick<IntercomSettings, "automateTicketReopeningOnComment" | "automateTicketReopeningOnCancellation" | "automateTicketReopeningOnCompletion" | "sendNoteOnStatusChange" | "sendNoteOnComment">;
export declare type AttachmentFragment = {
    __typename: "Attachment";
} & Pick<Attachment, "sourceType" | "subtitle" | "title" | "metadata" | "groupBySource" | "source" | "url" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    issue: {
        __typename?: "Issue";
    } & Pick<Issue, "id">;
};
export declare type IssueRelationHistoryPayloadFragment = {
    __typename: "IssueRelationHistoryPayload";
} & Pick<IssueRelationHistoryPayload, "identifier" | "type">;
export declare type JiraSettingsFragment = {
    __typename: "JiraSettings";
} & {
    projects: Array<{
        __typename?: "JiraProjectData";
    } & JiraProjectDataFragment>;
    projectMapping?: Maybe<Array<{
        __typename?: "JiraLinearMapping";
    } & JiraLinearMappingFragment>>;
};
export declare type RoadmapToProjectFragment = {
    __typename: "RoadmapToProject";
} & Pick<RoadmapToProject, "updatedAt" | "sortOrder" | "archivedAt" | "createdAt" | "id"> & {
    project: {
        __typename?: "Project";
    } & Pick<Project, "id">;
    roadmap: {
        __typename?: "Roadmap";
    } & Pick<Roadmap, "id">;
};
export declare type IntegrationTemplateFragment = {
    __typename: "IntegrationTemplate";
} & Pick<IntegrationTemplate, "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    integration: {
        __typename?: "Integration";
    } & Pick<Integration, "id">;
    template: {
        __typename?: "Template";
    } & Pick<Template, "id">;
};
export declare type IssueLabelFragment = {
    __typename: "IssueLabel";
} & Pick<IssueLabel, "color" | "description" | "name" | "updatedAt" | "archivedAt" | "createdAt" | "id" | "isGroup"> & {
    parent?: Maybe<{
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">>;
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type JiraProjectDataFragment = {
    __typename: "JiraProjectData";
} & Pick<JiraProjectData, "id" | "key" | "name">;
export declare type GitHubSettingsFragment = {
    __typename: "GitHubSettings";
} & Pick<GitHubSettings, "orgLogin" | "orgAvatarUrl">;
declare type NotificationSubscription_CustomViewNotificationSubscription_Fragment = {
    __typename: "CustomViewNotificationSubscription";
} & Pick<CustomViewNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    customView: {
        __typename?: "CustomView";
    } & Pick<CustomView, "id">;
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    label?: Maybe<{
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    subscriber: {
        __typename?: "User";
    } & Pick<User, "id">;
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
declare type NotificationSubscription_CycleNotificationSubscription_Fragment = {
    __typename: "CycleNotificationSubscription";
} & Pick<CycleNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    customView?: Maybe<{
        __typename?: "CustomView";
    } & Pick<CustomView, "id">>;
    cycle: {
        __typename?: "Cycle";
    } & Pick<Cycle, "id">;
    label?: Maybe<{
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    subscriber: {
        __typename?: "User";
    } & Pick<User, "id">;
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
declare type NotificationSubscription_LabelNotificationSubscription_Fragment = {
    __typename: "LabelNotificationSubscription";
} & Pick<LabelNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    customView?: Maybe<{
        __typename?: "CustomView";
    } & Pick<CustomView, "id">>;
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    label: {
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    subscriber: {
        __typename?: "User";
    } & Pick<User, "id">;
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
declare type NotificationSubscription_ProjectNotificationSubscription_Fragment = {
    __typename: "ProjectNotificationSubscription";
} & Pick<ProjectNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    customView?: Maybe<{
        __typename?: "CustomView";
    } & Pick<CustomView, "id">>;
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    label?: Maybe<{
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">>;
    project: {
        __typename?: "Project";
    } & Pick<Project, "id">;
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    subscriber: {
        __typename?: "User";
    } & Pick<User, "id">;
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
declare type NotificationSubscription_TeamNotificationSubscription_Fragment = {
    __typename: "TeamNotificationSubscription";
} & Pick<TeamNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    customView?: Maybe<{
        __typename?: "CustomView";
    } & Pick<CustomView, "id">>;
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    label?: Maybe<{
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
    subscriber: {
        __typename?: "User";
    } & Pick<User, "id">;
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
declare type NotificationSubscription_UserNotificationSubscription_Fragment = {
    __typename: "UserNotificationSubscription";
} & Pick<UserNotificationSubscription, "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    customView?: Maybe<{
        __typename?: "CustomView";
    } & Pick<CustomView, "id">>;
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    label?: Maybe<{
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    subscriber: {
        __typename?: "User";
    } & Pick<User, "id">;
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type NotificationSubscriptionFragment = NotificationSubscription_CustomViewNotificationSubscription_Fragment | NotificationSubscription_CycleNotificationSubscription_Fragment | NotificationSubscription_LabelNotificationSubscription_Fragment | NotificationSubscription_ProjectNotificationSubscription_Fragment | NotificationSubscription_TeamNotificationSubscription_Fragment | NotificationSubscription_UserNotificationSubscription_Fragment;
export declare type NotionSettingsFragment = {
    __typename: "NotionSettings";
} & Pick<NotionSettings, "workspaceId" | "workspaceName">;
export declare type OauthClientFragment = {
    __typename: "OauthClient";
} & Pick<OauthClient, "imageUrl" | "description" | "redirectUris" | "developer" | "clientId" | "name" | "clientSecret" | "updatedAt" | "webhookResourceTypes" | "archivedAt" | "createdAt" | "id" | "developerUrl" | "webhookUrl" | "webhookSecret" | "publicEnabled"> & {
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type FigmaEmbedFragment = {
    __typename: "FigmaEmbed";
} & Pick<FigmaEmbed, "lastModified" | "name" | "url" | "nodeName">;
export declare type UploadFileFragment = {
    __typename: "UploadFile";
} & Pick<UploadFile, "assetUrl" | "contentType" | "filename" | "uploadUrl" | "size" | "metaData"> & {
    headers: Array<{
        __typename?: "UploadFileHeader";
    } & UploadFileHeaderFragment>;
};
export declare type PagerDutySettingsFragment = {
    __typename: "PagerDutySettings";
} & {
    scheduleMapping: Array<{
        __typename?: "PagerDutyScheduleMapping";
    } & PagerDutyScheduleMappingFragment>;
};
export declare type UserAuthorizedApplicationFragment = {
    __typename: "UserAuthorizedApplication";
} & Pick<UserAuthorizedApplication, "name" | "approvalErrorCode" | "imageUrl" | "description" | "developer" | "id" | "clientId" | "developerUrl" | "webhooksEnabled" | "createdByLinear" | "isAuthorized">;
export declare type ApplicationFragment = {
    __typename: "Application";
} & Pick<Application, "name" | "imageUrl" | "description" | "developer" | "id" | "clientId" | "developerUrl">;
export declare type GithubOrgFragment = {
    __typename: "GithubOrg";
} & Pick<GithubOrg, "id" | "login" | "name" | "isPersonal"> & {
    repositories: Array<{
        __typename?: "GithubRepo";
    } & GithubRepoFragment>;
};
export declare type GithubRepoFragment = {
    __typename: "GithubRepo";
} & Pick<GithubRepo, "id" | "name">;
export declare type OauthClientApprovalFragment = {
    __typename: "OauthClientApproval";
} & Pick<OauthClientApproval, "updatedAt" | "requesterId" | "responderId" | "requestReason" | "denyReason" | "scopes" | "archivedAt" | "createdAt" | "id" | "oauthClientId">;
export declare type SentrySettingsFragment = {
    __typename: "SentrySettings";
} & Pick<SentrySettings, "organizationSlug">;
export declare type SlackPostSettingsFragment = {
    __typename: "SlackPostSettings";
} & Pick<SlackPostSettings, "channel" | "channelId" | "configurationUrl">;
export declare type IntegrationsSettingsFragment = {
    __typename: "IntegrationsSettings";
} & Pick<IntegrationsSettings, "updatedAt" | "archivedAt" | "createdAt" | "id" | "slackIssueNewComment" | "slackIssueAddedToTriage" | "slackIssueCreated" | "slackProjectUpdateCreated" | "slackIssueSlaHighRisk" | "slackIssueSlaBreached" | "slackIssueStatusChangedDone" | "slackIssueStatusChangedAll" | "slackProjectUpdateCreatedToTeam" | "slackProjectUpdateCreatedToWorkspace"> & {
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
};
export declare type IntegrationSettingsFragment = {
    __typename: "IntegrationSettings";
} & {
    front?: Maybe<{
        __typename?: "FrontSettings";
    } & FrontSettingsFragment>;
    gitHub?: Maybe<{
        __typename?: "GitHubSettings";
    } & GitHubSettingsFragment>;
    googleSheets?: Maybe<{
        __typename?: "GoogleSheetsSettings";
    } & GoogleSheetsSettingsFragment>;
    intercom?: Maybe<{
        __typename?: "IntercomSettings";
    } & IntercomSettingsFragment>;
    jira?: Maybe<{
        __typename?: "JiraSettings";
    } & JiraSettingsFragment>;
    notion?: Maybe<{
        __typename?: "NotionSettings";
    } & NotionSettingsFragment>;
    pagerDuty?: Maybe<{
        __typename?: "PagerDutySettings";
    } & PagerDutySettingsFragment>;
    sentry?: Maybe<{
        __typename?: "SentrySettings";
    } & SentrySettingsFragment>;
    slackOrgProjectUpdatesPost?: Maybe<{
        __typename?: "SlackPostSettings";
    } & SlackPostSettingsFragment>;
    slackPost?: Maybe<{
        __typename?: "SlackPostSettings";
    } & SlackPostSettingsFragment>;
    slackProjectPost?: Maybe<{
        __typename?: "SlackPostSettings";
    } & SlackPostSettingsFragment>;
    zendesk?: Maybe<{
        __typename?: "ZendeskSettings";
    } & ZendeskSettingsFragment>;
};
export declare type SamlConfigurationPayloadFragment = {
    __typename: "SamlConfigurationPayload";
} & Pick<SamlConfigurationPayload, "ssoBinding" | "ssoEndpoint" | "ssoSignAlgo" | "issuerEntityId">;
export declare type PaidSubscriptionFragment = {
    __typename: "PaidSubscription";
} & Pick<PaidSubscription, "canceledAt" | "nextBillingAt" | "updatedAt" | "seatsMaximum" | "seatsMinimum" | "seats" | "pendingChangeType" | "type" | "archivedAt" | "createdAt" | "id"> & {
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type UserSettingsFragment = {
    __typename: "UserSettings";
} & Pick<UserSettings, "calendarHash" | "unsubscribedFrom" | "updatedAt" | "notificationPreferences" | "archivedAt" | "createdAt" | "id" | "showFullUserNames"> & {
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type JiraLinearMappingFragment = {
    __typename: "JiraLinearMapping";
} & Pick<JiraLinearMapping, "jiraProjectId" | "linearTeamId">;
export declare type PagerDutyScheduleMappingFragment = {
    __typename: "PagerDutyScheduleMapping";
} & Pick<PagerDutyScheduleMapping, "scheduleId" | "scheduleName">;
export declare type FavoriteFragment = {
    __typename: "Favorite";
} & Pick<Favorite, "updatedAt" | "folderName" | "sortOrder" | "archivedAt" | "createdAt" | "predefinedViewType" | "type" | "id"> & {
    customView?: Maybe<{
        __typename?: "CustomView";
    } & Pick<CustomView, "id">>;
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    document?: Maybe<{
        __typename?: "Document";
    } & Pick<Document, "id">>;
    issue?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
    label?: Maybe<{
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    roadmap?: Maybe<{
        __typename?: "Roadmap";
    } & Pick<Roadmap, "id">>;
    projectTeam?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    owner: {
        __typename?: "User";
    } & Pick<User, "id">;
    parent?: Maybe<{
        __typename?: "Favorite";
    } & Pick<Favorite, "id">>;
    predefinedViewTeam?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
};
export declare type ViewPreferencesFragment = {
    __typename: "ViewPreferences";
} & Pick<ViewPreferences, "updatedAt" | "archivedAt" | "createdAt" | "id" | "type" | "viewType">;
export declare type AuditEntryFragment = {
    __typename: "AuditEntry";
} & Pick<AuditEntry, "requestInformation" | "metadata" | "countryCode" | "ip" | "actorId" | "updatedAt" | "archivedAt" | "createdAt" | "id" | "type"> & {
    actor?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type ZendeskSettingsFragment = {
    __typename: "ZendeskSettings";
} & Pick<ZendeskSettings, "botUserId" | "url" | "subdomain" | "automateTicketReopeningOnComment" | "automateTicketReopeningOnCancellation" | "automateTicketReopeningOnCompletion" | "sendNoteOnStatusChange" | "sendNoteOnComment">;
export declare type ApiKeyConnectionFragment = {
    __typename: "ApiKeyConnection";
} & {
    nodes: Array<{
        __typename?: "ApiKey";
    } & ApiKeyFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ApiKeyPayloadFragment = {
    __typename: "ApiKeyPayload";
} & Pick<ApiKeyPayload, "lastSyncId" | "success"> & {
    apiKey: {
        __typename?: "ApiKey";
    } & ApiKeyFragment;
};
export declare type AttachmentConnectionFragment = {
    __typename: "AttachmentConnection";
} & {
    nodes: Array<{
        __typename?: "Attachment";
    } & AttachmentFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type AttachmentPayloadFragment = {
    __typename: "AttachmentPayload";
} & Pick<AttachmentPayload, "lastSyncId" | "success"> & {
    attachment: {
        __typename?: "Attachment";
    } & Pick<Attachment, "id">;
};
export declare type AttachmentSourcesPayloadFragment = {
    __typename: "AttachmentSourcesPayload";
} & Pick<AttachmentSourcesPayload, "sources">;
export declare type AuditEntryConnectionFragment = {
    __typename: "AuditEntryConnection";
} & {
    nodes: Array<{
        __typename?: "AuditEntry";
    } & AuditEntryFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type AuditEntryTypeFragment = {
    __typename: "AuditEntryType";
} & Pick<AuditEntryType, "description" | "type">;
export declare type AuthResolverResponseFragment = {
    __typename: "AuthResolverResponse";
} & Pick<AuthResolverResponse, "email" | "lastUsedOrganizationId" | "token" | "allowDomainAccess" | "id"> & {
    availableOrganizations?: Maybe<Array<{
        __typename?: "Organization";
    } & OrganizationFragment>>;
    users: Array<{
        __typename?: "User";
    } & UserFragment>;
};
export declare type CommentConnectionFragment = {
    __typename: "CommentConnection";
} & {
    nodes: Array<{
        __typename?: "Comment";
    } & CommentFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type CommentPayloadFragment = {
    __typename: "CommentPayload";
} & Pick<CommentPayload, "lastSyncId" | "success"> & {
    comment: {
        __typename?: "Comment";
    } & Pick<Comment, "id">;
};
export declare type CompanyConnectionFragment = {
    __typename: "CompanyConnection";
} & {
    nodes: Array<{
        __typename?: "Company";
    } & CompanyFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ContactPayloadFragment = {
    __typename: "ContactPayload";
} & Pick<ContactPayload, "success">;
export declare type CreateCsvExportReportPayloadFragment = {
    __typename: "CreateCsvExportReportPayload";
} & Pick<CreateCsvExportReportPayload, "success">;
export declare type CreateOrJoinOrganizationResponseFragment = {
    __typename: "CreateOrJoinOrganizationResponse";
} & {
    user: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type CustomViewConnectionFragment = {
    __typename: "CustomViewConnection";
} & {
    nodes: Array<{
        __typename?: "CustomView";
    } & CustomViewFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type CustomViewPayloadFragment = {
    __typename: "CustomViewPayload";
} & Pick<CustomViewPayload, "lastSyncId" | "success"> & {
    customView: {
        __typename?: "CustomView";
    } & Pick<CustomView, "id">;
};
export declare type CustomViewSuggestionPayloadFragment = {
    __typename: "CustomViewSuggestionPayload";
} & Pick<CustomViewSuggestionPayload, "description" | "icon" | "name">;
export declare type CycleConnectionFragment = {
    __typename: "CycleConnection";
} & {
    nodes: Array<{
        __typename?: "Cycle";
    } & CycleFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type CyclePayloadFragment = {
    __typename: "CyclePayload";
} & Pick<CyclePayload, "lastSyncId" | "success"> & {
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
};
export declare type DocumentConnectionFragment = {
    __typename: "DocumentConnection";
} & {
    nodes: Array<{
        __typename?: "Document";
    } & DocumentFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type DocumentPayloadFragment = {
    __typename: "DocumentPayload";
} & Pick<DocumentPayload, "lastSyncId" | "success"> & {
    document: {
        __typename?: "Document";
    } & Pick<Document, "id">;
};
export declare type DocumentSearchPayloadFragment = {
    __typename: "DocumentSearchPayload";
} & Pick<DocumentSearchPayload, "totalCount"> & {
    archivePayload: {
        __typename?: "ArchiveResponse";
    } & ArchiveResponseFragment;
    nodes: Array<{
        __typename?: "DocumentSearchResult";
    } & DocumentSearchResultFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type DocumentSearchResultFragment = {
    __typename: "DocumentSearchResult";
} & Pick<DocumentSearchResult, "metadata" | "color" | "contentData" | "content" | "title" | "slugId" | "icon" | "updatedAt" | "archivedAt" | "createdAt" | "id"> & {
    project: {
        __typename?: "Project";
    } & Pick<Project, "id">;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
    updatedBy: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type DocumentSearchResultConnectionFragment = {
    __typename: "DocumentSearchResultConnection";
} & {
    nodes: Array<{
        __typename?: "DocumentSearchResult";
    } & DocumentSearchResultFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type EmailUnsubscribePayloadFragment = {
    __typename: "EmailUnsubscribePayload";
} & Pick<EmailUnsubscribePayload, "success">;
export declare type EmailUserAccountAuthChallengeResponseFragment = {
    __typename: "EmailUserAccountAuthChallengeResponse";
} & Pick<EmailUserAccountAuthChallengeResponse, "authType" | "success">;
export declare type EmbedPayloadFragment = {
    __typename: "EmbedPayload";
} & Pick<EmbedPayload, "success"> & {
    embed?: Maybe<{
        __typename?: "Embed";
    } & EmbedFragment>;
};
export declare type EmojiConnectionFragment = {
    __typename: "EmojiConnection";
} & {
    nodes: Array<{
        __typename?: "Emoji";
    } & EmojiFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type EmojiPayloadFragment = {
    __typename: "EmojiPayload";
} & Pick<EmojiPayload, "lastSyncId" | "success"> & {
    emoji: {
        __typename?: "Emoji";
    } & Pick<Emoji, "id">;
};
export declare type FavoriteConnectionFragment = {
    __typename: "FavoriteConnection";
} & {
    nodes: Array<{
        __typename?: "Favorite";
    } & FavoriteFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type FavoritePayloadFragment = {
    __typename: "FavoritePayload";
} & Pick<FavoritePayload, "lastSyncId" | "success"> & {
    favorite: {
        __typename?: "Favorite";
    } & Pick<Favorite, "id">;
};
export declare type FigmaEmbedPayloadFragment = {
    __typename: "FigmaEmbedPayload";
} & Pick<FigmaEmbedPayload, "success"> & {
    figmaEmbed?: Maybe<{
        __typename?: "FigmaEmbed";
    } & FigmaEmbedFragment>;
};
export declare type FirstResponderScheduleConnectionFragment = {
    __typename: "FirstResponderScheduleConnection";
} & {
    nodes: Array<{
        __typename?: "FirstResponderSchedule";
    } & FirstResponderScheduleFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type FrontAttachmentPayloadFragment = {
    __typename: "FrontAttachmentPayload";
} & Pick<FrontAttachmentPayload, "lastSyncId" | "success">;
export declare type GitHubCommitIntegrationPayloadFragment = {
    __typename: "GitHubCommitIntegrationPayload";
} & Pick<GitHubCommitIntegrationPayload, "lastSyncId" | "webhookSecret" | "success"> & {
    integration?: Maybe<{
        __typename?: "Integration";
    } & Pick<Integration, "id">>;
};
export declare type ImageUploadFromUrlPayloadFragment = {
    __typename: "ImageUploadFromUrlPayload";
} & Pick<ImageUploadFromUrlPayload, "url" | "lastSyncId" | "success">;
export declare type IntegrationConnectionFragment = {
    __typename: "IntegrationConnection";
} & {
    nodes: Array<{
        __typename?: "Integration";
    } & IntegrationFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IntegrationPayloadFragment = {
    __typename: "IntegrationPayload";
} & Pick<IntegrationPayload, "lastSyncId" | "success"> & {
    integration?: Maybe<{
        __typename?: "Integration";
    } & Pick<Integration, "id">>;
};
export declare type IntegrationRequestPayloadFragment = {
    __typename: "IntegrationRequestPayload";
} & Pick<IntegrationRequestPayload, "success">;
export declare type IntegrationTemplateConnectionFragment = {
    __typename: "IntegrationTemplateConnection";
} & {
    nodes: Array<{
        __typename?: "IntegrationTemplate";
    } & IntegrationTemplateFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IntegrationTemplatePayloadFragment = {
    __typename: "IntegrationTemplatePayload";
} & Pick<IntegrationTemplatePayload, "lastSyncId" | "success"> & {
    integrationTemplate: {
        __typename?: "IntegrationTemplate";
    } & Pick<IntegrationTemplate, "id">;
};
export declare type IntegrationsSettingsConnectionFragment = {
    __typename: "IntegrationsSettingsConnection";
} & {
    nodes: Array<{
        __typename?: "IntegrationsSettings";
    } & IntegrationsSettingsFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IntegrationsSettingsPayloadFragment = {
    __typename: "IntegrationsSettingsPayload";
} & Pick<IntegrationsSettingsPayload, "lastSyncId" | "success"> & {
    integrationsSettings: {
        __typename?: "IntegrationsSettings";
    } & Pick<IntegrationsSettings, "id">;
};
export declare type IssueBatchPayloadFragment = {
    __typename: "IssueBatchPayload";
} & Pick<IssueBatchPayload, "lastSyncId" | "success"> & {
    issues: Array<{
        __typename?: "Issue";
    } & IssueFragment>;
};
export declare type IssueConnectionFragment = {
    __typename: "IssueConnection";
} & {
    nodes: Array<{
        __typename?: "Issue";
    } & IssueFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IssueFilterSuggestionPayloadFragment = {
    __typename: "IssueFilterSuggestionPayload";
} & Pick<IssueFilterSuggestionPayload, "filter">;
export declare type IssueHistoryConnectionFragment = {
    __typename: "IssueHistoryConnection";
} & {
    nodes: Array<{
        __typename?: "IssueHistory";
    } & IssueHistoryFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IssueImportCheckPayloadFragment = {
    __typename: "IssueImportCheckPayload";
} & Pick<IssueImportCheckPayload, "success">;
export declare type IssueImportDeletePayloadFragment = {
    __typename: "IssueImportDeletePayload";
} & Pick<IssueImportDeletePayload, "lastSyncId" | "success"> & {
    issueImport?: Maybe<{
        __typename?: "IssueImport";
    } & IssueImportFragment>;
};
export declare type IssueImportPayloadFragment = {
    __typename: "IssueImportPayload";
} & Pick<IssueImportPayload, "lastSyncId" | "success"> & {
    issueImport?: Maybe<{
        __typename?: "IssueImport";
    } & IssueImportFragment>;
};
export declare type IssueLabelConnectionFragment = {
    __typename: "IssueLabelConnection";
} & {
    nodes: Array<{
        __typename?: "IssueLabel";
    } & IssueLabelFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IssueLabelPayloadFragment = {
    __typename: "IssueLabelPayload";
} & Pick<IssueLabelPayload, "lastSyncId" | "success"> & {
    issueLabel: {
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">;
};
export declare type IssuePayloadFragment = {
    __typename: "IssuePayload";
} & Pick<IssuePayload, "lastSyncId" | "success"> & {
    issue?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
};
export declare type IssuePriorityValueFragment = {
    __typename: "IssuePriorityValue";
} & Pick<IssuePriorityValue, "label" | "priority">;
export declare type IssueRelationConnectionFragment = {
    __typename: "IssueRelationConnection";
} & {
    nodes: Array<{
        __typename?: "IssueRelation";
    } & IssueRelationFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IssueRelationPayloadFragment = {
    __typename: "IssueRelationPayload";
} & Pick<IssueRelationPayload, "lastSyncId" | "success"> & {
    issueRelation: {
        __typename?: "IssueRelation";
    } & Pick<IssueRelation, "id">;
};
export declare type IssueSearchPayloadFragment = {
    __typename: "IssueSearchPayload";
} & Pick<IssueSearchPayload, "totalCount"> & {
    archivePayload: {
        __typename?: "ArchiveResponse";
    } & ArchiveResponseFragment;
    nodes: Array<{
        __typename?: "IssueSearchResult";
    } & IssueSearchResultFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type IssueSearchResultFragment = {
    __typename: "IssueSearchResult";
} & Pick<IssueSearchResult, "trashed" | "url" | "identifier" | "priorityLabel" | "metadata" | "previousIdentifiers" | "customerTicketCount" | "branchName" | "dueDate" | "estimate" | "description" | "title" | "number" | "updatedAt" | "boardOrder" | "sortOrder" | "subIssueSortOrder" | "priority" | "archivedAt" | "createdAt" | "startedTriageAt" | "triagedAt" | "autoArchivedAt" | "autoClosedAt" | "canceledAt" | "completedAt" | "startedAt" | "snoozedUntilAt" | "id"> & {
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    parent?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    projectMilestone?: Maybe<{
        __typename?: "ProjectMilestone";
    } & Pick<ProjectMilestone, "id">>;
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
    assignee?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    creator?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    snoozedBy?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    favorite?: Maybe<{
        __typename?: "Favorite";
    } & Pick<Favorite, "id">>;
    state: {
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">;
};
export declare type IssueSearchResultConnectionFragment = {
    __typename: "IssueSearchResultConnection";
} & {
    nodes: Array<{
        __typename?: "IssueSearchResult";
    } & IssueSearchResultFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type LogoutResponseFragment = {
    __typename: "LogoutResponse";
} & Pick<LogoutResponse, "success">;
declare type Node_ApiKey_Fragment = {
    __typename: "ApiKey";
} & Pick<ApiKey, "id">;
declare type Node_Attachment_Fragment = {
    __typename: "Attachment";
} & Pick<Attachment, "id">;
declare type Node_AuditEntry_Fragment = {
    __typename: "AuditEntry";
} & Pick<AuditEntry, "id">;
declare type Node_Comment_Fragment = {
    __typename: "Comment";
} & Pick<Comment, "id">;
declare type Node_Company_Fragment = {
    __typename: "Company";
} & Pick<Company, "id">;
declare type Node_CustomView_Fragment = {
    __typename: "CustomView";
} & Pick<CustomView, "id">;
declare type Node_CustomViewNotificationSubscription_Fragment = {
    __typename: "CustomViewNotificationSubscription";
} & Pick<CustomViewNotificationSubscription, "id">;
declare type Node_Cycle_Fragment = {
    __typename: "Cycle";
} & Pick<Cycle, "id">;
declare type Node_CycleNotificationSubscription_Fragment = {
    __typename: "CycleNotificationSubscription";
} & Pick<CycleNotificationSubscription, "id">;
declare type Node_Document_Fragment = {
    __typename: "Document";
} & Pick<Document, "id">;
declare type Node_DocumentContent_Fragment = {
    __typename: "DocumentContent";
} & Pick<DocumentContent, "id">;
declare type Node_DocumentSearchResult_Fragment = {
    __typename: "DocumentSearchResult";
} & Pick<DocumentSearchResult, "id">;
declare type Node_Emoji_Fragment = {
    __typename: "Emoji";
} & Pick<Emoji, "id">;
declare type Node_ExternalUser_Fragment = {
    __typename: "ExternalUser";
} & Pick<ExternalUser, "id">;
declare type Node_Favorite_Fragment = {
    __typename: "Favorite";
} & Pick<Favorite, "id">;
declare type Node_FirstResponderSchedule_Fragment = {
    __typename: "FirstResponderSchedule";
} & Pick<FirstResponderSchedule, "id">;
declare type Node_Integration_Fragment = {
    __typename: "Integration";
} & Pick<Integration, "id">;
declare type Node_IntegrationTemplate_Fragment = {
    __typename: "IntegrationTemplate";
} & Pick<IntegrationTemplate, "id">;
declare type Node_IntegrationsSettings_Fragment = {
    __typename: "IntegrationsSettings";
} & Pick<IntegrationsSettings, "id">;
declare type Node_Issue_Fragment = {
    __typename: "Issue";
} & Pick<Issue, "id">;
declare type Node_IssueDraft_Fragment = {
    __typename: "IssueDraft";
} & Pick<IssueDraft, "id">;
declare type Node_IssueHistory_Fragment = {
    __typename: "IssueHistory";
} & Pick<IssueHistory, "id">;
declare type Node_IssueImport_Fragment = {
    __typename: "IssueImport";
} & Pick<IssueImport, "id">;
declare type Node_IssueLabel_Fragment = {
    __typename: "IssueLabel";
} & Pick<IssueLabel, "id">;
declare type Node_IssueNotification_Fragment = {
    __typename: "IssueNotification";
} & Pick<IssueNotification, "id">;
declare type Node_IssueRelation_Fragment = {
    __typename: "IssueRelation";
} & Pick<IssueRelation, "id">;
declare type Node_IssueSearchResult_Fragment = {
    __typename: "IssueSearchResult";
} & Pick<IssueSearchResult, "id">;
declare type Node_LabelNotificationSubscription_Fragment = {
    __typename: "LabelNotificationSubscription";
} & Pick<LabelNotificationSubscription, "id">;
declare type Node_OauthClient_Fragment = {
    __typename: "OauthClient";
} & Pick<OauthClient, "id">;
declare type Node_OauthClientApproval_Fragment = {
    __typename: "OauthClientApproval";
} & Pick<OauthClientApproval, "id">;
declare type Node_OauthClientApprovalNotification_Fragment = {
    __typename: "OauthClientApprovalNotification";
} & Pick<OauthClientApprovalNotification, "id">;
declare type Node_Organization_Fragment = {
    __typename: "Organization";
} & Pick<Organization, "id">;
declare type Node_OrganizationDomain_Fragment = {
    __typename: "OrganizationDomain";
} & Pick<OrganizationDomain, "id">;
declare type Node_OrganizationInvite_Fragment = {
    __typename: "OrganizationInvite";
} & Pick<OrganizationInvite, "id">;
declare type Node_PaidSubscription_Fragment = {
    __typename: "PaidSubscription";
} & Pick<PaidSubscription, "id">;
declare type Node_Project_Fragment = {
    __typename: "Project";
} & Pick<Project, "id">;
declare type Node_ProjectLink_Fragment = {
    __typename: "ProjectLink";
} & Pick<ProjectLink, "id">;
declare type Node_ProjectMilestone_Fragment = {
    __typename: "ProjectMilestone";
} & Pick<ProjectMilestone, "id">;
declare type Node_ProjectNotification_Fragment = {
    __typename: "ProjectNotification";
} & Pick<ProjectNotification, "id">;
declare type Node_ProjectNotificationSubscription_Fragment = {
    __typename: "ProjectNotificationSubscription";
} & Pick<ProjectNotificationSubscription, "id">;
declare type Node_ProjectSearchResult_Fragment = {
    __typename: "ProjectSearchResult";
} & Pick<ProjectSearchResult, "id">;
declare type Node_ProjectUpdate_Fragment = {
    __typename: "ProjectUpdate";
} & Pick<ProjectUpdate, "id">;
declare type Node_ProjectUpdateInteraction_Fragment = {
    __typename: "ProjectUpdateInteraction";
} & Pick<ProjectUpdateInteraction, "id">;
declare type Node_PushSubscription_Fragment = {
    __typename: "PushSubscription";
} & Pick<PushSubscription, "id">;
declare type Node_Reaction_Fragment = {
    __typename: "Reaction";
} & Pick<Reaction, "id">;
declare type Node_Roadmap_Fragment = {
    __typename: "Roadmap";
} & Pick<Roadmap, "id">;
declare type Node_RoadmapToProject_Fragment = {
    __typename: "RoadmapToProject";
} & Pick<RoadmapToProject, "id">;
declare type Node_Team_Fragment = {
    __typename: "Team";
} & Pick<Team, "id">;
declare type Node_TeamMembership_Fragment = {
    __typename: "TeamMembership";
} & Pick<TeamMembership, "id">;
declare type Node_TeamNotificationSubscription_Fragment = {
    __typename: "TeamNotificationSubscription";
} & Pick<TeamNotificationSubscription, "id">;
declare type Node_Template_Fragment = {
    __typename: "Template";
} & Pick<Template, "id">;
declare type Node_User_Fragment = {
    __typename: "User";
} & Pick<User, "id">;
declare type Node_UserNotificationSubscription_Fragment = {
    __typename: "UserNotificationSubscription";
} & Pick<UserNotificationSubscription, "id">;
declare type Node_UserSettings_Fragment = {
    __typename: "UserSettings";
} & Pick<UserSettings, "id">;
declare type Node_ViewPreferences_Fragment = {
    __typename: "ViewPreferences";
} & Pick<ViewPreferences, "id">;
declare type Node_Webhook_Fragment = {
    __typename: "Webhook";
} & Pick<Webhook, "id">;
declare type Node_WorkflowCronJobDefinition_Fragment = {
    __typename: "WorkflowCronJobDefinition";
} & Pick<WorkflowCronJobDefinition, "id">;
declare type Node_WorkflowDefinition_Fragment = {
    __typename: "WorkflowDefinition";
} & Pick<WorkflowDefinition, "id">;
declare type Node_WorkflowState_Fragment = {
    __typename: "WorkflowState";
} & Pick<WorkflowState, "id">;
export declare type NodeFragment = Node_ApiKey_Fragment | Node_Attachment_Fragment | Node_AuditEntry_Fragment | Node_Comment_Fragment | Node_Company_Fragment | Node_CustomView_Fragment | Node_CustomViewNotificationSubscription_Fragment | Node_Cycle_Fragment | Node_CycleNotificationSubscription_Fragment | Node_Document_Fragment | Node_DocumentContent_Fragment | Node_DocumentSearchResult_Fragment | Node_Emoji_Fragment | Node_ExternalUser_Fragment | Node_Favorite_Fragment | Node_FirstResponderSchedule_Fragment | Node_Integration_Fragment | Node_IntegrationTemplate_Fragment | Node_IntegrationsSettings_Fragment | Node_Issue_Fragment | Node_IssueDraft_Fragment | Node_IssueHistory_Fragment | Node_IssueImport_Fragment | Node_IssueLabel_Fragment | Node_IssueNotification_Fragment | Node_IssueRelation_Fragment | Node_IssueSearchResult_Fragment | Node_LabelNotificationSubscription_Fragment | Node_OauthClient_Fragment | Node_OauthClientApproval_Fragment | Node_OauthClientApprovalNotification_Fragment | Node_Organization_Fragment | Node_OrganizationDomain_Fragment | Node_OrganizationInvite_Fragment | Node_PaidSubscription_Fragment | Node_Project_Fragment | Node_ProjectLink_Fragment | Node_ProjectMilestone_Fragment | Node_ProjectNotification_Fragment | Node_ProjectNotificationSubscription_Fragment | Node_ProjectSearchResult_Fragment | Node_ProjectUpdate_Fragment | Node_ProjectUpdateInteraction_Fragment | Node_PushSubscription_Fragment | Node_Reaction_Fragment | Node_Roadmap_Fragment | Node_RoadmapToProject_Fragment | Node_Team_Fragment | Node_TeamMembership_Fragment | Node_TeamNotificationSubscription_Fragment | Node_Template_Fragment | Node_User_Fragment | Node_UserNotificationSubscription_Fragment | Node_UserSettings_Fragment | Node_ViewPreferences_Fragment | Node_Webhook_Fragment | Node_WorkflowCronJobDefinition_Fragment | Node_WorkflowDefinition_Fragment | Node_WorkflowState_Fragment;
export declare type NotificationBatchActionPayloadFragment = {
    __typename: "NotificationBatchActionPayload";
} & Pick<NotificationBatchActionPayload, "lastSyncId" | "success"> & {
    notifications: Array<({
        __typename?: "IssueNotification";
    } & Notification_IssueNotification_Fragment) | ({
        __typename?: "OauthClientApprovalNotification";
    } & Notification_OauthClientApprovalNotification_Fragment) | ({
        __typename?: "ProjectNotification";
    } & Notification_ProjectNotification_Fragment)>;
};
export declare type NotificationConnectionFragment = {
    __typename: "NotificationConnection";
} & {
    nodes: Array<({
        __typename?: "IssueNotification";
    } & Notification_IssueNotification_Fragment) | ({
        __typename?: "OauthClientApprovalNotification";
    } & Notification_OauthClientApprovalNotification_Fragment) | ({
        __typename?: "ProjectNotification";
    } & Notification_ProjectNotification_Fragment)>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type NotificationPayloadFragment = {
    __typename: "NotificationPayload";
} & Pick<NotificationPayload, "lastSyncId" | "success"> & {
    notification: ({
        __typename?: "IssueNotification";
    } & Notification_IssueNotification_Fragment) | ({
        __typename?: "OauthClientApprovalNotification";
    } & Notification_OauthClientApprovalNotification_Fragment) | ({
        __typename?: "ProjectNotification";
    } & Notification_ProjectNotification_Fragment);
};
export declare type NotificationSubscriptionConnectionFragment = {
    __typename: "NotificationSubscriptionConnection";
} & {
    nodes: Array<({
        __typename?: "CustomViewNotificationSubscription";
    } & NotificationSubscription_CustomViewNotificationSubscription_Fragment) | ({
        __typename?: "CycleNotificationSubscription";
    } & NotificationSubscription_CycleNotificationSubscription_Fragment) | ({
        __typename?: "LabelNotificationSubscription";
    } & NotificationSubscription_LabelNotificationSubscription_Fragment) | ({
        __typename?: "ProjectNotificationSubscription";
    } & NotificationSubscription_ProjectNotificationSubscription_Fragment) | ({
        __typename?: "TeamNotificationSubscription";
    } & NotificationSubscription_TeamNotificationSubscription_Fragment) | ({
        __typename?: "UserNotificationSubscription";
    } & NotificationSubscription_UserNotificationSubscription_Fragment)>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type NotificationSubscriptionPayloadFragment = {
    __typename: "NotificationSubscriptionPayload";
} & Pick<NotificationSubscriptionPayload, "lastSyncId" | "success"> & {
    notificationSubscription: ({
        __typename?: "CustomViewNotificationSubscription";
    } & NotificationSubscription_CustomViewNotificationSubscription_Fragment) | ({
        __typename?: "CycleNotificationSubscription";
    } & NotificationSubscription_CycleNotificationSubscription_Fragment) | ({
        __typename?: "LabelNotificationSubscription";
    } & NotificationSubscription_LabelNotificationSubscription_Fragment) | ({
        __typename?: "ProjectNotificationSubscription";
    } & NotificationSubscription_ProjectNotificationSubscription_Fragment) | ({
        __typename?: "TeamNotificationSubscription";
    } & NotificationSubscription_TeamNotificationSubscription_Fragment) | ({
        __typename?: "UserNotificationSubscription";
    } & NotificationSubscription_UserNotificationSubscription_Fragment);
};
export declare type OauthClientConnectionFragment = {
    __typename: "OauthClientConnection";
} & {
    nodes: Array<{
        __typename?: "OauthClient";
    } & OauthClientFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type OrganizationCancelDeletePayloadFragment = {
    __typename: "OrganizationCancelDeletePayload";
} & Pick<OrganizationCancelDeletePayload, "success">;
export declare type OrganizationDeletePayloadFragment = {
    __typename: "OrganizationDeletePayload";
} & Pick<OrganizationDeletePayload, "success">;
export declare type OrganizationExistsPayloadFragment = {
    __typename: "OrganizationExistsPayload";
} & Pick<OrganizationExistsPayload, "success" | "exists">;
export declare type OrganizationInviteConnectionFragment = {
    __typename: "OrganizationInviteConnection";
} & {
    nodes: Array<{
        __typename?: "OrganizationInvite";
    } & OrganizationInviteFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type OrganizationInviteFullDetailsPayloadFragment = {
    __typename: "OrganizationInviteFullDetailsPayload";
} & Pick<OrganizationInviteFullDetailsPayload, "organizationId" | "organizationName" | "email" | "inviter" | "organizationLogoUrl" | "createdAt" | "accepted" | "expired">;
export declare type OrganizationInvitePayloadFragment = {
    __typename: "OrganizationInvitePayload";
} & Pick<OrganizationInvitePayload, "lastSyncId" | "success"> & {
    organizationInvite: {
        __typename?: "OrganizationInvite";
    } & Pick<OrganizationInvite, "id">;
};
export declare type OrganizationPayloadFragment = {
    __typename: "OrganizationPayload";
} & Pick<OrganizationPayload, "lastSyncId" | "success">;
export declare type OrganizationStartPlusTrialPayloadFragment = {
    __typename: "OrganizationStartPlusTrialPayload";
} & Pick<OrganizationStartPlusTrialPayload, "success">;
export declare type PageInfoFragment = {
    __typename: "PageInfo";
} & Pick<PageInfo, "startCursor" | "endCursor" | "hasPreviousPage" | "hasNextPage">;
export declare type ProjectConnectionFragment = {
    __typename: "ProjectConnection";
} & {
    nodes: Array<{
        __typename?: "Project";
    } & ProjectFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ProjectFilterSuggestionPayloadFragment = {
    __typename: "ProjectFilterSuggestionPayload";
} & Pick<ProjectFilterSuggestionPayload, "filter">;
export declare type ProjectLinkConnectionFragment = {
    __typename: "ProjectLinkConnection";
} & {
    nodes: Array<{
        __typename?: "ProjectLink";
    } & ProjectLinkFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ProjectLinkPayloadFragment = {
    __typename: "ProjectLinkPayload";
} & Pick<ProjectLinkPayload, "lastSyncId" | "success"> & {
    projectLink: {
        __typename?: "ProjectLink";
    } & Pick<ProjectLink, "id">;
};
export declare type ProjectMilestoneConnectionFragment = {
    __typename: "ProjectMilestoneConnection";
} & {
    nodes: Array<{
        __typename?: "ProjectMilestone";
    } & ProjectMilestoneFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ProjectMilestonePayloadFragment = {
    __typename: "ProjectMilestonePayload";
} & Pick<ProjectMilestonePayload, "lastSyncId" | "success"> & {
    projectMilestone: {
        __typename?: "ProjectMilestone";
    } & Pick<ProjectMilestone, "id">;
};
export declare type ProjectPayloadFragment = {
    __typename: "ProjectPayload";
} & Pick<ProjectPayload, "lastSyncId" | "success"> & {
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
};
export declare type ProjectSearchPayloadFragment = {
    __typename: "ProjectSearchPayload";
} & Pick<ProjectSearchPayload, "totalCount"> & {
    archivePayload: {
        __typename?: "ArchiveResponse";
    } & ArchiveResponseFragment;
    nodes: Array<{
        __typename?: "ProjectSearchResult";
    } & ProjectSearchResultFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ProjectSearchResultFragment = {
    __typename: "ProjectSearchResult";
} & Pick<ProjectSearchResult, "metadata" | "url" | "targetDate" | "startDate" | "icon" | "updatedAt" | "completedScopeHistory" | "completedIssueCountHistory" | "inProgressScopeHistory" | "progress" | "scope" | "color" | "description" | "name" | "slugId" | "sortOrder" | "archivedAt" | "createdAt" | "autoArchivedAt" | "canceledAt" | "completedAt" | "startedAt" | "projectUpdateRemindersPausedUntilAt" | "scopeHistory" | "issueCountHistory" | "state" | "id" | "slackIssueComments" | "slackNewIssue" | "slackIssueStatuses"> & {
    integrationsSettings?: Maybe<{
        __typename?: "IntegrationsSettings";
    } & Pick<IntegrationsSettings, "id">>;
    lead?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    convertedFromIssue?: Maybe<{
        __typename?: "Issue";
    } & Pick<Issue, "id">>;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type ProjectSearchResultConnectionFragment = {
    __typename: "ProjectSearchResultConnection";
} & {
    nodes: Array<{
        __typename?: "ProjectSearchResult";
    } & ProjectSearchResultFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ProjectUpdateConnectionFragment = {
    __typename: "ProjectUpdateConnection";
} & {
    nodes: Array<{
        __typename?: "ProjectUpdate";
    } & ProjectUpdateFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ProjectUpdateInteractionConnectionFragment = {
    __typename: "ProjectUpdateInteractionConnection";
} & {
    nodes: Array<{
        __typename?: "ProjectUpdateInteraction";
    } & ProjectUpdateInteractionFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ProjectUpdateInteractionPayloadFragment = {
    __typename: "ProjectUpdateInteractionPayload";
} & Pick<ProjectUpdateInteractionPayload, "lastSyncId" | "success"> & {
    projectUpdateInteraction: {
        __typename?: "ProjectUpdateInteraction";
    } & Pick<ProjectUpdateInteraction, "id">;
};
export declare type ProjectUpdatePayloadFragment = {
    __typename: "ProjectUpdatePayload";
} & Pick<ProjectUpdatePayload, "lastSyncId" | "success"> & {
    projectUpdate: {
        __typename?: "ProjectUpdate";
    } & Pick<ProjectUpdate, "id">;
};
export declare type ProjectUpdateWithInteractionPayloadFragment = {
    __typename: "ProjectUpdateWithInteractionPayload";
} & Pick<ProjectUpdateWithInteractionPayload, "lastSyncId" | "success"> & {
    interaction: {
        __typename?: "ProjectUpdateInteraction";
    } & Pick<ProjectUpdateInteraction, "id">;
    projectUpdate: {
        __typename?: "ProjectUpdate";
    } & Pick<ProjectUpdate, "id">;
};
export declare type PushSubscriptionConnectionFragment = {
    __typename: "PushSubscriptionConnection";
} & {
    nodes: Array<{
        __typename?: "PushSubscription";
    } & PushSubscriptionFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type PushSubscriptionPayloadFragment = {
    __typename: "PushSubscriptionPayload";
} & Pick<PushSubscriptionPayload, "lastSyncId" | "success">;
export declare type PushSubscriptionTestPayloadFragment = {
    __typename: "PushSubscriptionTestPayload";
} & Pick<PushSubscriptionTestPayload, "success">;
export declare type RateLimitPayloadFragment = {
    __typename: "RateLimitPayload";
} & Pick<RateLimitPayload, "identifier" | "kind"> & {
    limits: Array<{
        __typename?: "RateLimitResultPayload";
    } & RateLimitResultPayloadFragment>;
};
export declare type RateLimitResultPayloadFragment = {
    __typename: "RateLimitResultPayload";
} & Pick<RateLimitResultPayload, "period" | "remainingAmount" | "requestedAmount" | "reset" | "allowedAmount" | "type">;
export declare type ReactionConnectionFragment = {
    __typename: "ReactionConnection";
} & {
    nodes: Array<{
        __typename?: "Reaction";
    } & ReactionFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type ReactionPayloadFragment = {
    __typename: "ReactionPayload";
} & Pick<ReactionPayload, "lastSyncId" | "success"> & {
    reaction: {
        __typename?: "Reaction";
    } & ReactionFragment;
};
export declare type RoadmapConnectionFragment = {
    __typename: "RoadmapConnection";
} & {
    nodes: Array<{
        __typename?: "Roadmap";
    } & RoadmapFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type RoadmapPayloadFragment = {
    __typename: "RoadmapPayload";
} & Pick<RoadmapPayload, "lastSyncId" | "success"> & {
    roadmap: {
        __typename?: "Roadmap";
    } & Pick<Roadmap, "id">;
};
export declare type RoadmapToProjectConnectionFragment = {
    __typename: "RoadmapToProjectConnection";
} & {
    nodes: Array<{
        __typename?: "RoadmapToProject";
    } & RoadmapToProjectFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type RoadmapToProjectPayloadFragment = {
    __typename: "RoadmapToProjectPayload";
} & Pick<RoadmapToProjectPayload, "lastSyncId" | "success"> & {
    roadmapToProject: {
        __typename?: "RoadmapToProject";
    } & Pick<RoadmapToProject, "id">;
};
export declare type SamlConfigurationFragment = {
    __typename: "SamlConfiguration";
} & Pick<SamlConfiguration, "ssoBinding" | "ssoEndpoint" | "ssoSignAlgo" | "issuerEntityId" | "ssoSigningCert">;
export declare type SsoUrlFromEmailResponseFragment = {
    __typename: "SsoUrlFromEmailResponse";
} & Pick<SsoUrlFromEmailResponse, "samlSsoUrl" | "success">;
export declare type SynchronizedPayloadFragment = {
    __typename: "SynchronizedPayload";
} & Pick<SynchronizedPayload, "lastSyncId">;
export declare type TeamConnectionFragment = {
    __typename: "TeamConnection";
} & {
    nodes: Array<{
        __typename?: "Team";
    } & TeamFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type TeamMembershipConnectionFragment = {
    __typename: "TeamMembershipConnection";
} & {
    nodes: Array<{
        __typename?: "TeamMembership";
    } & TeamMembershipFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type TeamMembershipPayloadFragment = {
    __typename: "TeamMembershipPayload";
} & Pick<TeamMembershipPayload, "lastSyncId" | "success"> & {
    teamMembership?: Maybe<{
        __typename?: "TeamMembership";
    } & Pick<TeamMembership, "id">>;
};
export declare type TeamPayloadFragment = {
    __typename: "TeamPayload";
} & Pick<TeamPayload, "lastSyncId" | "success"> & {
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
};
export declare type TemplateConnectionFragment = {
    __typename: "TemplateConnection";
} & {
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type TemplatePayloadFragment = {
    __typename: "TemplatePayload";
} & Pick<TemplatePayload, "lastSyncId" | "success"> & {
    template: {
        __typename?: "Template";
    } & Pick<Template, "id">;
};
export declare type UploadFileHeaderFragment = {
    __typename: "UploadFileHeader";
} & Pick<UploadFileHeader, "key" | "value">;
export declare type UploadPayloadFragment = {
    __typename: "UploadPayload";
} & Pick<UploadPayload, "lastSyncId" | "success"> & {
    uploadFile?: Maybe<{
        __typename?: "UploadFile";
    } & UploadFileFragment>;
};
export declare type UserAdminPayloadFragment = {
    __typename: "UserAdminPayload";
} & Pick<UserAdminPayload, "success">;
export declare type UserConnectionFragment = {
    __typename: "UserConnection";
} & {
    nodes: Array<{
        __typename?: "User";
    } & UserFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type UserPayloadFragment = {
    __typename: "UserPayload";
} & Pick<UserPayload, "lastSyncId" | "success"> & {
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
};
export declare type UserSettingsFlagPayloadFragment = {
    __typename: "UserSettingsFlagPayload";
} & Pick<UserSettingsFlagPayload, "flag" | "value" | "lastSyncId" | "success">;
export declare type UserSettingsFlagsResetPayloadFragment = {
    __typename: "UserSettingsFlagsResetPayload";
} & Pick<UserSettingsFlagsResetPayload, "lastSyncId" | "success">;
export declare type UserSettingsPayloadFragment = {
    __typename: "UserSettingsPayload";
} & Pick<UserSettingsPayload, "lastSyncId" | "success">;
export declare type ViewPreferencesPayloadFragment = {
    __typename: "ViewPreferencesPayload";
} & Pick<ViewPreferencesPayload, "lastSyncId" | "success"> & {
    viewPreferences: {
        __typename?: "ViewPreferences";
    } & ViewPreferencesFragment;
};
export declare type WebhookConnectionFragment = {
    __typename: "WebhookConnection";
} & {
    nodes: Array<{
        __typename?: "Webhook";
    } & WebhookFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type WebhookPayloadFragment = {
    __typename: "WebhookPayload";
} & Pick<WebhookPayload, "lastSyncId" | "success"> & {
    webhook: {
        __typename?: "Webhook";
    } & Pick<Webhook, "id">;
};
export declare type WorkflowCronJobDefinitionFragment = {
    __typename: "WorkflowCronJobDefinition";
} & Pick<WorkflowCronJobDefinition, "activities" | "schedule" | "description" | "updatedAt" | "name" | "sortOrder" | "archivedAt" | "createdAt" | "id" | "enabled"> & {
    team: {
        __typename?: "Team";
    } & Pick<Team, "id">;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type WorkflowCronJobDefinitionConnectionFragment = {
    __typename: "WorkflowCronJobDefinitionConnection";
} & {
    nodes: Array<{
        __typename?: "WorkflowCronJobDefinition";
    } & WorkflowCronJobDefinitionFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type WorkflowDefinitionFragment = {
    __typename: "WorkflowDefinition";
} & Pick<WorkflowDefinition, "activities" | "conditions" | "description" | "updatedAt" | "groupName" | "name" | "sortOrder" | "archivedAt" | "createdAt" | "id" | "enabled"> & {
    customView?: Maybe<{
        __typename?: "CustomView";
    } & Pick<CustomView, "id">>;
    cycle?: Maybe<{
        __typename?: "Cycle";
    } & Pick<Cycle, "id">>;
    label?: Maybe<{
        __typename?: "IssueLabel";
    } & Pick<IssueLabel, "id">>;
    project?: Maybe<{
        __typename?: "Project";
    } & Pick<Project, "id">>;
    user?: Maybe<{
        __typename?: "User";
    } & Pick<User, "id">>;
    team?: Maybe<{
        __typename?: "Team";
    } & Pick<Team, "id">>;
    creator: {
        __typename?: "User";
    } & Pick<User, "id">;
};
export declare type WorkflowDefinitionConnectionFragment = {
    __typename: "WorkflowDefinitionConnection";
} & {
    nodes: Array<{
        __typename?: "WorkflowDefinition";
    } & WorkflowDefinitionFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type WorkflowStateConnectionFragment = {
    __typename: "WorkflowStateConnection";
} & {
    nodes: Array<{
        __typename?: "WorkflowState";
    } & WorkflowStateFragment>;
    pageInfo: {
        __typename?: "PageInfo";
    } & PageInfoFragment;
};
export declare type WorkflowStatePayloadFragment = {
    __typename: "WorkflowStatePayload";
} & Pick<WorkflowStatePayload, "lastSyncId" | "success"> & {
    workflowState: {
        __typename?: "WorkflowState";
    } & Pick<WorkflowState, "id">;
};
export declare type AirbyteIntegrationConnectMutationVariables = Exact<{
    input: AirbyteConfigurationInput;
}>;
export declare type AirbyteIntegrationConnectMutation = {
    __typename?: "Mutation";
} & {
    airbyteIntegrationConnect: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type CreateApiKeyMutationVariables = Exact<{
    input: ApiKeyCreateInput;
}>;
export declare type CreateApiKeyMutation = {
    __typename?: "Mutation";
} & {
    apiKeyCreate: {
        __typename?: "ApiKeyPayload";
    } & ApiKeyPayloadFragment;
};
export declare type DeleteApiKeyMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteApiKeyMutation = {
    __typename?: "Mutation";
} & {
    apiKeyDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type ArchiveAttachmentMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ArchiveAttachmentMutation = {
    __typename?: "Mutation";
} & {
    attachmentArchive: {
        __typename?: "AttachmentArchivePayload";
    } & AttachmentArchivePayloadFragment;
};
export declare type CreateAttachmentMutationVariables = Exact<{
    input: AttachmentCreateInput;
}>;
export declare type CreateAttachmentMutation = {
    __typename?: "Mutation";
} & {
    attachmentCreate: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type DeleteAttachmentMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteAttachmentMutation = {
    __typename?: "Mutation";
} & {
    attachmentDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type AttachmentLinkDiscordMutationVariables = Exact<{
    channelId: Scalars["String"];
    issueId: Scalars["String"];
    messageId: Scalars["String"];
    url: Scalars["String"];
}>;
export declare type AttachmentLinkDiscordMutation = {
    __typename?: "Mutation";
} & {
    attachmentLinkDiscord: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type AttachmentLinkFrontMutationVariables = Exact<{
    conversationId: Scalars["String"];
    issueId: Scalars["String"];
}>;
export declare type AttachmentLinkFrontMutation = {
    __typename?: "Mutation";
} & {
    attachmentLinkFront: {
        __typename?: "FrontAttachmentPayload";
    } & FrontAttachmentPayloadFragment;
};
export declare type AttachmentLinkIntercomMutationVariables = Exact<{
    conversationId: Scalars["String"];
    issueId: Scalars["String"];
}>;
export declare type AttachmentLinkIntercomMutation = {
    __typename?: "Mutation";
} & {
    attachmentLinkIntercom: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type AttachmentLinkJiraIssueMutationVariables = Exact<{
    issueId: Scalars["String"];
    jiraIssueId: Scalars["String"];
}>;
export declare type AttachmentLinkJiraIssueMutation = {
    __typename?: "Mutation";
} & {
    attachmentLinkJiraIssue: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type AttachmentLinkSlackMutationVariables = Exact<{
    channel: Scalars["String"];
    id?: Maybe<Scalars["String"]>;
    issueId: Scalars["String"];
    latest: Scalars["String"];
    title?: Maybe<Scalars["String"]>;
    ts?: Maybe<Scalars["String"]>;
    url: Scalars["String"];
}>;
export declare type AttachmentLinkSlackMutation = {
    __typename?: "Mutation";
} & {
    attachmentLinkSlack: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type AttachmentLinkUrlMutationVariables = Exact<{
    id?: Maybe<Scalars["String"]>;
    issueId: Scalars["String"];
    title?: Maybe<Scalars["String"]>;
    url: Scalars["String"];
}>;
export declare type AttachmentLinkUrlMutation = {
    __typename?: "Mutation";
} & {
    attachmentLinkURL: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type AttachmentLinkZendeskMutationVariables = Exact<{
    issueId: Scalars["String"];
    ticketId: Scalars["String"];
}>;
export declare type AttachmentLinkZendeskMutation = {
    __typename?: "Mutation";
} & {
    attachmentLinkZendesk: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type AttachmentUnsyncSlackMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type AttachmentUnsyncSlackMutation = {
    __typename?: "Mutation";
} & {
    attachmentUnsyncSlack: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type UpdateAttachmentMutationVariables = Exact<{
    id: Scalars["String"];
    input: AttachmentUpdateInput;
}>;
export declare type UpdateAttachmentMutation = {
    __typename?: "Mutation";
} & {
    attachmentUpdate: {
        __typename?: "AttachmentPayload";
    } & AttachmentPayloadFragment;
};
export declare type CreateCommentMutationVariables = Exact<{
    input: CommentCreateInput;
}>;
export declare type CreateCommentMutation = {
    __typename?: "Mutation";
} & {
    commentCreate: {
        __typename?: "CommentPayload";
    } & CommentPayloadFragment;
};
export declare type DeleteCommentMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteCommentMutation = {
    __typename?: "Mutation";
} & {
    commentDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type UpdateCommentMutationVariables = Exact<{
    id: Scalars["String"];
    input: CommentUpdateInput;
}>;
export declare type UpdateCommentMutation = {
    __typename?: "Mutation";
} & {
    commentUpdate: {
        __typename?: "CommentPayload";
    } & CommentPayloadFragment;
};
export declare type CreateContactMutationVariables = Exact<{
    input: ContactCreateInput;
}>;
export declare type CreateContactMutation = {
    __typename?: "Mutation";
} & {
    contactCreate: {
        __typename?: "ContactPayload";
    } & ContactPayloadFragment;
};
export declare type CreateCsvExportReportMutationVariables = Exact<{
    includePrivateTeamIds?: Maybe<Array<Scalars["String"]> | Scalars["String"]>;
}>;
export declare type CreateCsvExportReportMutation = {
    __typename?: "Mutation";
} & {
    createCsvExportReport: {
        __typename?: "CreateCsvExportReportPayload";
    } & CreateCsvExportReportPayloadFragment;
};
export declare type CreateOrganizationFromOnboardingMutationVariables = Exact<{
    input: CreateOrganizationInput;
    survey?: Maybe<OnboardingCustomerSurvey>;
}>;
export declare type CreateOrganizationFromOnboardingMutation = {
    __typename?: "Mutation";
} & {
    createOrganizationFromOnboarding: {
        __typename?: "CreateOrJoinOrganizationResponse";
    } & CreateOrJoinOrganizationResponseFragment;
};
export declare type CreateCustomViewMutationVariables = Exact<{
    input: CustomViewCreateInput;
}>;
export declare type CreateCustomViewMutation = {
    __typename?: "Mutation";
} & {
    customViewCreate: {
        __typename?: "CustomViewPayload";
    } & CustomViewPayloadFragment;
};
export declare type DeleteCustomViewMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteCustomViewMutation = {
    __typename?: "Mutation";
} & {
    customViewDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type UpdateCustomViewMutationVariables = Exact<{
    id: Scalars["String"];
    input: CustomViewUpdateInput;
}>;
export declare type UpdateCustomViewMutation = {
    __typename?: "Mutation";
} & {
    customViewUpdate: {
        __typename?: "CustomViewPayload";
    } & CustomViewPayloadFragment;
};
export declare type ArchiveCycleMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ArchiveCycleMutation = {
    __typename?: "Mutation";
} & {
    cycleArchive: {
        __typename?: "CycleArchivePayload";
    } & CycleArchivePayloadFragment;
};
export declare type CreateCycleMutationVariables = Exact<{
    input: CycleCreateInput;
}>;
export declare type CreateCycleMutation = {
    __typename?: "Mutation";
} & {
    cycleCreate: {
        __typename?: "CyclePayload";
    } & CyclePayloadFragment;
};
export declare type UpdateCycleMutationVariables = Exact<{
    id: Scalars["String"];
    input: CycleUpdateInput;
}>;
export declare type UpdateCycleMutation = {
    __typename?: "Mutation";
} & {
    cycleUpdate: {
        __typename?: "CyclePayload";
    } & CyclePayloadFragment;
};
export declare type CreateDocumentMutationVariables = Exact<{
    input: DocumentCreateInput;
}>;
export declare type CreateDocumentMutation = {
    __typename?: "Mutation";
} & {
    documentCreate: {
        __typename?: "DocumentPayload";
    } & DocumentPayloadFragment;
};
export declare type DeleteDocumentMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteDocumentMutation = {
    __typename?: "Mutation";
} & {
    documentDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type UpdateDocumentMutationVariables = Exact<{
    id: Scalars["String"];
    input: DocumentUpdateInput;
}>;
export declare type UpdateDocumentMutation = {
    __typename?: "Mutation";
} & {
    documentUpdate: {
        __typename?: "DocumentPayload";
    } & DocumentPayloadFragment;
};
export declare type EmailTokenUserAccountAuthMutationVariables = Exact<{
    input: TokenUserAccountAuthInput;
}>;
export declare type EmailTokenUserAccountAuthMutation = {
    __typename?: "Mutation";
} & {
    emailTokenUserAccountAuth: {
        __typename?: "AuthResolverResponse";
    } & AuthResolverResponseFragment;
};
export declare type EmailUnsubscribeMutationVariables = Exact<{
    input: EmailUnsubscribeInput;
}>;
export declare type EmailUnsubscribeMutation = {
    __typename?: "Mutation";
} & {
    emailUnsubscribe: {
        __typename?: "EmailUnsubscribePayload";
    } & EmailUnsubscribePayloadFragment;
};
export declare type EmailUserAccountAuthChallengeMutationVariables = Exact<{
    input: EmailUserAccountAuthChallengeInput;
}>;
export declare type EmailUserAccountAuthChallengeMutation = {
    __typename?: "Mutation";
} & {
    emailUserAccountAuthChallenge: {
        __typename?: "EmailUserAccountAuthChallengeResponse";
    } & EmailUserAccountAuthChallengeResponseFragment;
};
export declare type CreateEmojiMutationVariables = Exact<{
    input: EmojiCreateInput;
}>;
export declare type CreateEmojiMutation = {
    __typename?: "Mutation";
} & {
    emojiCreate: {
        __typename?: "EmojiPayload";
    } & EmojiPayloadFragment;
};
export declare type DeleteEmojiMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteEmojiMutation = {
    __typename?: "Mutation";
} & {
    emojiDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type CreateFavoriteMutationVariables = Exact<{
    input: FavoriteCreateInput;
}>;
export declare type CreateFavoriteMutation = {
    __typename?: "Mutation";
} & {
    favoriteCreate: {
        __typename?: "FavoritePayload";
    } & FavoritePayloadFragment;
};
export declare type DeleteFavoriteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteFavoriteMutation = {
    __typename?: "Mutation";
} & {
    favoriteDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type UpdateFavoriteMutationVariables = Exact<{
    id: Scalars["String"];
    input: FavoriteUpdateInput;
}>;
export declare type UpdateFavoriteMutation = {
    __typename?: "Mutation";
} & {
    favoriteUpdate: {
        __typename?: "FavoritePayload";
    } & FavoritePayloadFragment;
};
export declare type FileUploadMutationVariables = Exact<{
    contentType: Scalars["String"];
    filename: Scalars["String"];
    makePublic?: Maybe<Scalars["Boolean"]>;
    metaData?: Maybe<Scalars["JSON"]>;
    size: Scalars["Int"];
}>;
export declare type FileUploadMutation = {
    __typename?: "Mutation";
} & {
    fileUpload: {
        __typename?: "UploadPayload";
    } & UploadPayloadFragment;
};
export declare type GoogleUserAccountAuthMutationVariables = Exact<{
    input: GoogleUserAccountAuthInput;
}>;
export declare type GoogleUserAccountAuthMutation = {
    __typename?: "Mutation";
} & {
    googleUserAccountAuth: {
        __typename?: "AuthResolverResponse";
    } & AuthResolverResponseFragment;
};
export declare type ImageUploadFromUrlMutationVariables = Exact<{
    url: Scalars["String"];
}>;
export declare type ImageUploadFromUrlMutation = {
    __typename?: "Mutation";
} & {
    imageUploadFromUrl: {
        __typename?: "ImageUploadFromUrlPayload";
    } & ImageUploadFromUrlPayloadFragment;
};
export declare type ImportFileUploadMutationVariables = Exact<{
    contentType: Scalars["String"];
    filename: Scalars["String"];
    metaData?: Maybe<Scalars["JSON"]>;
    size: Scalars["Int"];
}>;
export declare type ImportFileUploadMutation = {
    __typename?: "Mutation";
} & {
    importFileUpload: {
        __typename?: "UploadPayload";
    } & UploadPayloadFragment;
};
export declare type DeleteIntegrationMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteIntegrationMutation = {
    __typename?: "Mutation";
} & {
    integrationDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type IntegrationDiscordMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationDiscordMutation = {
    __typename?: "Mutation";
} & {
    integrationDiscord: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationFigmaMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationFigmaMutation = {
    __typename?: "Mutation";
} & {
    integrationFigma: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationFrontMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationFrontMutation = {
    __typename?: "Mutation";
} & {
    integrationFront: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type CreateIntegrationGithubCommitMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type CreateIntegrationGithubCommitMutation = {
    __typename?: "Mutation";
} & {
    integrationGithubCommitCreate: {
        __typename?: "GitHubCommitIntegrationPayload";
    } & GitHubCommitIntegrationPayloadFragment;
};
export declare type IntegrationGithubConnectMutationVariables = Exact<{
    installationId: Scalars["String"];
}>;
export declare type IntegrationGithubConnectMutation = {
    __typename?: "Mutation";
} & {
    integrationGithubConnect: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationGitlabConnectMutationVariables = Exact<{
    accessToken: Scalars["String"];
    gitlabUrl: Scalars["String"];
}>;
export declare type IntegrationGitlabConnectMutation = {
    __typename?: "Mutation";
} & {
    integrationGitlabConnect: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationGoogleSheetsMutationVariables = Exact<{
    code: Scalars["String"];
}>;
export declare type IntegrationGoogleSheetsMutation = {
    __typename?: "Mutation";
} & {
    integrationGoogleSheets: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationIntercomMutationVariables = Exact<{
    code: Scalars["String"];
    domainUrl?: Maybe<Scalars["String"]>;
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationIntercomMutation = {
    __typename?: "Mutation";
} & {
    integrationIntercom: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type DeleteIntegrationIntercomMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type DeleteIntegrationIntercomMutation = {
    __typename?: "Mutation";
} & {
    integrationIntercomDelete: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type UpdateIntegrationIntercomSettingsMutationVariables = Exact<{
    input: IntercomSettingsInput;
}>;
export declare type UpdateIntegrationIntercomSettingsMutation = {
    __typename?: "Mutation";
} & {
    integrationIntercomSettingsUpdate: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationLoomMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type IntegrationLoomMutation = {
    __typename?: "Mutation";
} & {
    integrationLoom: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationRequestMutationVariables = Exact<{
    input: IntegrationRequestInput;
}>;
export declare type IntegrationRequestMutation = {
    __typename?: "Mutation";
} & {
    integrationRequest: {
        __typename?: "IntegrationRequestPayload";
    } & IntegrationRequestPayloadFragment;
};
export declare type IntegrationSentryConnectMutationVariables = Exact<{
    code: Scalars["String"];
    installationId: Scalars["String"];
    organizationSlug: Scalars["String"];
}>;
export declare type IntegrationSentryConnectMutation = {
    __typename?: "Mutation";
} & {
    integrationSentryConnect: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    shouldUseV2Auth?: Maybe<Scalars["Boolean"]>;
}>;
export declare type IntegrationSlackMutation = {
    __typename?: "Mutation";
} & {
    integrationSlack: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackAsksMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationSlackAsksMutation = {
    __typename?: "Mutation";
} & {
    integrationSlackAsks: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackImportEmojisMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationSlackImportEmojisMutation = {
    __typename?: "Mutation";
} & {
    integrationSlackImportEmojis: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackOrgProjectUpdatesPostMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationSlackOrgProjectUpdatesPostMutation = {
    __typename?: "Mutation";
} & {
    integrationSlackOrgProjectUpdatesPost: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackPersonalMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationSlackPersonalMutation = {
    __typename?: "Mutation";
} & {
    integrationSlackPersonal: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackPostMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    shouldUseV2Auth?: Maybe<Scalars["Boolean"]>;
    teamId: Scalars["String"];
}>;
export declare type IntegrationSlackPostMutation = {
    __typename?: "Mutation";
} & {
    integrationSlackPost: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationSlackProjectPostMutationVariables = Exact<{
    code: Scalars["String"];
    projectId: Scalars["String"];
    redirectUri: Scalars["String"];
    service: Scalars["String"];
}>;
export declare type IntegrationSlackProjectPostMutation = {
    __typename?: "Mutation";
} & {
    integrationSlackProjectPost: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type CreateIntegrationTemplateMutationVariables = Exact<{
    input: IntegrationTemplateCreateInput;
}>;
export declare type CreateIntegrationTemplateMutation = {
    __typename?: "Mutation";
} & {
    integrationTemplateCreate: {
        __typename?: "IntegrationTemplatePayload";
    } & IntegrationTemplatePayloadFragment;
};
export declare type DeleteIntegrationTemplateMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteIntegrationTemplateMutation = {
    __typename?: "Mutation";
} & {
    integrationTemplateDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type IntegrationUpdateSlackMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type IntegrationUpdateSlackMutation = {
    __typename?: "Mutation";
} & {
    integrationUpdateSlack: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type IntegrationZendeskMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    scope: Scalars["String"];
    subdomain: Scalars["String"];
}>;
export declare type IntegrationZendeskMutation = {
    __typename?: "Mutation";
} & {
    integrationZendesk: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type CreateIntegrationsSettingsMutationVariables = Exact<{
    input: IntegrationsSettingsCreateInput;
}>;
export declare type CreateIntegrationsSettingsMutation = {
    __typename?: "Mutation";
} & {
    integrationsSettingsCreate: {
        __typename?: "IntegrationsSettingsPayload";
    } & IntegrationsSettingsPayloadFragment;
};
export declare type UpdateIntegrationsSettingsMutationVariables = Exact<{
    id: Scalars["String"];
    input: IntegrationsSettingsUpdateInput;
}>;
export declare type UpdateIntegrationsSettingsMutation = {
    __typename?: "Mutation";
} & {
    integrationsSettingsUpdate: {
        __typename?: "IntegrationsSettingsPayload";
    } & IntegrationsSettingsPayloadFragment;
};
export declare type ArchiveIssueMutationVariables = Exact<{
    id: Scalars["String"];
    trash?: Maybe<Scalars["Boolean"]>;
}>;
export declare type ArchiveIssueMutation = {
    __typename?: "Mutation";
} & {
    issueArchive: {
        __typename?: "IssueArchivePayload";
    } & IssueArchivePayloadFragment;
};
export declare type UpdateIssueBatchMutationVariables = Exact<{
    ids: Array<Scalars["UUID"]> | Scalars["UUID"];
    input: IssueUpdateInput;
}>;
export declare type UpdateIssueBatchMutation = {
    __typename?: "Mutation";
} & {
    issueBatchUpdate: {
        __typename?: "IssueBatchPayload";
    } & IssueBatchPayloadFragment;
};
export declare type CreateIssueMutationVariables = Exact<{
    input: IssueCreateInput;
}>;
export declare type CreateIssueMutation = {
    __typename?: "Mutation";
} & {
    issueCreate: {
        __typename?: "IssuePayload";
    } & IssuePayloadFragment;
};
export declare type DeleteIssueMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteIssueMutation = {
    __typename?: "Mutation";
} & {
    issueDelete: {
        __typename?: "IssueArchivePayload";
    } & IssueArchivePayloadFragment;
};
export declare type IssueImportCreateAsanaMutationVariables = Exact<{
    asanaTeamName: Scalars["String"];
    asanaToken: Scalars["String"];
    id?: Maybe<Scalars["String"]>;
    includeClosedIssues?: Maybe<Scalars["Boolean"]>;
    instantProcess?: Maybe<Scalars["Boolean"]>;
    organizationId?: Maybe<Scalars["String"]>;
    teamId?: Maybe<Scalars["String"]>;
    teamName?: Maybe<Scalars["String"]>;
}>;
export declare type IssueImportCreateAsanaMutation = {
    __typename?: "Mutation";
} & {
    issueImportCreateAsana: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type IssueImportCreateCsvJiraMutationVariables = Exact<{
    csvUrl: Scalars["String"];
    jiraEmail?: Maybe<Scalars["String"]>;
    jiraHostname?: Maybe<Scalars["String"]>;
    jiraToken?: Maybe<Scalars["String"]>;
    organizationId?: Maybe<Scalars["String"]>;
    teamId?: Maybe<Scalars["String"]>;
    teamName?: Maybe<Scalars["String"]>;
}>;
export declare type IssueImportCreateCsvJiraMutation = {
    __typename?: "Mutation";
} & {
    issueImportCreateCSVJira: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type IssueImportCreateClubhouseMutationVariables = Exact<{
    clubhouseGroupName: Scalars["String"];
    clubhouseToken: Scalars["String"];
    id?: Maybe<Scalars["String"]>;
    includeClosedIssues?: Maybe<Scalars["Boolean"]>;
    instantProcess?: Maybe<Scalars["Boolean"]>;
    organizationId?: Maybe<Scalars["String"]>;
    teamId?: Maybe<Scalars["String"]>;
    teamName?: Maybe<Scalars["String"]>;
}>;
export declare type IssueImportCreateClubhouseMutation = {
    __typename?: "Mutation";
} & {
    issueImportCreateClubhouse: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type IssueImportCreateGithubMutationVariables = Exact<{
    githubRepoName: Scalars["String"];
    githubRepoOwner: Scalars["String"];
    githubShouldImportOrgProjects?: Maybe<Scalars["Boolean"]>;
    githubToken: Scalars["String"];
    id?: Maybe<Scalars["String"]>;
    includeClosedIssues?: Maybe<Scalars["Boolean"]>;
    instantProcess?: Maybe<Scalars["Boolean"]>;
    organizationId?: Maybe<Scalars["String"]>;
    teamId?: Maybe<Scalars["String"]>;
    teamName?: Maybe<Scalars["String"]>;
}>;
export declare type IssueImportCreateGithubMutation = {
    __typename?: "Mutation";
} & {
    issueImportCreateGithub: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type IssueImportCreateJiraMutationVariables = Exact<{
    id?: Maybe<Scalars["String"]>;
    includeClosedIssues?: Maybe<Scalars["Boolean"]>;
    instantProcess?: Maybe<Scalars["Boolean"]>;
    jiraEmail: Scalars["String"];
    jiraHostname: Scalars["String"];
    jiraProject: Scalars["String"];
    jiraToken: Scalars["String"];
    organizationId?: Maybe<Scalars["String"]>;
    teamId?: Maybe<Scalars["String"]>;
    teamName?: Maybe<Scalars["String"]>;
}>;
export declare type IssueImportCreateJiraMutation = {
    __typename?: "Mutation";
} & {
    issueImportCreateJira: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type DeleteIssueImportMutationVariables = Exact<{
    issueImportId: Scalars["String"];
}>;
export declare type DeleteIssueImportMutation = {
    __typename?: "Mutation";
} & {
    issueImportDelete: {
        __typename?: "IssueImportDeletePayload";
    } & IssueImportDeletePayloadFragment;
};
export declare type IssueImportProcessMutationVariables = Exact<{
    issueImportId: Scalars["String"];
    mapping: Scalars["JSONObject"];
}>;
export declare type IssueImportProcessMutation = {
    __typename?: "Mutation";
} & {
    issueImportProcess: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type UpdateIssueImportMutationVariables = Exact<{
    id: Scalars["String"];
    input: IssueImportUpdateInput;
}>;
export declare type UpdateIssueImportMutation = {
    __typename?: "Mutation";
} & {
    issueImportUpdate: {
        __typename?: "IssueImportPayload";
    } & IssueImportPayloadFragment;
};
export declare type CreateIssueLabelMutationVariables = Exact<{
    input: IssueLabelCreateInput;
    replaceTeamLabels?: Maybe<Scalars["Boolean"]>;
}>;
export declare type CreateIssueLabelMutation = {
    __typename?: "Mutation";
} & {
    issueLabelCreate: {
        __typename?: "IssueLabelPayload";
    } & IssueLabelPayloadFragment;
};
export declare type DeleteIssueLabelMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteIssueLabelMutation = {
    __typename?: "Mutation";
} & {
    issueLabelDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type UpdateIssueLabelMutationVariables = Exact<{
    id: Scalars["String"];
    input: IssueLabelUpdateInput;
}>;
export declare type UpdateIssueLabelMutation = {
    __typename?: "Mutation";
} & {
    issueLabelUpdate: {
        __typename?: "IssueLabelPayload";
    } & IssueLabelPayloadFragment;
};
export declare type CreateIssueRelationMutationVariables = Exact<{
    input: IssueRelationCreateInput;
}>;
export declare type CreateIssueRelationMutation = {
    __typename?: "Mutation";
} & {
    issueRelationCreate: {
        __typename?: "IssueRelationPayload";
    } & IssueRelationPayloadFragment;
};
export declare type DeleteIssueRelationMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteIssueRelationMutation = {
    __typename?: "Mutation";
} & {
    issueRelationDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type UpdateIssueRelationMutationVariables = Exact<{
    id: Scalars["String"];
    input: IssueRelationUpdateInput;
}>;
export declare type UpdateIssueRelationMutation = {
    __typename?: "Mutation";
} & {
    issueRelationUpdate: {
        __typename?: "IssueRelationPayload";
    } & IssueRelationPayloadFragment;
};
export declare type IssueReminderMutationVariables = Exact<{
    id: Scalars["String"];
    reminderAt: Scalars["DateTime"];
}>;
export declare type IssueReminderMutation = {
    __typename?: "Mutation";
} & {
    issueReminder: {
        __typename?: "IssuePayload";
    } & IssuePayloadFragment;
};
export declare type UnarchiveIssueMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UnarchiveIssueMutation = {
    __typename?: "Mutation";
} & {
    issueUnarchive: {
        __typename?: "IssueArchivePayload";
    } & IssueArchivePayloadFragment;
};
export declare type UpdateIssueMutationVariables = Exact<{
    id: Scalars["String"];
    input: IssueUpdateInput;
}>;
export declare type UpdateIssueMutation = {
    __typename?: "Mutation";
} & {
    issueUpdate: {
        __typename?: "IssuePayload";
    } & IssuePayloadFragment;
};
export declare type JoinOrganizationFromOnboardingMutationVariables = Exact<{
    input: JoinOrganizationInput;
}>;
export declare type JoinOrganizationFromOnboardingMutation = {
    __typename?: "Mutation";
} & {
    joinOrganizationFromOnboarding: {
        __typename?: "CreateOrJoinOrganizationResponse";
    } & CreateOrJoinOrganizationResponseFragment;
};
export declare type LeaveOrganizationMutationVariables = Exact<{
    organizationId: Scalars["String"];
}>;
export declare type LeaveOrganizationMutation = {
    __typename?: "Mutation";
} & {
    leaveOrganization: {
        __typename?: "CreateOrJoinOrganizationResponse";
    } & CreateOrJoinOrganizationResponseFragment;
};
export declare type LogoutMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type LogoutMutation = {
    __typename?: "Mutation";
} & {
    logout: {
        __typename?: "LogoutResponse";
    } & LogoutResponseFragment;
};
export declare type ArchiveNotificationMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ArchiveNotificationMutation = {
    __typename?: "Mutation";
} & {
    notificationArchive: {
        __typename?: "NotificationArchivePayload";
    } & NotificationArchivePayloadFragment;
};
export declare type NotificationArchiveAllMutationVariables = Exact<{
    input: NotificationEntityInput;
}>;
export declare type NotificationArchiveAllMutation = {
    __typename?: "Mutation";
} & {
    notificationArchiveAll: {
        __typename?: "NotificationBatchActionPayload";
    } & NotificationBatchActionPayloadFragment;
};
export declare type NotificationMarkReadAllMutationVariables = Exact<{
    input: NotificationEntityInput;
    readAt: Scalars["DateTime"];
}>;
export declare type NotificationMarkReadAllMutation = {
    __typename?: "Mutation";
} & {
    notificationMarkReadAll: {
        __typename?: "NotificationBatchActionPayload";
    } & NotificationBatchActionPayloadFragment;
};
export declare type NotificationMarkUnreadAllMutationVariables = Exact<{
    input: NotificationEntityInput;
}>;
export declare type NotificationMarkUnreadAllMutation = {
    __typename?: "Mutation";
} & {
    notificationMarkUnreadAll: {
        __typename?: "NotificationBatchActionPayload";
    } & NotificationBatchActionPayloadFragment;
};
export declare type NotificationSnoozeAllMutationVariables = Exact<{
    input: NotificationEntityInput;
    snoozedUntilAt: Scalars["DateTime"];
}>;
export declare type NotificationSnoozeAllMutation = {
    __typename?: "Mutation";
} & {
    notificationSnoozeAll: {
        __typename?: "NotificationBatchActionPayload";
    } & NotificationBatchActionPayloadFragment;
};
export declare type CreateNotificationSubscriptionMutationVariables = Exact<{
    input: NotificationSubscriptionCreateInput;
}>;
export declare type CreateNotificationSubscriptionMutation = {
    __typename?: "Mutation";
} & {
    notificationSubscriptionCreate: {
        __typename?: "NotificationSubscriptionPayload";
    } & NotificationSubscriptionPayloadFragment;
};
export declare type DeleteNotificationSubscriptionMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteNotificationSubscriptionMutation = {
    __typename?: "Mutation";
} & {
    notificationSubscriptionDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type UpdateNotificationSubscriptionMutationVariables = Exact<{
    id: Scalars["String"];
    input: NotificationSubscriptionUpdateInput;
}>;
export declare type UpdateNotificationSubscriptionMutation = {
    __typename?: "Mutation";
} & {
    notificationSubscriptionUpdate: {
        __typename?: "NotificationSubscriptionPayload";
    } & NotificationSubscriptionPayloadFragment;
};
export declare type UnarchiveNotificationMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UnarchiveNotificationMutation = {
    __typename?: "Mutation";
} & {
    notificationUnarchive: {
        __typename?: "NotificationArchivePayload";
    } & NotificationArchivePayloadFragment;
};
export declare type NotificationUnsnoozeAllMutationVariables = Exact<{
    input: NotificationEntityInput;
    unsnoozedAt: Scalars["DateTime"];
}>;
export declare type NotificationUnsnoozeAllMutation = {
    __typename?: "Mutation";
} & {
    notificationUnsnoozeAll: {
        __typename?: "NotificationBatchActionPayload";
    } & NotificationBatchActionPayloadFragment;
};
export declare type UpdateNotificationMutationVariables = Exact<{
    id: Scalars["String"];
    input: NotificationUpdateInput;
}>;
export declare type UpdateNotificationMutation = {
    __typename?: "Mutation";
} & {
    notificationUpdate: {
        __typename?: "NotificationPayload";
    } & NotificationPayloadFragment;
};
export declare type DeleteOrganizationCancelMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type DeleteOrganizationCancelMutation = {
    __typename?: "Mutation";
} & {
    organizationCancelDelete: {
        __typename?: "OrganizationCancelDeletePayload";
    } & OrganizationCancelDeletePayloadFragment;
};
export declare type DeleteOrganizationMutationVariables = Exact<{
    input: DeleteOrganizationInput;
}>;
export declare type DeleteOrganizationMutation = {
    __typename?: "Mutation";
} & {
    organizationDelete: {
        __typename?: "OrganizationDeletePayload";
    } & OrganizationDeletePayloadFragment;
};
export declare type OrganizationDeleteChallengeMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type OrganizationDeleteChallengeMutation = {
    __typename?: "Mutation";
} & {
    organizationDeleteChallenge: {
        __typename?: "OrganizationDeletePayload";
    } & OrganizationDeletePayloadFragment;
};
export declare type DeleteOrganizationDomainMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteOrganizationDomainMutation = {
    __typename?: "Mutation";
} & {
    organizationDomainDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type CreateOrganizationInviteMutationVariables = Exact<{
    input: OrganizationInviteCreateInput;
}>;
export declare type CreateOrganizationInviteMutation = {
    __typename?: "Mutation";
} & {
    organizationInviteCreate: {
        __typename?: "OrganizationInvitePayload";
    } & OrganizationInvitePayloadFragment;
};
export declare type DeleteOrganizationInviteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteOrganizationInviteMutation = {
    __typename?: "Mutation";
} & {
    organizationInviteDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type UpdateOrganizationInviteMutationVariables = Exact<{
    id: Scalars["String"];
    input: OrganizationInviteUpdateInput;
}>;
export declare type UpdateOrganizationInviteMutation = {
    __typename?: "Mutation";
} & {
    organizationInviteUpdate: {
        __typename?: "OrganizationInvitePayload";
    } & OrganizationInvitePayloadFragment;
};
export declare type OrganizationStartPlusTrialMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type OrganizationStartPlusTrialMutation = {
    __typename?: "Mutation";
} & {
    organizationStartPlusTrial: {
        __typename?: "OrganizationStartPlusTrialPayload";
    } & OrganizationStartPlusTrialPayloadFragment;
};
export declare type UpdateOrganizationMutationVariables = Exact<{
    input: UpdateOrganizationInput;
}>;
export declare type UpdateOrganizationMutation = {
    __typename?: "Mutation";
} & {
    organizationUpdate: {
        __typename?: "OrganizationPayload";
    } & OrganizationPayloadFragment;
};
export declare type ArchiveProjectMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ArchiveProjectMutation = {
    __typename?: "Mutation";
} & {
    projectArchive: {
        __typename?: "ProjectArchivePayload";
    } & ProjectArchivePayloadFragment;
};
export declare type CreateProjectMutationVariables = Exact<{
    input: ProjectCreateInput;
}>;
export declare type CreateProjectMutation = {
    __typename?: "Mutation";
} & {
    projectCreate: {
        __typename?: "ProjectPayload";
    } & ProjectPayloadFragment;
};
export declare type DeleteProjectMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteProjectMutation = {
    __typename?: "Mutation";
} & {
    projectDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type CreateProjectLinkMutationVariables = Exact<{
    input: ProjectLinkCreateInput;
}>;
export declare type CreateProjectLinkMutation = {
    __typename?: "Mutation";
} & {
    projectLinkCreate: {
        __typename?: "ProjectLinkPayload";
    } & ProjectLinkPayloadFragment;
};
export declare type DeleteProjectLinkMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteProjectLinkMutation = {
    __typename?: "Mutation";
} & {
    projectLinkDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type UpdateProjectLinkMutationVariables = Exact<{
    id: Scalars["String"];
    input: ProjectLinkUpdateInput;
}>;
export declare type UpdateProjectLinkMutation = {
    __typename?: "Mutation";
} & {
    projectLinkUpdate: {
        __typename?: "ProjectLinkPayload";
    } & ProjectLinkPayloadFragment;
};
export declare type CreateProjectMilestoneMutationVariables = Exact<{
    input: ProjectMilestoneCreateInput;
}>;
export declare type CreateProjectMilestoneMutation = {
    __typename?: "Mutation";
} & {
    projectMilestoneCreate: {
        __typename?: "ProjectMilestonePayload";
    } & ProjectMilestonePayloadFragment;
};
export declare type DeleteProjectMilestoneMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteProjectMilestoneMutation = {
    __typename?: "Mutation";
} & {
    projectMilestoneDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type UpdateProjectMilestoneMutationVariables = Exact<{
    id: Scalars["String"];
    input: ProjectMilestoneUpdateInput;
}>;
export declare type UpdateProjectMilestoneMutation = {
    __typename?: "Mutation";
} & {
    projectMilestoneUpdate: {
        __typename?: "ProjectMilestonePayload";
    } & ProjectMilestonePayloadFragment;
};
export declare type UnarchiveProjectMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UnarchiveProjectMutation = {
    __typename?: "Mutation";
} & {
    projectUnarchive: {
        __typename?: "ProjectArchivePayload";
    } & ProjectArchivePayloadFragment;
};
export declare type UpdateProjectMutationVariables = Exact<{
    id: Scalars["String"];
    input: ProjectUpdateInput;
}>;
export declare type UpdateProjectMutation = {
    __typename?: "Mutation";
} & {
    projectUpdate: {
        __typename?: "ProjectPayload";
    } & ProjectPayloadFragment;
};
export declare type CreateProjectUpdateMutationVariables = Exact<{
    input: ProjectUpdateCreateInput;
}>;
export declare type CreateProjectUpdateMutation = {
    __typename?: "Mutation";
} & {
    projectUpdateCreate: {
        __typename?: "ProjectUpdatePayload";
    } & ProjectUpdatePayloadFragment;
};
export declare type DeleteProjectUpdateMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteProjectUpdateMutation = {
    __typename?: "Mutation";
} & {
    projectUpdateDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type CreateProjectUpdateInteractionMutationVariables = Exact<{
    input: ProjectUpdateInteractionCreateInput;
}>;
export declare type CreateProjectUpdateInteractionMutation = {
    __typename?: "Mutation";
} & {
    projectUpdateInteractionCreate: {
        __typename?: "ProjectUpdateInteractionPayload";
    } & ProjectUpdateInteractionPayloadFragment;
};
export declare type ProjectUpdateMarkAsReadMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ProjectUpdateMarkAsReadMutation = {
    __typename?: "Mutation";
} & {
    projectUpdateMarkAsRead: {
        __typename?: "ProjectUpdateWithInteractionPayload";
    } & ProjectUpdateWithInteractionPayloadFragment;
};
export declare type UpdateProjectUpdateMutationVariables = Exact<{
    id: Scalars["String"];
    input: ProjectUpdateUpdateInput;
}>;
export declare type UpdateProjectUpdateMutation = {
    __typename?: "Mutation";
} & {
    projectUpdateUpdate: {
        __typename?: "ProjectUpdatePayload";
    } & ProjectUpdatePayloadFragment;
};
export declare type CreatePushSubscriptionMutationVariables = Exact<{
    input: PushSubscriptionCreateInput;
}>;
export declare type CreatePushSubscriptionMutation = {
    __typename?: "Mutation";
} & {
    pushSubscriptionCreate: {
        __typename?: "PushSubscriptionPayload";
    } & PushSubscriptionPayloadFragment;
};
export declare type DeletePushSubscriptionMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeletePushSubscriptionMutation = {
    __typename?: "Mutation";
} & {
    pushSubscriptionDelete: {
        __typename?: "PushSubscriptionPayload";
    } & PushSubscriptionPayloadFragment;
};
export declare type CreateReactionMutationVariables = Exact<{
    input: ReactionCreateInput;
}>;
export declare type CreateReactionMutation = {
    __typename?: "Mutation";
} & {
    reactionCreate: {
        __typename?: "ReactionPayload";
    } & ReactionPayloadFragment;
};
export declare type DeleteReactionMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteReactionMutation = {
    __typename?: "Mutation";
} & {
    reactionDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type RefreshGoogleSheetsDataMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type RefreshGoogleSheetsDataMutation = {
    __typename?: "Mutation";
} & {
    refreshGoogleSheetsData: {
        __typename?: "IntegrationPayload";
    } & IntegrationPayloadFragment;
};
export declare type ResendOrganizationInviteMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ResendOrganizationInviteMutation = {
    __typename?: "Mutation";
} & {
    resendOrganizationInvite: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type ArchiveRoadmapMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ArchiveRoadmapMutation = {
    __typename?: "Mutation";
} & {
    roadmapArchive: {
        __typename?: "RoadmapArchivePayload";
    } & RoadmapArchivePayloadFragment;
};
export declare type CreateRoadmapMutationVariables = Exact<{
    input: RoadmapCreateInput;
}>;
export declare type CreateRoadmapMutation = {
    __typename?: "Mutation";
} & {
    roadmapCreate: {
        __typename?: "RoadmapPayload";
    } & RoadmapPayloadFragment;
};
export declare type DeleteRoadmapMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteRoadmapMutation = {
    __typename?: "Mutation";
} & {
    roadmapDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type CreateRoadmapToProjectMutationVariables = Exact<{
    input: RoadmapToProjectCreateInput;
}>;
export declare type CreateRoadmapToProjectMutation = {
    __typename?: "Mutation";
} & {
    roadmapToProjectCreate: {
        __typename?: "RoadmapToProjectPayload";
    } & RoadmapToProjectPayloadFragment;
};
export declare type DeleteRoadmapToProjectMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteRoadmapToProjectMutation = {
    __typename?: "Mutation";
} & {
    roadmapToProjectDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type UpdateRoadmapToProjectMutationVariables = Exact<{
    id: Scalars["String"];
    input: RoadmapToProjectUpdateInput;
}>;
export declare type UpdateRoadmapToProjectMutation = {
    __typename?: "Mutation";
} & {
    roadmapToProjectUpdate: {
        __typename?: "RoadmapToProjectPayload";
    } & RoadmapToProjectPayloadFragment;
};
export declare type UnarchiveRoadmapMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UnarchiveRoadmapMutation = {
    __typename?: "Mutation";
} & {
    roadmapUnarchive: {
        __typename?: "RoadmapArchivePayload";
    } & RoadmapArchivePayloadFragment;
};
export declare type UpdateRoadmapMutationVariables = Exact<{
    id: Scalars["String"];
    input: RoadmapUpdateInput;
}>;
export declare type UpdateRoadmapMutation = {
    __typename?: "Mutation";
} & {
    roadmapUpdate: {
        __typename?: "RoadmapPayload";
    } & RoadmapPayloadFragment;
};
export declare type SamlTokenUserAccountAuthMutationVariables = Exact<{
    input: TokenUserAccountAuthInput;
}>;
export declare type SamlTokenUserAccountAuthMutation = {
    __typename?: "Mutation";
} & {
    samlTokenUserAccountAuth: {
        __typename?: "AuthResolverResponse";
    } & AuthResolverResponseFragment;
};
export declare type CreateTeamMutationVariables = Exact<{
    copySettingsFromTeamId?: Maybe<Scalars["String"]>;
    input: TeamCreateInput;
}>;
export declare type CreateTeamMutation = {
    __typename?: "Mutation";
} & {
    teamCreate: {
        __typename?: "TeamPayload";
    } & TeamPayloadFragment;
};
export declare type DeleteTeamCyclesMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteTeamCyclesMutation = {
    __typename?: "Mutation";
} & {
    teamCyclesDelete: {
        __typename?: "TeamPayload";
    } & TeamPayloadFragment;
};
export declare type DeleteTeamMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteTeamMutation = {
    __typename?: "Mutation";
} & {
    teamDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type DeleteTeamKeyMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteTeamKeyMutation = {
    __typename?: "Mutation";
} & {
    teamKeyDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type CreateTeamMembershipMutationVariables = Exact<{
    input: TeamMembershipCreateInput;
}>;
export declare type CreateTeamMembershipMutation = {
    __typename?: "Mutation";
} & {
    teamMembershipCreate: {
        __typename?: "TeamMembershipPayload";
    } & TeamMembershipPayloadFragment;
};
export declare type DeleteTeamMembershipMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteTeamMembershipMutation = {
    __typename?: "Mutation";
} & {
    teamMembershipDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type UpdateTeamMembershipMutationVariables = Exact<{
    id: Scalars["String"];
    input: TeamMembershipUpdateInput;
}>;
export declare type UpdateTeamMembershipMutation = {
    __typename?: "Mutation";
} & {
    teamMembershipUpdate: {
        __typename?: "TeamMembershipPayload";
    } & TeamMembershipPayloadFragment;
};
export declare type UpdateTeamMutationVariables = Exact<{
    id: Scalars["String"];
    input: TeamUpdateInput;
}>;
export declare type UpdateTeamMutation = {
    __typename?: "Mutation";
} & {
    teamUpdate: {
        __typename?: "TeamPayload";
    } & TeamPayloadFragment;
};
export declare type CreateTemplateMutationVariables = Exact<{
    input: TemplateCreateInput;
}>;
export declare type CreateTemplateMutation = {
    __typename?: "Mutation";
} & {
    templateCreate: {
        __typename?: "TemplatePayload";
    } & TemplatePayloadFragment;
};
export declare type DeleteTemplateMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteTemplateMutation = {
    __typename?: "Mutation";
} & {
    templateDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type UpdateTemplateMutationVariables = Exact<{
    id: Scalars["String"];
    input: TemplateUpdateInput;
}>;
export declare type UpdateTemplateMutation = {
    __typename?: "Mutation";
} & {
    templateUpdate: {
        __typename?: "TemplatePayload";
    } & TemplatePayloadFragment;
};
export declare type UserDemoteAdminMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UserDemoteAdminMutation = {
    __typename?: "Mutation";
} & {
    userDemoteAdmin: {
        __typename?: "UserAdminPayload";
    } & UserAdminPayloadFragment;
};
export declare type UserDemoteMemberMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UserDemoteMemberMutation = {
    __typename?: "Mutation";
} & {
    userDemoteMember: {
        __typename?: "UserAdminPayload";
    } & UserAdminPayloadFragment;
};
export declare type UserDiscordConnectMutationVariables = Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>;
export declare type UserDiscordConnectMutation = {
    __typename?: "Mutation";
} & {
    userDiscordConnect: {
        __typename?: "UserPayload";
    } & UserPayloadFragment;
};
export declare type UserExternalUserDisconnectMutationVariables = Exact<{
    service: Scalars["String"];
}>;
export declare type UserExternalUserDisconnectMutation = {
    __typename?: "Mutation";
} & {
    userExternalUserDisconnect: {
        __typename?: "UserPayload";
    } & UserPayloadFragment;
};
export declare type UpdateUserFlagMutationVariables = Exact<{
    flag: UserFlagType;
    operation: UserFlagUpdateOperation;
}>;
export declare type UpdateUserFlagMutation = {
    __typename?: "Mutation";
} & {
    userFlagUpdate: {
        __typename?: "UserSettingsFlagPayload";
    } & UserSettingsFlagPayloadFragment;
};
export declare type UserGitHubConnectMutationVariables = Exact<{
    code: Scalars["String"];
}>;
export declare type UserGitHubConnectMutation = {
    __typename?: "Mutation";
} & {
    userGitHubConnect: {
        __typename?: "UserPayload";
    } & UserPayloadFragment;
};
export declare type UserGoogleCalendarConnectMutationVariables = Exact<{
    code: Scalars["String"];
}>;
export declare type UserGoogleCalendarConnectMutation = {
    __typename?: "Mutation";
} & {
    userGoogleCalendarConnect: {
        __typename?: "UserPayload";
    } & UserPayloadFragment;
};
export declare type UserJiraConnectMutationVariables = Exact<{
    code: Scalars["String"];
}>;
export declare type UserJiraConnectMutation = {
    __typename?: "Mutation";
} & {
    userJiraConnect: {
        __typename?: "UserPayload";
    } & UserPayloadFragment;
};
export declare type UserPromoteAdminMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UserPromoteAdminMutation = {
    __typename?: "Mutation";
} & {
    userPromoteAdmin: {
        __typename?: "UserAdminPayload";
    } & UserAdminPayloadFragment;
};
export declare type UserPromoteMemberMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UserPromoteMemberMutation = {
    __typename?: "Mutation";
} & {
    userPromoteMember: {
        __typename?: "UserAdminPayload";
    } & UserAdminPayloadFragment;
};
export declare type UserSettingsFlagIncrementMutationVariables = Exact<{
    flag: Scalars["String"];
}>;
export declare type UserSettingsFlagIncrementMutation = {
    __typename?: "Mutation";
} & {
    userSettingsFlagIncrement: {
        __typename?: "UserSettingsFlagPayload";
    } & UserSettingsFlagPayloadFragment;
};
export declare type UserSettingsFlagsResetMutationVariables = Exact<{
    flags?: Maybe<Array<UserFlagType> | UserFlagType>;
}>;
export declare type UserSettingsFlagsResetMutation = {
    __typename?: "Mutation";
} & {
    userSettingsFlagsReset: {
        __typename?: "UserSettingsFlagsResetPayload";
    } & UserSettingsFlagsResetPayloadFragment;
};
export declare type UpdateUserSettingsMutationVariables = Exact<{
    id: Scalars["String"];
    input: UserSettingsUpdateInput;
}>;
export declare type UpdateUserSettingsMutation = {
    __typename?: "Mutation";
} & {
    userSettingsUpdate: {
        __typename?: "UserSettingsPayload";
    } & UserSettingsPayloadFragment;
};
export declare type SuspendUserMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type SuspendUserMutation = {
    __typename?: "Mutation";
} & {
    userSuspend: {
        __typename?: "UserAdminPayload";
    } & UserAdminPayloadFragment;
};
export declare type UnsuspendUserMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UnsuspendUserMutation = {
    __typename?: "Mutation";
} & {
    userUnsuspend: {
        __typename?: "UserAdminPayload";
    } & UserAdminPayloadFragment;
};
export declare type UpdateUserMutationVariables = Exact<{
    id: Scalars["String"];
    input: UpdateUserInput;
}>;
export declare type UpdateUserMutation = {
    __typename?: "Mutation";
} & {
    userUpdate: {
        __typename?: "UserPayload";
    } & UserPayloadFragment;
};
export declare type CreateViewPreferencesMutationVariables = Exact<{
    input: ViewPreferencesCreateInput;
}>;
export declare type CreateViewPreferencesMutation = {
    __typename?: "Mutation";
} & {
    viewPreferencesCreate: {
        __typename?: "ViewPreferencesPayload";
    } & ViewPreferencesPayloadFragment;
};
export declare type DeleteViewPreferencesMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteViewPreferencesMutation = {
    __typename?: "Mutation";
} & {
    viewPreferencesDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type UpdateViewPreferencesMutationVariables = Exact<{
    id: Scalars["String"];
    input: ViewPreferencesUpdateInput;
}>;
export declare type UpdateViewPreferencesMutation = {
    __typename?: "Mutation";
} & {
    viewPreferencesUpdate: {
        __typename?: "ViewPreferencesPayload";
    } & ViewPreferencesPayloadFragment;
};
export declare type CreateWebhookMutationVariables = Exact<{
    input: WebhookCreateInput;
}>;
export declare type CreateWebhookMutation = {
    __typename?: "Mutation";
} & {
    webhookCreate: {
        __typename?: "WebhookPayload";
    } & WebhookPayloadFragment;
};
export declare type DeleteWebhookMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DeleteWebhookMutation = {
    __typename?: "Mutation";
} & {
    webhookDelete: {
        __typename?: "DeletePayload";
    } & DeletePayloadFragment;
};
export declare type UpdateWebhookMutationVariables = Exact<{
    id: Scalars["String"];
    input: WebhookUpdateInput;
}>;
export declare type UpdateWebhookMutation = {
    __typename?: "Mutation";
} & {
    webhookUpdate: {
        __typename?: "WebhookPayload";
    } & WebhookPayloadFragment;
};
export declare type ArchiveWorkflowStateMutationVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ArchiveWorkflowStateMutation = {
    __typename?: "Mutation";
} & {
    workflowStateArchive: {
        __typename?: "WorkflowStateArchivePayload";
    } & WorkflowStateArchivePayloadFragment;
};
export declare type CreateWorkflowStateMutationVariables = Exact<{
    input: WorkflowStateCreateInput;
}>;
export declare type CreateWorkflowStateMutation = {
    __typename?: "Mutation";
} & {
    workflowStateCreate: {
        __typename?: "WorkflowStatePayload";
    } & WorkflowStatePayloadFragment;
};
export declare type UpdateWorkflowStateMutationVariables = Exact<{
    id: Scalars["String"];
    input: WorkflowStateUpdateInput;
}>;
export declare type UpdateWorkflowStateMutation = {
    __typename?: "Mutation";
} & {
    workflowStateUpdate: {
        __typename?: "WorkflowStatePayload";
    } & WorkflowStatePayloadFragment;
};
export declare type ProjectMilestoneQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ProjectMilestoneQuery = {
    __typename?: "Query";
} & {
    ProjectMilestone: {
        __typename?: "ProjectMilestone";
    } & ProjectMilestoneFragment;
};
export declare type ProjectMilestonesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<ProjectMilestoneFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type ProjectMilestonesQuery = {
    __typename?: "Query";
} & {
    ProjectMilestones: {
        __typename?: "ProjectMilestoneConnection";
    } & ProjectMilestoneConnectionFragment;
};
export declare type AdministrableTeamsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AdministrableTeamsQuery = {
    __typename?: "Query";
} & {
    administrableTeams: {
        __typename?: "TeamConnection";
    } & TeamConnectionFragment;
};
export declare type ApiKeysQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type ApiKeysQuery = {
    __typename?: "Query";
} & {
    apiKeys: {
        __typename?: "ApiKeyConnection";
    } & ApiKeyConnectionFragment;
};
export declare type ApplicationInfoQueryVariables = Exact<{
    clientId: Scalars["String"];
}>;
export declare type ApplicationInfoQuery = {
    __typename?: "Query";
} & {
    applicationInfo: {
        __typename?: "Application";
    } & ApplicationFragment;
};
export declare type ApplicationWithAuthorizationQueryVariables = Exact<{
    actor?: Maybe<Scalars["String"]>;
    clientId: Scalars["String"];
    redirectUri?: Maybe<Scalars["String"]>;
    scope: Array<Scalars["String"]> | Scalars["String"];
}>;
export declare type ApplicationWithAuthorizationQuery = {
    __typename?: "Query";
} & {
    applicationWithAuthorization: {
        __typename?: "UserAuthorizedApplication";
    } & UserAuthorizedApplicationFragment;
};
export declare type AttachmentQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type AttachmentQuery = {
    __typename?: "Query";
} & {
    attachment: {
        __typename?: "Attachment";
    } & AttachmentFragment;
};
export declare type AttachmentIssueQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type AttachmentIssueQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & IssueFragment;
};
export declare type AttachmentIssue_AttachmentsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<AttachmentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_AttachmentsQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        attachments: {
            __typename?: "AttachmentConnection";
        } & AttachmentConnectionFragment;
    };
};
export declare type AttachmentIssue_ChildrenQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_ChildrenQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        children: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type AttachmentIssue_CommentsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CommentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_CommentsQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        comments: {
            __typename?: "CommentConnection";
        } & CommentConnectionFragment;
    };
};
export declare type AttachmentIssue_HistoryQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_HistoryQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        history: {
            __typename?: "IssueHistoryConnection";
        } & IssueHistoryConnectionFragment;
    };
};
export declare type AttachmentIssue_InverseRelationsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_InverseRelationsQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        inverseRelations: {
            __typename?: "IssueRelationConnection";
        } & IssueRelationConnectionFragment;
    };
};
export declare type AttachmentIssue_LabelsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_LabelsQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        labels: {
            __typename?: "IssueLabelConnection";
        } & IssueLabelConnectionFragment;
    };
};
export declare type AttachmentIssue_RelationsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_RelationsQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        relations: {
            __typename?: "IssueRelationConnection";
        } & IssueRelationConnectionFragment;
    };
};
export declare type AttachmentIssue_SubscribersQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentIssue_SubscribersQuery = {
    __typename?: "Query";
} & {
    attachmentIssue: {
        __typename?: "Issue";
    } & {
        subscribers: {
            __typename?: "UserConnection";
        } & UserConnectionFragment;
    };
};
export declare type AttachmentsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<AttachmentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AttachmentsQuery = {
    __typename?: "Query";
} & {
    attachments: {
        __typename?: "AttachmentConnection";
    } & AttachmentConnectionFragment;
};
export declare type AttachmentsForUrlQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    url: Scalars["String"];
}>;
export declare type AttachmentsForUrlQuery = {
    __typename?: "Query";
} & {
    attachmentsForURL: {
        __typename?: "AttachmentConnection";
    } & AttachmentConnectionFragment;
};
export declare type AuditEntriesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<AuditEntryFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type AuditEntriesQuery = {
    __typename?: "Query";
} & {
    auditEntries: {
        __typename?: "AuditEntryConnection";
    } & AuditEntryConnectionFragment;
};
export declare type AuditEntryTypesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type AuditEntryTypesQuery = {
    __typename?: "Query";
} & {
    auditEntryTypes: Array<{
        __typename?: "AuditEntryType";
    } & AuditEntryTypeFragment>;
};
export declare type AvailableUsersQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type AvailableUsersQuery = {
    __typename?: "Query";
} & {
    availableUsers: {
        __typename?: "AuthResolverResponse";
    } & AuthResolverResponseFragment;
};
export declare type CommentQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type CommentQuery = {
    __typename?: "Query";
} & {
    comment: {
        __typename?: "Comment";
    } & CommentFragment;
};
export declare type Comment_ChildrenQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CommentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Comment_ChildrenQuery = {
    __typename?: "Query";
} & {
    comment: {
        __typename?: "Comment";
    } & {
        children: {
            __typename?: "CommentConnection";
        } & CommentConnectionFragment;
    };
};
export declare type CommentsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CommentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type CommentsQuery = {
    __typename?: "Query";
} & {
    comments: {
        __typename?: "CommentConnection";
    } & CommentConnectionFragment;
};
export declare type CustomViewQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type CustomViewQuery = {
    __typename?: "Query";
} & {
    customView: {
        __typename?: "CustomView";
    } & CustomViewFragment;
};
export declare type CustomViewsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type CustomViewsQuery = {
    __typename?: "Query";
} & {
    customViews: {
        __typename?: "CustomViewConnection";
    } & CustomViewConnectionFragment;
};
export declare type CycleQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type CycleQuery = {
    __typename?: "Query";
} & {
    cycle: {
        __typename?: "Cycle";
    } & CycleFragment;
};
export declare type Cycle_IssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Cycle_IssuesQuery = {
    __typename?: "Query";
} & {
    cycle: {
        __typename?: "Cycle";
    } & {
        issues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Cycle_UncompletedIssuesUponCloseQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Cycle_UncompletedIssuesUponCloseQuery = {
    __typename?: "Query";
} & {
    cycle: {
        __typename?: "Cycle";
    } & {
        uncompletedIssuesUponClose: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type CyclesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CycleFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type CyclesQuery = {
    __typename?: "Query";
} & {
    cycles: {
        __typename?: "CycleConnection";
    } & CycleConnectionFragment;
};
export declare type DocumentQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type DocumentQuery = {
    __typename?: "Query";
} & {
    document: {
        __typename?: "Document";
    } & DocumentFragment;
};
export declare type DocumentsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type DocumentsQuery = {
    __typename?: "Query";
} & {
    documents: {
        __typename?: "DocumentConnection";
    } & DocumentConnectionFragment;
};
export declare type EmbedInfoQueryVariables = Exact<{
    url: Scalars["String"];
}>;
export declare type EmbedInfoQuery = {
    __typename?: "Query";
} & {
    embedInfo: {
        __typename?: "EmbedPayload";
    } & EmbedPayloadFragment;
};
export declare type EmbedInfo_EmbedQueryVariables = Exact<{
    url: Scalars["String"];
}>;
export declare type EmbedInfo_EmbedQuery = {
    __typename?: "Query";
} & {
    embedInfo: {
        __typename?: "EmbedPayload";
    } & {
        embed?: Maybe<{
            __typename?: "Embed";
        } & EmbedFragment>;
    };
};
export declare type EmojiQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type EmojiQuery = {
    __typename?: "Query";
} & {
    emoji: {
        __typename?: "Emoji";
    } & EmojiFragment;
};
export declare type EmojisQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type EmojisQuery = {
    __typename?: "Query";
} & {
    emojis: {
        __typename?: "EmojiConnection";
    } & EmojiConnectionFragment;
};
export declare type FavoriteQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type FavoriteQuery = {
    __typename?: "Query";
} & {
    favorite: {
        __typename?: "Favorite";
    } & FavoriteFragment;
};
export declare type Favorite_ChildrenQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Favorite_ChildrenQuery = {
    __typename?: "Query";
} & {
    favorite: {
        __typename?: "Favorite";
    } & {
        children: {
            __typename?: "FavoriteConnection";
        } & FavoriteConnectionFragment;
    };
};
export declare type FavoritesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type FavoritesQuery = {
    __typename?: "Query";
} & {
    favorites: {
        __typename?: "FavoriteConnection";
    } & FavoriteConnectionFragment;
};
export declare type FigmaEmbedInfoQueryVariables = Exact<{
    fileId: Scalars["String"];
    nodeId?: Maybe<Scalars["String"]>;
}>;
export declare type FigmaEmbedInfoQuery = {
    __typename?: "Query";
} & {
    figmaEmbedInfo: {
        __typename?: "FigmaEmbedPayload";
    } & FigmaEmbedPayloadFragment;
};
export declare type FigmaEmbedInfo_FigmaEmbedQueryVariables = Exact<{
    fileId: Scalars["String"];
    nodeId?: Maybe<Scalars["String"]>;
}>;
export declare type FigmaEmbedInfo_FigmaEmbedQuery = {
    __typename?: "Query";
} & {
    figmaEmbedInfo: {
        __typename?: "FigmaEmbedPayload";
    } & {
        figmaEmbed?: Maybe<{
            __typename?: "FigmaEmbed";
        } & FigmaEmbedFragment>;
    };
};
export declare type IntegrationQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IntegrationQuery = {
    __typename?: "Query";
} & {
    integration: {
        __typename?: "Integration";
    } & IntegrationFragment;
};
export declare type IntegrationTemplateQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IntegrationTemplateQuery = {
    __typename?: "Query";
} & {
    integrationTemplate: {
        __typename?: "IntegrationTemplate";
    } & IntegrationTemplateFragment;
};
export declare type IntegrationTemplatesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IntegrationTemplatesQuery = {
    __typename?: "Query";
} & {
    integrationTemplates: {
        __typename?: "IntegrationTemplateConnection";
    } & IntegrationTemplateConnectionFragment;
};
export declare type IntegrationsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IntegrationsQuery = {
    __typename?: "Query";
} & {
    integrations: {
        __typename?: "IntegrationConnection";
    } & IntegrationConnectionFragment;
};
export declare type IntegrationsSettingsQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IntegrationsSettingsQuery = {
    __typename?: "Query";
} & {
    integrationsSettings: {
        __typename?: "IntegrationsSettings";
    } & IntegrationsSettingsFragment;
};
export declare type IssueQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IssueQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & IssueFragment;
};
export declare type Issue_AttachmentsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<AttachmentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_AttachmentsQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        attachments: {
            __typename?: "AttachmentConnection";
        } & AttachmentConnectionFragment;
    };
};
export declare type Issue_ChildrenQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_ChildrenQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        children: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Issue_CommentsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CommentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_CommentsQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        comments: {
            __typename?: "CommentConnection";
        } & CommentConnectionFragment;
    };
};
export declare type Issue_HistoryQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_HistoryQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        history: {
            __typename?: "IssueHistoryConnection";
        } & IssueHistoryConnectionFragment;
    };
};
export declare type Issue_InverseRelationsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_InverseRelationsQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        inverseRelations: {
            __typename?: "IssueRelationConnection";
        } & IssueRelationConnectionFragment;
    };
};
export declare type Issue_LabelsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_LabelsQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        labels: {
            __typename?: "IssueLabelConnection";
        } & IssueLabelConnectionFragment;
    };
};
export declare type Issue_RelationsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_RelationsQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        relations: {
            __typename?: "IssueRelationConnection";
        } & IssueRelationConnectionFragment;
    };
};
export declare type Issue_SubscribersQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Issue_SubscribersQuery = {
    __typename?: "Query";
} & {
    issue: {
        __typename?: "Issue";
    } & {
        subscribers: {
            __typename?: "UserConnection";
        } & UserConnectionFragment;
    };
};
export declare type IssueFigmaFileKeySearchQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    fileKey: Scalars["String"];
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueFigmaFileKeySearchQuery = {
    __typename?: "Query";
} & {
    issueFigmaFileKeySearch: {
        __typename?: "IssueConnection";
    } & IssueConnectionFragment;
};
export declare type IssueFilterSuggestionQueryVariables = Exact<{
    prompt: Scalars["String"];
}>;
export declare type IssueFilterSuggestionQuery = {
    __typename?: "Query";
} & {
    issueFilterSuggestion: {
        __typename?: "IssueFilterSuggestionPayload";
    } & IssueFilterSuggestionPayloadFragment;
};
export declare type IssueImportCheckCsvQueryVariables = Exact<{
    csvUrl: Scalars["String"];
    service: Scalars["String"];
}>;
export declare type IssueImportCheckCsvQuery = {
    __typename?: "Query";
} & {
    issueImportCheckCSV: {
        __typename?: "IssueImportCheckPayload";
    } & IssueImportCheckPayloadFragment;
};
export declare type IssueImportFinishGithubOAuthQueryVariables = Exact<{
    code: Scalars["String"];
}>;
export declare type IssueImportFinishGithubOAuthQuery = {
    __typename?: "Query";
} & {
    issueImportFinishGithubOAuth: {
        __typename?: "GithubOAuthTokenPayload";
    } & GithubOAuthTokenPayloadFragment;
};
export declare type IssueLabelQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IssueLabelQuery = {
    __typename?: "Query";
} & {
    issueLabel: {
        __typename?: "IssueLabel";
    } & IssueLabelFragment;
};
export declare type IssueLabel_ChildrenQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueLabel_ChildrenQuery = {
    __typename?: "Query";
} & {
    issueLabel: {
        __typename?: "IssueLabel";
    } & {
        children: {
            __typename?: "IssueLabelConnection";
        } & IssueLabelConnectionFragment;
    };
};
export declare type IssueLabel_IssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueLabel_IssuesQuery = {
    __typename?: "Query";
} & {
    issueLabel: {
        __typename?: "IssueLabel";
    } & {
        issues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type IssueLabelsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueLabelsQuery = {
    __typename?: "Query";
} & {
    issueLabels: {
        __typename?: "IssueLabelConnection";
    } & IssueLabelConnectionFragment;
};
export declare type IssuePriorityValuesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type IssuePriorityValuesQuery = {
    __typename?: "Query";
} & {
    issuePriorityValues: Array<{
        __typename?: "IssuePriorityValue";
    } & IssuePriorityValueFragment>;
};
export declare type IssueRelationQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type IssueRelationQuery = {
    __typename?: "Query";
} & {
    issueRelation: {
        __typename?: "IssueRelation";
    } & IssueRelationFragment;
};
export declare type IssueRelationsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueRelationsQuery = {
    __typename?: "Query";
} & {
    issueRelations: {
        __typename?: "IssueRelationConnection";
    } & IssueRelationConnectionFragment;
};
export declare type IssueSearchQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    query?: Maybe<Scalars["String"]>;
}>;
export declare type IssueSearchQuery = {
    __typename?: "Query";
} & {
    issueSearch: {
        __typename?: "IssueConnection";
    } & IssueConnectionFragment;
};
export declare type IssueVcsBranchSearchQueryVariables = Exact<{
    branchName: Scalars["String"];
}>;
export declare type IssueVcsBranchSearchQuery = {
    __typename?: "Query";
} & {
    issueVcsBranchSearch?: Maybe<{
        __typename?: "Issue";
    } & IssueFragment>;
};
export declare type IssueVcsBranchSearch_AttachmentsQueryVariables = Exact<{
    branchName: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<AttachmentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueVcsBranchSearch_AttachmentsQuery = {
    __typename?: "Query";
} & {
    issueVcsBranchSearch?: Maybe<{
        __typename?: "Issue";
    } & {
        attachments: {
            __typename?: "AttachmentConnection";
        } & AttachmentConnectionFragment;
    }>;
};
export declare type IssueVcsBranchSearch_ChildrenQueryVariables = Exact<{
    branchName: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueVcsBranchSearch_ChildrenQuery = {
    __typename?: "Query";
} & {
    issueVcsBranchSearch?: Maybe<{
        __typename?: "Issue";
    } & {
        children: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    }>;
};
export declare type IssueVcsBranchSearch_CommentsQueryVariables = Exact<{
    branchName: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CommentFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueVcsBranchSearch_CommentsQuery = {
    __typename?: "Query";
} & {
    issueVcsBranchSearch?: Maybe<{
        __typename?: "Issue";
    } & {
        comments: {
            __typename?: "CommentConnection";
        } & CommentConnectionFragment;
    }>;
};
export declare type IssueVcsBranchSearch_HistoryQueryVariables = Exact<{
    branchName: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueVcsBranchSearch_HistoryQuery = {
    __typename?: "Query";
} & {
    issueVcsBranchSearch?: Maybe<{
        __typename?: "Issue";
    } & {
        history: {
            __typename?: "IssueHistoryConnection";
        } & IssueHistoryConnectionFragment;
    }>;
};
export declare type IssueVcsBranchSearch_InverseRelationsQueryVariables = Exact<{
    branchName: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueVcsBranchSearch_InverseRelationsQuery = {
    __typename?: "Query";
} & {
    issueVcsBranchSearch?: Maybe<{
        __typename?: "Issue";
    } & {
        inverseRelations: {
            __typename?: "IssueRelationConnection";
        } & IssueRelationConnectionFragment;
    }>;
};
export declare type IssueVcsBranchSearch_LabelsQueryVariables = Exact<{
    branchName: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueVcsBranchSearch_LabelsQuery = {
    __typename?: "Query";
} & {
    issueVcsBranchSearch?: Maybe<{
        __typename?: "Issue";
    } & {
        labels: {
            __typename?: "IssueLabelConnection";
        } & IssueLabelConnectionFragment;
    }>;
};
export declare type IssueVcsBranchSearch_RelationsQueryVariables = Exact<{
    branchName: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueVcsBranchSearch_RelationsQuery = {
    __typename?: "Query";
} & {
    issueVcsBranchSearch?: Maybe<{
        __typename?: "Issue";
    } & {
        relations: {
            __typename?: "IssueRelationConnection";
        } & IssueRelationConnectionFragment;
    }>;
};
export declare type IssueVcsBranchSearch_SubscribersQueryVariables = Exact<{
    branchName: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssueVcsBranchSearch_SubscribersQuery = {
    __typename?: "Query";
} & {
    issueVcsBranchSearch?: Maybe<{
        __typename?: "Issue";
    } & {
        subscribers: {
            __typename?: "UserConnection";
        } & UserConnectionFragment;
    }>;
};
export declare type IssuesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type IssuesQuery = {
    __typename?: "Query";
} & {
    issues: {
        __typename?: "IssueConnection";
    } & IssueConnectionFragment;
};
export declare type NotificationQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type NotificationQuery = {
    __typename?: "Query";
} & {
    notification: ({
        __typename?: "IssueNotification";
    } & Notification_IssueNotification_Fragment) | ({
        __typename?: "OauthClientApprovalNotification";
    } & Notification_OauthClientApprovalNotification_Fragment) | ({
        __typename?: "ProjectNotification";
    } & Notification_ProjectNotification_Fragment);
};
export declare type NotificationSubscriptionQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type NotificationSubscriptionQuery = {
    __typename?: "Query";
} & {
    notificationSubscription: ({
        __typename?: "CustomViewNotificationSubscription";
    } & NotificationSubscription_CustomViewNotificationSubscription_Fragment) | ({
        __typename?: "CycleNotificationSubscription";
    } & NotificationSubscription_CycleNotificationSubscription_Fragment) | ({
        __typename?: "LabelNotificationSubscription";
    } & NotificationSubscription_LabelNotificationSubscription_Fragment) | ({
        __typename?: "ProjectNotificationSubscription";
    } & NotificationSubscription_ProjectNotificationSubscription_Fragment) | ({
        __typename?: "TeamNotificationSubscription";
    } & NotificationSubscription_TeamNotificationSubscription_Fragment) | ({
        __typename?: "UserNotificationSubscription";
    } & NotificationSubscription_UserNotificationSubscription_Fragment);
};
export declare type NotificationSubscriptionsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type NotificationSubscriptionsQuery = {
    __typename?: "Query";
} & {
    notificationSubscriptions: {
        __typename?: "NotificationSubscriptionConnection";
    } & NotificationSubscriptionConnectionFragment;
};
export declare type NotificationsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type NotificationsQuery = {
    __typename?: "Query";
} & {
    notifications: {
        __typename?: "NotificationConnection";
    } & NotificationConnectionFragment;
};
export declare type OrganizationQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type OrganizationQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & OrganizationFragment;
};
export declare type Organization_IntegrationsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Organization_IntegrationsQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & {
        integrations: {
            __typename?: "IntegrationConnection";
        } & IntegrationConnectionFragment;
    };
};
export declare type Organization_LabelsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Organization_LabelsQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & {
        labels: {
            __typename?: "IssueLabelConnection";
        } & IssueLabelConnectionFragment;
    };
};
export declare type Organization_SubscriptionQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type Organization_SubscriptionQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & {
        subscription?: Maybe<{
            __typename?: "PaidSubscription";
        } & PaidSubscriptionFragment>;
    };
};
export declare type Organization_TeamsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Organization_TeamsQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & {
        teams: {
            __typename?: "TeamConnection";
        } & TeamConnectionFragment;
    };
};
export declare type Organization_TemplatesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Organization_TemplatesQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & {
        templates: {
            __typename?: "TemplateConnection";
        } & TemplateConnectionFragment;
    };
};
export declare type Organization_UsersQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Organization_UsersQuery = {
    __typename?: "Query";
} & {
    organization: {
        __typename?: "Organization";
    } & {
        users: {
            __typename?: "UserConnection";
        } & UserConnectionFragment;
    };
};
export declare type OrganizationExistsQueryVariables = Exact<{
    urlKey: Scalars["String"];
}>;
export declare type OrganizationExistsQuery = {
    __typename?: "Query";
} & {
    organizationExists: {
        __typename?: "OrganizationExistsPayload";
    } & OrganizationExistsPayloadFragment;
};
export declare type OrganizationInviteQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type OrganizationInviteQuery = {
    __typename?: "Query";
} & {
    organizationInvite: {
        __typename?: "OrganizationInvite";
    } & OrganizationInviteFragment;
};
export declare type OrganizationInvitesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type OrganizationInvitesQuery = {
    __typename?: "Query";
} & {
    organizationInvites: {
        __typename?: "OrganizationInviteConnection";
    } & OrganizationInviteConnectionFragment;
};
export declare type ProjectQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ProjectQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & ProjectFragment;
};
export declare type Project_DocumentsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Project_DocumentsQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & {
        documents: {
            __typename?: "DocumentConnection";
        } & DocumentConnectionFragment;
    };
};
export declare type Project_IssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Project_IssuesQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & {
        issues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Project_LinksQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Project_LinksQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & {
        links: {
            __typename?: "ProjectLinkConnection";
        } & ProjectLinkConnectionFragment;
    };
};
export declare type Project_MembersQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Project_MembersQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & {
        members: {
            __typename?: "UserConnection";
        } & UserConnectionFragment;
    };
};
export declare type Project_ProjectMilestonesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Project_ProjectMilestonesQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & {
        projectMilestones: {
            __typename?: "ProjectMilestoneConnection";
        } & ProjectMilestoneConnectionFragment;
    };
};
export declare type Project_ProjectUpdatesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Project_ProjectUpdatesQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & {
        projectUpdates: {
            __typename?: "ProjectUpdateConnection";
        } & ProjectUpdateConnectionFragment;
    };
};
export declare type Project_TeamsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Project_TeamsQuery = {
    __typename?: "Query";
} & {
    project: {
        __typename?: "Project";
    } & {
        teams: {
            __typename?: "TeamConnection";
        } & TeamConnectionFragment;
    };
};
export declare type ProjectFilterSuggestionQueryVariables = Exact<{
    prompt: Scalars["String"];
}>;
export declare type ProjectFilterSuggestionQuery = {
    __typename?: "Query";
} & {
    projectFilterSuggestion: {
        __typename?: "ProjectFilterSuggestionPayload";
    } & ProjectFilterSuggestionPayloadFragment;
};
export declare type ProjectLinkQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ProjectLinkQuery = {
    __typename?: "Query";
} & {
    projectLink: {
        __typename?: "ProjectLink";
    } & ProjectLinkFragment;
};
export declare type ProjectLinksQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type ProjectLinksQuery = {
    __typename?: "Query";
} & {
    projectLinks: {
        __typename?: "ProjectLinkConnection";
    } & ProjectLinkConnectionFragment;
};
export declare type ProjectUpdateQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ProjectUpdateQuery = {
    __typename?: "Query";
} & {
    projectUpdate: {
        __typename?: "ProjectUpdate";
    } & ProjectUpdateFragment;
};
export declare type ProjectUpdateInteractionQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type ProjectUpdateInteractionQuery = {
    __typename?: "Query";
} & {
    projectUpdateInteraction: {
        __typename?: "ProjectUpdateInteraction";
    } & ProjectUpdateInteractionFragment;
};
export declare type ProjectUpdateInteractionsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type ProjectUpdateInteractionsQuery = {
    __typename?: "Query";
} & {
    projectUpdateInteractions: {
        __typename?: "ProjectUpdateInteractionConnection";
    } & ProjectUpdateInteractionConnectionFragment;
};
export declare type ProjectUpdatesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type ProjectUpdatesQuery = {
    __typename?: "Query";
} & {
    projectUpdates: {
        __typename?: "ProjectUpdateConnection";
    } & ProjectUpdateConnectionFragment;
};
export declare type ProjectsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<ProjectFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type ProjectsQuery = {
    __typename?: "Query";
} & {
    projects: {
        __typename?: "ProjectConnection";
    } & ProjectConnectionFragment;
};
export declare type PushSubscriptionTestQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type PushSubscriptionTestQuery = {
    __typename?: "Query";
} & {
    pushSubscriptionTest: {
        __typename?: "PushSubscriptionTestPayload";
    } & PushSubscriptionTestPayloadFragment;
};
export declare type RateLimitStatusQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type RateLimitStatusQuery = {
    __typename?: "Query";
} & {
    rateLimitStatus: {
        __typename?: "RateLimitPayload";
    } & RateLimitPayloadFragment;
};
export declare type RoadmapQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type RoadmapQuery = {
    __typename?: "Query";
} & {
    roadmap: {
        __typename?: "Roadmap";
    } & RoadmapFragment;
};
export declare type Roadmap_ProjectsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<ProjectFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Roadmap_ProjectsQuery = {
    __typename?: "Query";
} & {
    roadmap: {
        __typename?: "Roadmap";
    } & {
        projects: {
            __typename?: "ProjectConnection";
        } & ProjectConnectionFragment;
    };
};
export declare type RoadmapToProjectQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type RoadmapToProjectQuery = {
    __typename?: "Query";
} & {
    roadmapToProject: {
        __typename?: "RoadmapToProject";
    } & RoadmapToProjectFragment;
};
export declare type RoadmapToProjectsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type RoadmapToProjectsQuery = {
    __typename?: "Query";
} & {
    roadmapToProjects: {
        __typename?: "RoadmapToProjectConnection";
    } & RoadmapToProjectConnectionFragment;
};
export declare type RoadmapsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type RoadmapsQuery = {
    __typename?: "Query";
} & {
    roadmaps: {
        __typename?: "RoadmapConnection";
    } & RoadmapConnectionFragment;
};
export declare type SearchDocumentsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    term: Scalars["String"];
}>;
export declare type SearchDocumentsQuery = {
    __typename?: "Query";
} & {
    searchDocuments: {
        __typename?: "DocumentSearchPayload";
    } & DocumentSearchPayloadFragment;
};
export declare type SearchDocuments_ArchivePayloadQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    term: Scalars["String"];
}>;
export declare type SearchDocuments_ArchivePayloadQuery = {
    __typename?: "Query";
} & {
    searchDocuments: {
        __typename?: "DocumentSearchPayload";
    } & {
        archivePayload: {
            __typename?: "ArchiveResponse";
        } & ArchiveResponseFragment;
    };
};
export declare type SearchIssuesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    term: Scalars["String"];
}>;
export declare type SearchIssuesQuery = {
    __typename?: "Query";
} & {
    searchIssues: {
        __typename?: "IssueSearchPayload";
    } & IssueSearchPayloadFragment;
};
export declare type SearchIssues_ArchivePayloadQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    term: Scalars["String"];
}>;
export declare type SearchIssues_ArchivePayloadQuery = {
    __typename?: "Query";
} & {
    searchIssues: {
        __typename?: "IssueSearchPayload";
    } & {
        archivePayload: {
            __typename?: "ArchiveResponse";
        } & ArchiveResponseFragment;
    };
};
export declare type SearchProjectsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    term: Scalars["String"];
}>;
export declare type SearchProjectsQuery = {
    __typename?: "Query";
} & {
    searchProjects: {
        __typename?: "ProjectSearchPayload";
    } & ProjectSearchPayloadFragment;
};
export declare type SearchProjects_ArchivePayloadQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
    term: Scalars["String"];
}>;
export declare type SearchProjects_ArchivePayloadQuery = {
    __typename?: "Query";
} & {
    searchProjects: {
        __typename?: "ProjectSearchPayload";
    } & {
        archivePayload: {
            __typename?: "ArchiveResponse";
        } & ArchiveResponseFragment;
    };
};
export declare type SsoUrlFromEmailQueryVariables = Exact<{
    email: Scalars["String"];
    isDesktop?: Maybe<Scalars["Boolean"]>;
}>;
export declare type SsoUrlFromEmailQuery = {
    __typename?: "Query";
} & {
    ssoUrlFromEmail: {
        __typename?: "SsoUrlFromEmailResponse";
    } & SsoUrlFromEmailResponseFragment;
};
export declare type TeamQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TeamQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & TeamFragment;
};
export declare type Team_CyclesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<CycleFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_CyclesQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        cycles: {
            __typename?: "CycleConnection";
        } & CycleConnectionFragment;
    };
};
export declare type Team_IssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_IssuesQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        issues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Team_LabelsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueLabelFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_LabelsQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        labels: {
            __typename?: "IssueLabelConnection";
        } & IssueLabelConnectionFragment;
    };
};
export declare type Team_MembersQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_MembersQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        members: {
            __typename?: "UserConnection";
        } & UserConnectionFragment;
    };
};
export declare type Team_MembershipsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_MembershipsQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        memberships: {
            __typename?: "TeamMembershipConnection";
        } & TeamMembershipConnectionFragment;
    };
};
export declare type Team_ProjectsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<ProjectFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_ProjectsQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        projects: {
            __typename?: "ProjectConnection";
        } & ProjectConnectionFragment;
    };
};
export declare type Team_StatesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<WorkflowStateFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_StatesQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        states: {
            __typename?: "WorkflowStateConnection";
        } & WorkflowStateConnectionFragment;
    };
};
export declare type Team_TemplatesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_TemplatesQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        templates: {
            __typename?: "TemplateConnection";
        } & TemplateConnectionFragment;
    };
};
export declare type Team_WebhooksQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Team_WebhooksQuery = {
    __typename?: "Query";
} & {
    team: {
        __typename?: "Team";
    } & {
        webhooks: {
            __typename?: "WebhookConnection";
        } & WebhookConnectionFragment;
    };
};
export declare type TeamMembershipQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TeamMembershipQuery = {
    __typename?: "Query";
} & {
    teamMembership: {
        __typename?: "TeamMembership";
    } & TeamMembershipFragment;
};
export declare type TeamMembershipsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type TeamMembershipsQuery = {
    __typename?: "Query";
} & {
    teamMemberships: {
        __typename?: "TeamMembershipConnection";
    } & TeamMembershipConnectionFragment;
};
export declare type TeamsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type TeamsQuery = {
    __typename?: "Query";
} & {
    teams: {
        __typename?: "TeamConnection";
    } & TeamConnectionFragment;
};
export declare type TemplateQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type TemplateQuery = {
    __typename?: "Query";
} & {
    template: {
        __typename?: "Template";
    } & TemplateFragment;
};
export declare type TemplatesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type TemplatesQuery = {
    __typename?: "Query";
} & {
    templates: Array<{
        __typename?: "Template";
    } & TemplateFragment>;
};
export declare type TemplatesForIntegrationQueryVariables = Exact<{
    integrationType: Scalars["String"];
}>;
export declare type TemplatesForIntegrationQuery = {
    __typename?: "Query";
} & {
    templatesForIntegration: Array<{
        __typename?: "Template";
    } & TemplateFragment>;
};
export declare type UserQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type UserQuery = {
    __typename?: "Query";
} & {
    user: {
        __typename?: "User";
    } & UserFragment;
};
export declare type User_AssignedIssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type User_AssignedIssuesQuery = {
    __typename?: "Query";
} & {
    user: {
        __typename?: "User";
    } & {
        assignedIssues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type User_CreatedIssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type User_CreatedIssuesQuery = {
    __typename?: "Query";
} & {
    user: {
        __typename?: "User";
    } & {
        createdIssues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type User_TeamMembershipsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type User_TeamMembershipsQuery = {
    __typename?: "Query";
} & {
    user: {
        __typename?: "User";
    } & {
        teamMemberships: {
            __typename?: "TeamMembershipConnection";
        } & TeamMembershipConnectionFragment;
    };
};
export declare type User_TeamsQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type User_TeamsQuery = {
    __typename?: "Query";
} & {
    user: {
        __typename?: "User";
    } & {
        teams: {
            __typename?: "TeamConnection";
        } & TeamConnectionFragment;
    };
};
export declare type UserSettingsQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type UserSettingsQuery = {
    __typename?: "Query";
} & {
    userSettings: {
        __typename?: "UserSettings";
    } & UserSettingsFragment;
};
export declare type UsersQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<UserFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    includeDisabled?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type UsersQuery = {
    __typename?: "Query";
} & {
    users: {
        __typename?: "UserConnection";
    } & UserConnectionFragment;
};
export declare type ViewerQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type ViewerQuery = {
    __typename?: "Query";
} & {
    viewer: {
        __typename?: "User";
    } & UserFragment;
};
export declare type Viewer_AssignedIssuesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Viewer_AssignedIssuesQuery = {
    __typename?: "Query";
} & {
    viewer: {
        __typename?: "User";
    } & {
        assignedIssues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Viewer_CreatedIssuesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Viewer_CreatedIssuesQuery = {
    __typename?: "Query";
} & {
    viewer: {
        __typename?: "User";
    } & {
        createdIssues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type Viewer_TeamMembershipsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Viewer_TeamMembershipsQuery = {
    __typename?: "Query";
} & {
    viewer: {
        __typename?: "User";
    } & {
        teamMemberships: {
            __typename?: "TeamMembershipConnection";
        } & TeamMembershipConnectionFragment;
    };
};
export declare type Viewer_TeamsQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<TeamFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type Viewer_TeamsQuery = {
    __typename?: "Query";
} & {
    viewer: {
        __typename?: "User";
    } & {
        teams: {
            __typename?: "TeamConnection";
        } & TeamConnectionFragment;
    };
};
export declare type WebhookQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type WebhookQuery = {
    __typename?: "Query";
} & {
    webhook: {
        __typename?: "Webhook";
    } & WebhookFragment;
};
export declare type WebhooksQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type WebhooksQuery = {
    __typename?: "Query";
} & {
    webhooks: {
        __typename?: "WebhookConnection";
    } & WebhookConnectionFragment;
};
export declare type WorkflowStateQueryVariables = Exact<{
    id: Scalars["String"];
}>;
export declare type WorkflowStateQuery = {
    __typename?: "Query";
} & {
    workflowState: {
        __typename?: "WorkflowState";
    } & WorkflowStateFragment;
};
export declare type WorkflowState_IssuesQueryVariables = Exact<{
    id: Scalars["String"];
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<IssueFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type WorkflowState_IssuesQuery = {
    __typename?: "Query";
} & {
    workflowState: {
        __typename?: "WorkflowState";
    } & {
        issues: {
            __typename?: "IssueConnection";
        } & IssueConnectionFragment;
    };
};
export declare type WorkflowStatesQueryVariables = Exact<{
    after?: Maybe<Scalars["String"]>;
    before?: Maybe<Scalars["String"]>;
    filter?: Maybe<WorkflowStateFilter>;
    first?: Maybe<Scalars["Int"]>;
    includeArchived?: Maybe<Scalars["Boolean"]>;
    last?: Maybe<Scalars["Int"]>;
    orderBy?: Maybe<PaginationOrderBy>;
}>;
export declare type WorkflowStatesQuery = {
    __typename?: "Query";
} & {
    workflowStates: {
        __typename?: "WorkflowStateConnection";
    } & WorkflowStateConnectionFragment;
};
export declare const EntityFragmentDoc: DocumentNode<EntityFragment, unknown>;
export declare const CustomViewNotificationSubscriptionFragmentDoc: DocumentNode<CustomViewNotificationSubscriptionFragment, unknown>;
export declare const CycleNotificationSubscriptionFragmentDoc: DocumentNode<CycleNotificationSubscriptionFragment, unknown>;
export declare const DocumentContentFragmentDoc: DocumentNode<DocumentContentFragment, unknown>;
export declare const AttachmentArchivePayloadFragmentDoc: DocumentNode<AttachmentArchivePayloadFragment, unknown>;
export declare const CycleArchivePayloadFragmentDoc: DocumentNode<CycleArchivePayloadFragment, unknown>;
export declare const DeletePayloadFragmentDoc: DocumentNode<DeletePayloadFragment, unknown>;
export declare const IssueArchivePayloadFragmentDoc: DocumentNode<IssueArchivePayloadFragment, unknown>;
export declare const IssueNotificationFragmentDoc: DocumentNode<IssueNotificationFragment, unknown>;
export declare const OauthClientApprovalFragmentDoc: DocumentNode<OauthClientApprovalFragment, unknown>;
export declare const OauthClientApprovalNotificationFragmentDoc: DocumentNode<OauthClientApprovalNotificationFragment, unknown>;
export declare const ProjectNotificationFragmentDoc: DocumentNode<ProjectNotificationFragment, unknown>;
export declare const NotificationFragmentDoc: DocumentNode<NotificationFragment, unknown>;
export declare const NotificationArchivePayloadFragmentDoc: DocumentNode<NotificationArchivePayloadFragment, unknown>;
export declare const ProjectArchivePayloadFragmentDoc: DocumentNode<ProjectArchivePayloadFragment, unknown>;
export declare const RoadmapArchivePayloadFragmentDoc: DocumentNode<RoadmapArchivePayloadFragment, unknown>;
export declare const WorkflowStateArchivePayloadFragmentDoc: DocumentNode<WorkflowStateArchivePayloadFragment, unknown>;
export declare const ArchivePayloadFragmentDoc: DocumentNode<ArchivePayloadFragment, unknown>;
export declare const LabelNotificationSubscriptionFragmentDoc: DocumentNode<LabelNotificationSubscriptionFragment, unknown>;
export declare const ProjectNotificationSubscriptionFragmentDoc: DocumentNode<ProjectNotificationSubscriptionFragment, unknown>;
export declare const TeamNotificationSubscriptionFragmentDoc: DocumentNode<TeamNotificationSubscriptionFragment, unknown>;
export declare const TemplateFragmentDoc: DocumentNode<TemplateFragment, unknown>;
export declare const UserFragmentDoc: DocumentNode<UserFragment, unknown>;
export declare const UserAccountFragmentDoc: DocumentNode<UserAccountFragment, unknown>;
export declare const UserNotificationSubscriptionFragmentDoc: DocumentNode<UserNotificationSubscriptionFragment, unknown>;
export declare const SyncResponseFragmentDoc: DocumentNode<SyncResponseFragment, unknown>;
export declare const OrganizationDomainFragmentDoc: DocumentNode<OrganizationDomainFragment, unknown>;
export declare const GithubRepoFragmentDoc: DocumentNode<GithubRepoFragment, unknown>;
export declare const GithubOrgFragmentDoc: DocumentNode<GithubOrgFragment, unknown>;
export declare const GithubOAuthTokenPayloadFragmentDoc: DocumentNode<GithubOAuthTokenPayloadFragment, unknown>;
export declare const UserAuthorizedApplicationFragmentDoc: DocumentNode<UserAuthorizedApplicationFragment, unknown>;
export declare const ApplicationFragmentDoc: DocumentNode<ApplicationFragment, unknown>;
export declare const FrontSettingsFragmentDoc: DocumentNode<FrontSettingsFragment, unknown>;
export declare const GitHubSettingsFragmentDoc: DocumentNode<GitHubSettingsFragment, unknown>;
export declare const GoogleSheetsSettingsFragmentDoc: DocumentNode<GoogleSheetsSettingsFragment, unknown>;
export declare const IntercomSettingsFragmentDoc: DocumentNode<IntercomSettingsFragment, unknown>;
export declare const JiraProjectDataFragmentDoc: DocumentNode<JiraProjectDataFragment, unknown>;
export declare const JiraLinearMappingFragmentDoc: DocumentNode<JiraLinearMappingFragment, unknown>;
export declare const JiraSettingsFragmentDoc: DocumentNode<JiraSettingsFragment, unknown>;
export declare const NotionSettingsFragmentDoc: DocumentNode<NotionSettingsFragment, unknown>;
export declare const PagerDutyScheduleMappingFragmentDoc: DocumentNode<PagerDutyScheduleMappingFragment, unknown>;
export declare const PagerDutySettingsFragmentDoc: DocumentNode<PagerDutySettingsFragment, unknown>;
export declare const SentrySettingsFragmentDoc: DocumentNode<SentrySettingsFragment, unknown>;
export declare const SlackPostSettingsFragmentDoc: DocumentNode<SlackPostSettingsFragment, unknown>;
export declare const ZendeskSettingsFragmentDoc: DocumentNode<ZendeskSettingsFragment, unknown>;
export declare const IntegrationSettingsFragmentDoc: DocumentNode<IntegrationSettingsFragment, unknown>;
export declare const SamlConfigurationPayloadFragmentDoc: DocumentNode<SamlConfigurationPayloadFragment, unknown>;
export declare const UserSettingsFragmentDoc: DocumentNode<UserSettingsFragment, unknown>;
export declare const ApiKeyFragmentDoc: DocumentNode<ApiKeyFragment, unknown>;
export declare const PageInfoFragmentDoc: DocumentNode<PageInfoFragment, unknown>;
export declare const ApiKeyConnectionFragmentDoc: DocumentNode<ApiKeyConnectionFragment, unknown>;
export declare const ApiKeyPayloadFragmentDoc: DocumentNode<ApiKeyPayloadFragment, unknown>;
export declare const AttachmentFragmentDoc: DocumentNode<AttachmentFragment, unknown>;
export declare const AttachmentConnectionFragmentDoc: DocumentNode<AttachmentConnectionFragment, unknown>;
export declare const AttachmentPayloadFragmentDoc: DocumentNode<AttachmentPayloadFragment, unknown>;
export declare const AttachmentSourcesPayloadFragmentDoc: DocumentNode<AttachmentSourcesPayloadFragment, unknown>;
export declare const AuditEntryFragmentDoc: DocumentNode<AuditEntryFragment, unknown>;
export declare const AuditEntryConnectionFragmentDoc: DocumentNode<AuditEntryConnectionFragment, unknown>;
export declare const AuditEntryTypeFragmentDoc: DocumentNode<AuditEntryTypeFragment, unknown>;
export declare const PaidSubscriptionFragmentDoc: DocumentNode<PaidSubscriptionFragment, unknown>;
export declare const OrganizationFragmentDoc: DocumentNode<OrganizationFragment, unknown>;
export declare const AuthResolverResponseFragmentDoc: DocumentNode<AuthResolverResponseFragment, unknown>;
export declare const CommentFragmentDoc: DocumentNode<CommentFragment, unknown>;
export declare const CommentConnectionFragmentDoc: DocumentNode<CommentConnectionFragment, unknown>;
export declare const CommentPayloadFragmentDoc: DocumentNode<CommentPayloadFragment, unknown>;
export declare const CompanyFragmentDoc: DocumentNode<CompanyFragment, unknown>;
export declare const CompanyConnectionFragmentDoc: DocumentNode<CompanyConnectionFragment, unknown>;
export declare const ContactPayloadFragmentDoc: DocumentNode<ContactPayloadFragment, unknown>;
export declare const CreateCsvExportReportPayloadFragmentDoc: DocumentNode<CreateCsvExportReportPayloadFragment, unknown>;
export declare const CreateOrJoinOrganizationResponseFragmentDoc: DocumentNode<CreateOrJoinOrganizationResponseFragment, unknown>;
export declare const CustomViewFragmentDoc: DocumentNode<CustomViewFragment, unknown>;
export declare const CustomViewConnectionFragmentDoc: DocumentNode<CustomViewConnectionFragment, unknown>;
export declare const CustomViewPayloadFragmentDoc: DocumentNode<CustomViewPayloadFragment, unknown>;
export declare const CustomViewSuggestionPayloadFragmentDoc: DocumentNode<CustomViewSuggestionPayloadFragment, unknown>;
export declare const CycleFragmentDoc: DocumentNode<CycleFragment, unknown>;
export declare const CycleConnectionFragmentDoc: DocumentNode<CycleConnectionFragment, unknown>;
export declare const CyclePayloadFragmentDoc: DocumentNode<CyclePayloadFragment, unknown>;
export declare const DocumentFragmentDoc: DocumentNode<DocumentFragment, unknown>;
export declare const DocumentConnectionFragmentDoc: DocumentNode<DocumentConnectionFragment, unknown>;
export declare const DocumentPayloadFragmentDoc: DocumentNode<DocumentPayloadFragment, unknown>;
export declare const ArchiveResponseFragmentDoc: DocumentNode<ArchiveResponseFragment, unknown>;
export declare const DocumentSearchResultFragmentDoc: DocumentNode<DocumentSearchResultFragment, unknown>;
export declare const DocumentSearchPayloadFragmentDoc: DocumentNode<DocumentSearchPayloadFragment, unknown>;
export declare const DocumentSearchResultConnectionFragmentDoc: DocumentNode<DocumentSearchResultConnectionFragment, unknown>;
export declare const EmailUnsubscribePayloadFragmentDoc: DocumentNode<EmailUnsubscribePayloadFragment, unknown>;
export declare const EmailUserAccountAuthChallengeResponseFragmentDoc: DocumentNode<EmailUserAccountAuthChallengeResponseFragment, unknown>;
export declare const EmbedFragmentDoc: DocumentNode<EmbedFragment, unknown>;
export declare const EmbedPayloadFragmentDoc: DocumentNode<EmbedPayloadFragment, unknown>;
export declare const EmojiFragmentDoc: DocumentNode<EmojiFragment, unknown>;
export declare const EmojiConnectionFragmentDoc: DocumentNode<EmojiConnectionFragment, unknown>;
export declare const EmojiPayloadFragmentDoc: DocumentNode<EmojiPayloadFragment, unknown>;
export declare const FavoriteFragmentDoc: DocumentNode<FavoriteFragment, unknown>;
export declare const FavoriteConnectionFragmentDoc: DocumentNode<FavoriteConnectionFragment, unknown>;
export declare const FavoritePayloadFragmentDoc: DocumentNode<FavoritePayloadFragment, unknown>;
export declare const FigmaEmbedFragmentDoc: DocumentNode<FigmaEmbedFragment, unknown>;
export declare const FigmaEmbedPayloadFragmentDoc: DocumentNode<FigmaEmbedPayloadFragment, unknown>;
export declare const FirstResponderScheduleFragmentDoc: DocumentNode<FirstResponderScheduleFragment, unknown>;
export declare const FirstResponderScheduleConnectionFragmentDoc: DocumentNode<FirstResponderScheduleConnectionFragment, unknown>;
export declare const FrontAttachmentPayloadFragmentDoc: DocumentNode<FrontAttachmentPayloadFragment, unknown>;
export declare const GitHubCommitIntegrationPayloadFragmentDoc: DocumentNode<GitHubCommitIntegrationPayloadFragment, unknown>;
export declare const ImageUploadFromUrlPayloadFragmentDoc: DocumentNode<ImageUploadFromUrlPayloadFragment, unknown>;
export declare const IntegrationFragmentDoc: DocumentNode<IntegrationFragment, unknown>;
export declare const IntegrationConnectionFragmentDoc: DocumentNode<IntegrationConnectionFragment, unknown>;
export declare const IntegrationPayloadFragmentDoc: DocumentNode<IntegrationPayloadFragment, unknown>;
export declare const IntegrationRequestPayloadFragmentDoc: DocumentNode<IntegrationRequestPayloadFragment, unknown>;
export declare const IntegrationTemplateFragmentDoc: DocumentNode<IntegrationTemplateFragment, unknown>;
export declare const IntegrationTemplateConnectionFragmentDoc: DocumentNode<IntegrationTemplateConnectionFragment, unknown>;
export declare const IntegrationTemplatePayloadFragmentDoc: DocumentNode<IntegrationTemplatePayloadFragment, unknown>;
export declare const IntegrationsSettingsFragmentDoc: DocumentNode<IntegrationsSettingsFragment, unknown>;
export declare const IntegrationsSettingsConnectionFragmentDoc: DocumentNode<IntegrationsSettingsConnectionFragment, unknown>;
export declare const IntegrationsSettingsPayloadFragmentDoc: DocumentNode<IntegrationsSettingsPayloadFragment, unknown>;
export declare const IssueFragmentDoc: DocumentNode<IssueFragment, unknown>;
export declare const IssueBatchPayloadFragmentDoc: DocumentNode<IssueBatchPayloadFragment, unknown>;
export declare const IssueConnectionFragmentDoc: DocumentNode<IssueConnectionFragment, unknown>;
export declare const IssueFilterSuggestionPayloadFragmentDoc: DocumentNode<IssueFilterSuggestionPayloadFragment, unknown>;
export declare const IssueRelationHistoryPayloadFragmentDoc: DocumentNode<IssueRelationHistoryPayloadFragment, unknown>;
export declare const IssueImportFragmentDoc: DocumentNode<IssueImportFragment, unknown>;
export declare const IssueHistoryFragmentDoc: DocumentNode<IssueHistoryFragment, unknown>;
export declare const IssueHistoryConnectionFragmentDoc: DocumentNode<IssueHistoryConnectionFragment, unknown>;
export declare const IssueImportCheckPayloadFragmentDoc: DocumentNode<IssueImportCheckPayloadFragment, unknown>;
export declare const IssueImportDeletePayloadFragmentDoc: DocumentNode<IssueImportDeletePayloadFragment, unknown>;
export declare const IssueImportPayloadFragmentDoc: DocumentNode<IssueImportPayloadFragment, unknown>;
export declare const IssueLabelFragmentDoc: DocumentNode<IssueLabelFragment, unknown>;
export declare const IssueLabelConnectionFragmentDoc: DocumentNode<IssueLabelConnectionFragment, unknown>;
export declare const IssueLabelPayloadFragmentDoc: DocumentNode<IssueLabelPayloadFragment, unknown>;
export declare const IssuePayloadFragmentDoc: DocumentNode<IssuePayloadFragment, unknown>;
export declare const IssuePriorityValueFragmentDoc: DocumentNode<IssuePriorityValueFragment, unknown>;
export declare const IssueRelationFragmentDoc: DocumentNode<IssueRelationFragment, unknown>;
export declare const IssueRelationConnectionFragmentDoc: DocumentNode<IssueRelationConnectionFragment, unknown>;
export declare const IssueRelationPayloadFragmentDoc: DocumentNode<IssueRelationPayloadFragment, unknown>;
export declare const IssueSearchResultFragmentDoc: DocumentNode<IssueSearchResultFragment, unknown>;
export declare const IssueSearchPayloadFragmentDoc: DocumentNode<IssueSearchPayloadFragment, unknown>;
export declare const IssueSearchResultConnectionFragmentDoc: DocumentNode<IssueSearchResultConnectionFragment, unknown>;
export declare const LogoutResponseFragmentDoc: DocumentNode<LogoutResponseFragment, unknown>;
export declare const NodeFragmentDoc: DocumentNode<NodeFragment, unknown>;
export declare const NotificationBatchActionPayloadFragmentDoc: DocumentNode<NotificationBatchActionPayloadFragment, unknown>;
export declare const NotificationConnectionFragmentDoc: DocumentNode<NotificationConnectionFragment, unknown>;
export declare const NotificationPayloadFragmentDoc: DocumentNode<NotificationPayloadFragment, unknown>;
export declare const NotificationSubscriptionFragmentDoc: DocumentNode<NotificationSubscriptionFragment, unknown>;
export declare const NotificationSubscriptionConnectionFragmentDoc: DocumentNode<NotificationSubscriptionConnectionFragment, unknown>;
export declare const NotificationSubscriptionPayloadFragmentDoc: DocumentNode<NotificationSubscriptionPayloadFragment, unknown>;
export declare const OauthClientFragmentDoc: DocumentNode<OauthClientFragment, unknown>;
export declare const OauthClientConnectionFragmentDoc: DocumentNode<OauthClientConnectionFragment, unknown>;
export declare const OrganizationCancelDeletePayloadFragmentDoc: DocumentNode<OrganizationCancelDeletePayloadFragment, unknown>;
export declare const OrganizationDeletePayloadFragmentDoc: DocumentNode<OrganizationDeletePayloadFragment, unknown>;
export declare const OrganizationExistsPayloadFragmentDoc: DocumentNode<OrganizationExistsPayloadFragment, unknown>;
export declare const OrganizationInviteFragmentDoc: DocumentNode<OrganizationInviteFragment, unknown>;
export declare const OrganizationInviteConnectionFragmentDoc: DocumentNode<OrganizationInviteConnectionFragment, unknown>;
export declare const OrganizationInviteFullDetailsPayloadFragmentDoc: DocumentNode<OrganizationInviteFullDetailsPayloadFragment, unknown>;
export declare const OrganizationInvitePayloadFragmentDoc: DocumentNode<OrganizationInvitePayloadFragment, unknown>;
export declare const OrganizationPayloadFragmentDoc: DocumentNode<OrganizationPayloadFragment, unknown>;
export declare const OrganizationStartPlusTrialPayloadFragmentDoc: DocumentNode<OrganizationStartPlusTrialPayloadFragment, unknown>;
export declare const ProjectFragmentDoc: DocumentNode<ProjectFragment, unknown>;
export declare const ProjectConnectionFragmentDoc: DocumentNode<ProjectConnectionFragment, unknown>;
export declare const ProjectFilterSuggestionPayloadFragmentDoc: DocumentNode<ProjectFilterSuggestionPayloadFragment, unknown>;
export declare const ProjectLinkFragmentDoc: DocumentNode<ProjectLinkFragment, unknown>;
export declare const ProjectLinkConnectionFragmentDoc: DocumentNode<ProjectLinkConnectionFragment, unknown>;
export declare const ProjectLinkPayloadFragmentDoc: DocumentNode<ProjectLinkPayloadFragment, unknown>;
export declare const ProjectMilestoneFragmentDoc: DocumentNode<ProjectMilestoneFragment, unknown>;
export declare const ProjectMilestoneConnectionFragmentDoc: DocumentNode<ProjectMilestoneConnectionFragment, unknown>;
export declare const ProjectMilestonePayloadFragmentDoc: DocumentNode<ProjectMilestonePayloadFragment, unknown>;
export declare const ProjectPayloadFragmentDoc: DocumentNode<ProjectPayloadFragment, unknown>;
export declare const ProjectSearchResultFragmentDoc: DocumentNode<ProjectSearchResultFragment, unknown>;
export declare const ProjectSearchPayloadFragmentDoc: DocumentNode<ProjectSearchPayloadFragment, unknown>;
export declare const ProjectSearchResultConnectionFragmentDoc: DocumentNode<ProjectSearchResultConnectionFragment, unknown>;
export declare const ProjectUpdateFragmentDoc: DocumentNode<ProjectUpdateFragment, unknown>;
export declare const ProjectUpdateConnectionFragmentDoc: DocumentNode<ProjectUpdateConnectionFragment, unknown>;
export declare const ProjectUpdateInteractionFragmentDoc: DocumentNode<ProjectUpdateInteractionFragment, unknown>;
export declare const ProjectUpdateInteractionConnectionFragmentDoc: DocumentNode<ProjectUpdateInteractionConnectionFragment, unknown>;
export declare const ProjectUpdateInteractionPayloadFragmentDoc: DocumentNode<ProjectUpdateInteractionPayloadFragment, unknown>;
export declare const ProjectUpdatePayloadFragmentDoc: DocumentNode<ProjectUpdatePayloadFragment, unknown>;
export declare const ProjectUpdateWithInteractionPayloadFragmentDoc: DocumentNode<ProjectUpdateWithInteractionPayloadFragment, unknown>;
export declare const PushSubscriptionFragmentDoc: DocumentNode<PushSubscriptionFragment, unknown>;
export declare const PushSubscriptionConnectionFragmentDoc: DocumentNode<PushSubscriptionConnectionFragment, unknown>;
export declare const PushSubscriptionPayloadFragmentDoc: DocumentNode<PushSubscriptionPayloadFragment, unknown>;
export declare const PushSubscriptionTestPayloadFragmentDoc: DocumentNode<PushSubscriptionTestPayloadFragment, unknown>;
export declare const RateLimitResultPayloadFragmentDoc: DocumentNode<RateLimitResultPayloadFragment, unknown>;
export declare const RateLimitPayloadFragmentDoc: DocumentNode<RateLimitPayloadFragment, unknown>;
export declare const ReactionFragmentDoc: DocumentNode<ReactionFragment, unknown>;
export declare const ReactionConnectionFragmentDoc: DocumentNode<ReactionConnectionFragment, unknown>;
export declare const ReactionPayloadFragmentDoc: DocumentNode<ReactionPayloadFragment, unknown>;
export declare const RoadmapFragmentDoc: DocumentNode<RoadmapFragment, unknown>;
export declare const RoadmapConnectionFragmentDoc: DocumentNode<RoadmapConnectionFragment, unknown>;
export declare const RoadmapPayloadFragmentDoc: DocumentNode<RoadmapPayloadFragment, unknown>;
export declare const RoadmapToProjectFragmentDoc: DocumentNode<RoadmapToProjectFragment, unknown>;
export declare const RoadmapToProjectConnectionFragmentDoc: DocumentNode<RoadmapToProjectConnectionFragment, unknown>;
export declare const RoadmapToProjectPayloadFragmentDoc: DocumentNode<RoadmapToProjectPayloadFragment, unknown>;
export declare const SamlConfigurationFragmentDoc: DocumentNode<SamlConfigurationFragment, unknown>;
export declare const SsoUrlFromEmailResponseFragmentDoc: DocumentNode<SsoUrlFromEmailResponseFragment, unknown>;
export declare const SynchronizedPayloadFragmentDoc: DocumentNode<SynchronizedPayloadFragment, unknown>;
export declare const TeamFragmentDoc: DocumentNode<TeamFragment, unknown>;
export declare const TeamConnectionFragmentDoc: DocumentNode<TeamConnectionFragment, unknown>;
export declare const TeamMembershipFragmentDoc: DocumentNode<TeamMembershipFragment, unknown>;
export declare const TeamMembershipConnectionFragmentDoc: DocumentNode<TeamMembershipConnectionFragment, unknown>;
export declare const TeamMembershipPayloadFragmentDoc: DocumentNode<TeamMembershipPayloadFragment, unknown>;
export declare const TeamPayloadFragmentDoc: DocumentNode<TeamPayloadFragment, unknown>;
export declare const TemplateConnectionFragmentDoc: DocumentNode<TemplateConnectionFragment, unknown>;
export declare const TemplatePayloadFragmentDoc: DocumentNode<TemplatePayloadFragment, unknown>;
export declare const UploadFileHeaderFragmentDoc: DocumentNode<UploadFileHeaderFragment, unknown>;
export declare const UploadFileFragmentDoc: DocumentNode<UploadFileFragment, unknown>;
export declare const UploadPayloadFragmentDoc: DocumentNode<UploadPayloadFragment, unknown>;
export declare const UserAdminPayloadFragmentDoc: DocumentNode<UserAdminPayloadFragment, unknown>;
export declare const UserConnectionFragmentDoc: DocumentNode<UserConnectionFragment, unknown>;
export declare const UserPayloadFragmentDoc: DocumentNode<UserPayloadFragment, unknown>;
export declare const UserSettingsFlagPayloadFragmentDoc: DocumentNode<UserSettingsFlagPayloadFragment, unknown>;
export declare const UserSettingsFlagsResetPayloadFragmentDoc: DocumentNode<UserSettingsFlagsResetPayloadFragment, unknown>;
export declare const UserSettingsPayloadFragmentDoc: DocumentNode<UserSettingsPayloadFragment, unknown>;
export declare const ViewPreferencesFragmentDoc: DocumentNode<ViewPreferencesFragment, unknown>;
export declare const ViewPreferencesPayloadFragmentDoc: DocumentNode<ViewPreferencesPayloadFragment, unknown>;
export declare const WebhookFragmentDoc: DocumentNode<WebhookFragment, unknown>;
export declare const WebhookConnectionFragmentDoc: DocumentNode<WebhookConnectionFragment, unknown>;
export declare const WebhookPayloadFragmentDoc: DocumentNode<WebhookPayloadFragment, unknown>;
export declare const WorkflowCronJobDefinitionFragmentDoc: DocumentNode<WorkflowCronJobDefinitionFragment, unknown>;
export declare const WorkflowCronJobDefinitionConnectionFragmentDoc: DocumentNode<WorkflowCronJobDefinitionConnectionFragment, unknown>;
export declare const WorkflowDefinitionFragmentDoc: DocumentNode<WorkflowDefinitionFragment, unknown>;
export declare const WorkflowDefinitionConnectionFragmentDoc: DocumentNode<WorkflowDefinitionConnectionFragment, unknown>;
export declare const WorkflowStateFragmentDoc: DocumentNode<WorkflowStateFragment, unknown>;
export declare const WorkflowStateConnectionFragmentDoc: DocumentNode<WorkflowStateConnectionFragment, unknown>;
export declare const WorkflowStatePayloadFragmentDoc: DocumentNode<WorkflowStatePayloadFragment, unknown>;
export declare const AirbyteIntegrationConnectDocument: DocumentNode<AirbyteIntegrationConnectMutation, Exact<{
    input: AirbyteConfigurationInput;
}>>;
export declare const CreateApiKeyDocument: DocumentNode<CreateApiKeyMutation, Exact<{
    input: ApiKeyCreateInput;
}>>;
export declare const DeleteApiKeyDocument: DocumentNode<DeleteApiKeyMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const ArchiveAttachmentDocument: DocumentNode<ArchiveAttachmentMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const CreateAttachmentDocument: DocumentNode<CreateAttachmentMutation, Exact<{
    input: AttachmentCreateInput;
}>>;
export declare const DeleteAttachmentDocument: DocumentNode<DeleteAttachmentMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const AttachmentLinkDiscordDocument: DocumentNode<AttachmentLinkDiscordMutation, Exact<{
    channelId: Scalars["String"];
    issueId: Scalars["String"];
    messageId: Scalars["String"];
    url: Scalars["String"];
}>>;
export declare const AttachmentLinkFrontDocument: DocumentNode<AttachmentLinkFrontMutation, Exact<{
    conversationId: Scalars["String"];
    issueId: Scalars["String"];
}>>;
export declare const AttachmentLinkIntercomDocument: DocumentNode<AttachmentLinkIntercomMutation, Exact<{
    conversationId: Scalars["String"];
    issueId: Scalars["String"];
}>>;
export declare const AttachmentLinkJiraIssueDocument: DocumentNode<AttachmentLinkJiraIssueMutation, Exact<{
    issueId: Scalars["String"];
    jiraIssueId: Scalars["String"];
}>>;
export declare const AttachmentLinkSlackDocument: DocumentNode<AttachmentLinkSlackMutation, Exact<{
    channel: Scalars["String"];
    id?: Maybe<string> | undefined;
    issueId: Scalars["String"];
    latest: Scalars["String"];
    title?: Maybe<string> | undefined;
    ts?: Maybe<string> | undefined;
    url: Scalars["String"];
}>>;
export declare const AttachmentLinkUrlDocument: DocumentNode<AttachmentLinkUrlMutation, Exact<{
    id?: Maybe<string> | undefined;
    issueId: Scalars["String"];
    title?: Maybe<string> | undefined;
    url: Scalars["String"];
}>>;
export declare const AttachmentLinkZendeskDocument: DocumentNode<AttachmentLinkZendeskMutation, Exact<{
    issueId: Scalars["String"];
    ticketId: Scalars["String"];
}>>;
export declare const AttachmentUnsyncSlackDocument: DocumentNode<AttachmentUnsyncSlackMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateAttachmentDocument: DocumentNode<UpdateAttachmentMutation, Exact<{
    id: Scalars["String"];
    input: AttachmentUpdateInput;
}>>;
export declare const CreateCommentDocument: DocumentNode<CreateCommentMutation, Exact<{
    input: CommentCreateInput;
}>>;
export declare const DeleteCommentDocument: DocumentNode<DeleteCommentMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateCommentDocument: DocumentNode<UpdateCommentMutation, Exact<{
    id: Scalars["String"];
    input: CommentUpdateInput;
}>>;
export declare const CreateContactDocument: DocumentNode<CreateContactMutation, Exact<{
    input: ContactCreateInput;
}>>;
export declare const CreateCsvExportReportDocument: DocumentNode<CreateCsvExportReportMutation, Exact<{
    includePrivateTeamIds?: Maybe<string | string[]> | undefined;
}>>;
export declare const CreateOrganizationFromOnboardingDocument: DocumentNode<CreateOrganizationFromOnboardingMutation, Exact<{
    input: CreateOrganizationInput;
    survey?: Maybe<OnboardingCustomerSurvey> | undefined;
}>>;
export declare const CreateCustomViewDocument: DocumentNode<CreateCustomViewMutation, Exact<{
    input: CustomViewCreateInput;
}>>;
export declare const DeleteCustomViewDocument: DocumentNode<DeleteCustomViewMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateCustomViewDocument: DocumentNode<UpdateCustomViewMutation, Exact<{
    id: Scalars["String"];
    input: CustomViewUpdateInput;
}>>;
export declare const ArchiveCycleDocument: DocumentNode<ArchiveCycleMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const CreateCycleDocument: DocumentNode<CreateCycleMutation, Exact<{
    input: CycleCreateInput;
}>>;
export declare const UpdateCycleDocument: DocumentNode<UpdateCycleMutation, Exact<{
    id: Scalars["String"];
    input: CycleUpdateInput;
}>>;
export declare const CreateDocumentDocument: DocumentNode<CreateDocumentMutation, Exact<{
    input: DocumentCreateInput;
}>>;
export declare const DeleteDocumentDocument: DocumentNode<DeleteDocumentMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateDocumentDocument: DocumentNode<UpdateDocumentMutation, Exact<{
    id: Scalars["String"];
    input: DocumentUpdateInput;
}>>;
export declare const EmailTokenUserAccountAuthDocument: DocumentNode<EmailTokenUserAccountAuthMutation, Exact<{
    input: TokenUserAccountAuthInput;
}>>;
export declare const EmailUnsubscribeDocument: DocumentNode<EmailUnsubscribeMutation, Exact<{
    input: EmailUnsubscribeInput;
}>>;
export declare const EmailUserAccountAuthChallengeDocument: DocumentNode<EmailUserAccountAuthChallengeMutation, Exact<{
    input: EmailUserAccountAuthChallengeInput;
}>>;
export declare const CreateEmojiDocument: DocumentNode<CreateEmojiMutation, Exact<{
    input: EmojiCreateInput;
}>>;
export declare const DeleteEmojiDocument: DocumentNode<DeleteEmojiMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const CreateFavoriteDocument: DocumentNode<CreateFavoriteMutation, Exact<{
    input: FavoriteCreateInput;
}>>;
export declare const DeleteFavoriteDocument: DocumentNode<DeleteFavoriteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateFavoriteDocument: DocumentNode<UpdateFavoriteMutation, Exact<{
    id: Scalars["String"];
    input: FavoriteUpdateInput;
}>>;
export declare const FileUploadDocument: DocumentNode<FileUploadMutation, Exact<{
    contentType: Scalars["String"];
    filename: Scalars["String"];
    makePublic?: Maybe<boolean> | undefined;
    metaData?: Maybe<Record<string, unknown>> | undefined;
    size: Scalars["Int"];
}>>;
export declare const GoogleUserAccountAuthDocument: DocumentNode<GoogleUserAccountAuthMutation, Exact<{
    input: GoogleUserAccountAuthInput;
}>>;
export declare const ImageUploadFromUrlDocument: DocumentNode<ImageUploadFromUrlMutation, Exact<{
    url: Scalars["String"];
}>>;
export declare const ImportFileUploadDocument: DocumentNode<ImportFileUploadMutation, Exact<{
    contentType: Scalars["String"];
    filename: Scalars["String"];
    metaData?: Maybe<Record<string, unknown>> | undefined;
    size: Scalars["Int"];
}>>;
export declare const DeleteIntegrationDocument: DocumentNode<DeleteIntegrationMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const IntegrationDiscordDocument: DocumentNode<IntegrationDiscordMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>>;
export declare const IntegrationFigmaDocument: DocumentNode<IntegrationFigmaMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>>;
export declare const IntegrationFrontDocument: DocumentNode<IntegrationFrontMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>>;
export declare const CreateIntegrationGithubCommitDocument: DocumentNode<CreateIntegrationGithubCommitMutation, Exact<{
    [key: string]: never;
}>>;
export declare const IntegrationGithubConnectDocument: DocumentNode<IntegrationGithubConnectMutation, Exact<{
    installationId: Scalars["String"];
}>>;
export declare const IntegrationGitlabConnectDocument: DocumentNode<IntegrationGitlabConnectMutation, Exact<{
    accessToken: Scalars["String"];
    gitlabUrl: Scalars["String"];
}>>;
export declare const IntegrationGoogleSheetsDocument: DocumentNode<IntegrationGoogleSheetsMutation, Exact<{
    code: Scalars["String"];
}>>;
export declare const IntegrationIntercomDocument: DocumentNode<IntegrationIntercomMutation, Exact<{
    code: Scalars["String"];
    domainUrl?: Maybe<string> | undefined;
    redirectUri: Scalars["String"];
}>>;
export declare const DeleteIntegrationIntercomDocument: DocumentNode<DeleteIntegrationIntercomMutation, Exact<{
    [key: string]: never;
}>>;
export declare const UpdateIntegrationIntercomSettingsDocument: DocumentNode<UpdateIntegrationIntercomSettingsMutation, Exact<{
    input: IntercomSettingsInput;
}>>;
export declare const IntegrationLoomDocument: DocumentNode<IntegrationLoomMutation, Exact<{
    [key: string]: never;
}>>;
export declare const IntegrationRequestDocument: DocumentNode<IntegrationRequestMutation, Exact<{
    input: IntegrationRequestInput;
}>>;
export declare const IntegrationSentryConnectDocument: DocumentNode<IntegrationSentryConnectMutation, Exact<{
    code: Scalars["String"];
    installationId: Scalars["String"];
    organizationSlug: Scalars["String"];
}>>;
export declare const IntegrationSlackDocument: DocumentNode<IntegrationSlackMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    shouldUseV2Auth?: Maybe<boolean> | undefined;
}>>;
export declare const IntegrationSlackAsksDocument: DocumentNode<IntegrationSlackAsksMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>>;
export declare const IntegrationSlackImportEmojisDocument: DocumentNode<IntegrationSlackImportEmojisMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>>;
export declare const IntegrationSlackOrgProjectUpdatesPostDocument: DocumentNode<IntegrationSlackOrgProjectUpdatesPostMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>>;
export declare const IntegrationSlackPersonalDocument: DocumentNode<IntegrationSlackPersonalMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>>;
export declare const IntegrationSlackPostDocument: DocumentNode<IntegrationSlackPostMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    shouldUseV2Auth?: Maybe<boolean> | undefined;
    teamId: Scalars["String"];
}>>;
export declare const IntegrationSlackProjectPostDocument: DocumentNode<IntegrationSlackProjectPostMutation, Exact<{
    code: Scalars["String"];
    projectId: Scalars["String"];
    redirectUri: Scalars["String"];
    service: Scalars["String"];
}>>;
export declare const CreateIntegrationTemplateDocument: DocumentNode<CreateIntegrationTemplateMutation, Exact<{
    input: IntegrationTemplateCreateInput;
}>>;
export declare const DeleteIntegrationTemplateDocument: DocumentNode<DeleteIntegrationTemplateMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const IntegrationUpdateSlackDocument: DocumentNode<IntegrationUpdateSlackMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>>;
export declare const IntegrationZendeskDocument: DocumentNode<IntegrationZendeskMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
    scope: Scalars["String"];
    subdomain: Scalars["String"];
}>>;
export declare const CreateIntegrationsSettingsDocument: DocumentNode<CreateIntegrationsSettingsMutation, Exact<{
    input: IntegrationsSettingsCreateInput;
}>>;
export declare const UpdateIntegrationsSettingsDocument: DocumentNode<UpdateIntegrationsSettingsMutation, Exact<{
    id: Scalars["String"];
    input: IntegrationsSettingsUpdateInput;
}>>;
export declare const ArchiveIssueDocument: DocumentNode<ArchiveIssueMutation, Exact<{
    id: Scalars["String"];
    trash?: Maybe<boolean> | undefined;
}>>;
export declare const UpdateIssueBatchDocument: DocumentNode<UpdateIssueBatchMutation, Exact<{
    ids: Array<Scalars["UUID"]> | Scalars["UUID"];
    input: IssueUpdateInput;
}>>;
export declare const CreateIssueDocument: DocumentNode<CreateIssueMutation, Exact<{
    input: IssueCreateInput;
}>>;
export declare const DeleteIssueDocument: DocumentNode<DeleteIssueMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const IssueImportCreateAsanaDocument: DocumentNode<IssueImportCreateAsanaMutation, Exact<{
    asanaTeamName: Scalars["String"];
    asanaToken: Scalars["String"];
    id?: Maybe<string> | undefined;
    includeClosedIssues?: Maybe<boolean> | undefined;
    instantProcess?: Maybe<boolean> | undefined;
    organizationId?: Maybe<string> | undefined;
    teamId?: Maybe<string> | undefined;
    teamName?: Maybe<string> | undefined;
}>>;
export declare const IssueImportCreateCsvJiraDocument: DocumentNode<IssueImportCreateCsvJiraMutation, Exact<{
    csvUrl: Scalars["String"];
    jiraEmail?: Maybe<string> | undefined;
    jiraHostname?: Maybe<string> | undefined;
    jiraToken?: Maybe<string> | undefined;
    organizationId?: Maybe<string> | undefined;
    teamId?: Maybe<string> | undefined;
    teamName?: Maybe<string> | undefined;
}>>;
export declare const IssueImportCreateClubhouseDocument: DocumentNode<IssueImportCreateClubhouseMutation, Exact<{
    clubhouseGroupName: Scalars["String"];
    clubhouseToken: Scalars["String"];
    id?: Maybe<string> | undefined;
    includeClosedIssues?: Maybe<boolean> | undefined;
    instantProcess?: Maybe<boolean> | undefined;
    organizationId?: Maybe<string> | undefined;
    teamId?: Maybe<string> | undefined;
    teamName?: Maybe<string> | undefined;
}>>;
export declare const IssueImportCreateGithubDocument: DocumentNode<IssueImportCreateGithubMutation, Exact<{
    githubRepoName: Scalars["String"];
    githubRepoOwner: Scalars["String"];
    githubShouldImportOrgProjects?: Maybe<boolean> | undefined;
    githubToken: Scalars["String"];
    id?: Maybe<string> | undefined;
    includeClosedIssues?: Maybe<boolean> | undefined;
    instantProcess?: Maybe<boolean> | undefined;
    organizationId?: Maybe<string> | undefined;
    teamId?: Maybe<string> | undefined;
    teamName?: Maybe<string> | undefined;
}>>;
export declare const IssueImportCreateJiraDocument: DocumentNode<IssueImportCreateJiraMutation, Exact<{
    id?: Maybe<string> | undefined;
    includeClosedIssues?: Maybe<boolean> | undefined;
    instantProcess?: Maybe<boolean> | undefined;
    jiraEmail: Scalars["String"];
    jiraHostname: Scalars["String"];
    jiraProject: Scalars["String"];
    jiraToken: Scalars["String"];
    organizationId?: Maybe<string> | undefined;
    teamId?: Maybe<string> | undefined;
    teamName?: Maybe<string> | undefined;
}>>;
export declare const DeleteIssueImportDocument: DocumentNode<DeleteIssueImportMutation, Exact<{
    issueImportId: Scalars["String"];
}>>;
export declare const IssueImportProcessDocument: DocumentNode<IssueImportProcessMutation, Exact<{
    issueImportId: Scalars["String"];
    mapping: Scalars["JSONObject"];
}>>;
export declare const UpdateIssueImportDocument: DocumentNode<UpdateIssueImportMutation, Exact<{
    id: Scalars["String"];
    input: IssueImportUpdateInput;
}>>;
export declare const CreateIssueLabelDocument: DocumentNode<CreateIssueLabelMutation, Exact<{
    input: IssueLabelCreateInput;
    replaceTeamLabels?: Maybe<boolean> | undefined;
}>>;
export declare const DeleteIssueLabelDocument: DocumentNode<DeleteIssueLabelMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateIssueLabelDocument: DocumentNode<UpdateIssueLabelMutation, Exact<{
    id: Scalars["String"];
    input: IssueLabelUpdateInput;
}>>;
export declare const CreateIssueRelationDocument: DocumentNode<CreateIssueRelationMutation, Exact<{
    input: IssueRelationCreateInput;
}>>;
export declare const DeleteIssueRelationDocument: DocumentNode<DeleteIssueRelationMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateIssueRelationDocument: DocumentNode<UpdateIssueRelationMutation, Exact<{
    id: Scalars["String"];
    input: IssueRelationUpdateInput;
}>>;
export declare const IssueReminderDocument: DocumentNode<IssueReminderMutation, Exact<{
    id: Scalars["String"];
    reminderAt: Scalars["DateTime"];
}>>;
export declare const UnarchiveIssueDocument: DocumentNode<UnarchiveIssueMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateIssueDocument: DocumentNode<UpdateIssueMutation, Exact<{
    id: Scalars["String"];
    input: IssueUpdateInput;
}>>;
export declare const JoinOrganizationFromOnboardingDocument: DocumentNode<JoinOrganizationFromOnboardingMutation, Exact<{
    input: JoinOrganizationInput;
}>>;
export declare const LeaveOrganizationDocument: DocumentNode<LeaveOrganizationMutation, Exact<{
    organizationId: Scalars["String"];
}>>;
export declare const LogoutDocument: DocumentNode<LogoutMutation, Exact<{
    [key: string]: never;
}>>;
export declare const ArchiveNotificationDocument: DocumentNode<ArchiveNotificationMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const NotificationArchiveAllDocument: DocumentNode<NotificationArchiveAllMutation, Exact<{
    input: NotificationEntityInput;
}>>;
export declare const NotificationMarkReadAllDocument: DocumentNode<NotificationMarkReadAllMutation, Exact<{
    input: NotificationEntityInput;
    readAt: Scalars["DateTime"];
}>>;
export declare const NotificationMarkUnreadAllDocument: DocumentNode<NotificationMarkUnreadAllMutation, Exact<{
    input: NotificationEntityInput;
}>>;
export declare const NotificationSnoozeAllDocument: DocumentNode<NotificationSnoozeAllMutation, Exact<{
    input: NotificationEntityInput;
    snoozedUntilAt: Scalars["DateTime"];
}>>;
export declare const CreateNotificationSubscriptionDocument: DocumentNode<CreateNotificationSubscriptionMutation, Exact<{
    input: NotificationSubscriptionCreateInput;
}>>;
export declare const DeleteNotificationSubscriptionDocument: DocumentNode<DeleteNotificationSubscriptionMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateNotificationSubscriptionDocument: DocumentNode<UpdateNotificationSubscriptionMutation, Exact<{
    id: Scalars["String"];
    input: NotificationSubscriptionUpdateInput;
}>>;
export declare const UnarchiveNotificationDocument: DocumentNode<UnarchiveNotificationMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const NotificationUnsnoozeAllDocument: DocumentNode<NotificationUnsnoozeAllMutation, Exact<{
    input: NotificationEntityInput;
    unsnoozedAt: Scalars["DateTime"];
}>>;
export declare const UpdateNotificationDocument: DocumentNode<UpdateNotificationMutation, Exact<{
    id: Scalars["String"];
    input: NotificationUpdateInput;
}>>;
export declare const DeleteOrganizationCancelDocument: DocumentNode<DeleteOrganizationCancelMutation, Exact<{
    [key: string]: never;
}>>;
export declare const DeleteOrganizationDocument: DocumentNode<DeleteOrganizationMutation, Exact<{
    input: DeleteOrganizationInput;
}>>;
export declare const OrganizationDeleteChallengeDocument: DocumentNode<OrganizationDeleteChallengeMutation, Exact<{
    [key: string]: never;
}>>;
export declare const DeleteOrganizationDomainDocument: DocumentNode<DeleteOrganizationDomainMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const CreateOrganizationInviteDocument: DocumentNode<CreateOrganizationInviteMutation, Exact<{
    input: OrganizationInviteCreateInput;
}>>;
export declare const DeleteOrganizationInviteDocument: DocumentNode<DeleteOrganizationInviteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateOrganizationInviteDocument: DocumentNode<UpdateOrganizationInviteMutation, Exact<{
    id: Scalars["String"];
    input: OrganizationInviteUpdateInput;
}>>;
export declare const OrganizationStartPlusTrialDocument: DocumentNode<OrganizationStartPlusTrialMutation, Exact<{
    [key: string]: never;
}>>;
export declare const UpdateOrganizationDocument: DocumentNode<UpdateOrganizationMutation, Exact<{
    input: UpdateOrganizationInput;
}>>;
export declare const ArchiveProjectDocument: DocumentNode<ArchiveProjectMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const CreateProjectDocument: DocumentNode<CreateProjectMutation, Exact<{
    input: ProjectCreateInput;
}>>;
export declare const DeleteProjectDocument: DocumentNode<DeleteProjectMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const CreateProjectLinkDocument: DocumentNode<CreateProjectLinkMutation, Exact<{
    input: ProjectLinkCreateInput;
}>>;
export declare const DeleteProjectLinkDocument: DocumentNode<DeleteProjectLinkMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateProjectLinkDocument: DocumentNode<UpdateProjectLinkMutation, Exact<{
    id: Scalars["String"];
    input: ProjectLinkUpdateInput;
}>>;
export declare const CreateProjectMilestoneDocument: DocumentNode<CreateProjectMilestoneMutation, Exact<{
    input: ProjectMilestoneCreateInput;
}>>;
export declare const DeleteProjectMilestoneDocument: DocumentNode<DeleteProjectMilestoneMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateProjectMilestoneDocument: DocumentNode<UpdateProjectMilestoneMutation, Exact<{
    id: Scalars["String"];
    input: ProjectMilestoneUpdateInput;
}>>;
export declare const UnarchiveProjectDocument: DocumentNode<UnarchiveProjectMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateProjectDocument: DocumentNode<UpdateProjectMutation, Exact<{
    id: Scalars["String"];
    input: ProjectUpdateInput;
}>>;
export declare const CreateProjectUpdateDocument: DocumentNode<CreateProjectUpdateMutation, Exact<{
    input: ProjectUpdateCreateInput;
}>>;
export declare const DeleteProjectUpdateDocument: DocumentNode<DeleteProjectUpdateMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const CreateProjectUpdateInteractionDocument: DocumentNode<CreateProjectUpdateInteractionMutation, Exact<{
    input: ProjectUpdateInteractionCreateInput;
}>>;
export declare const ProjectUpdateMarkAsReadDocument: DocumentNode<ProjectUpdateMarkAsReadMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateProjectUpdateDocument: DocumentNode<UpdateProjectUpdateMutation, Exact<{
    id: Scalars["String"];
    input: ProjectUpdateUpdateInput;
}>>;
export declare const CreatePushSubscriptionDocument: DocumentNode<CreatePushSubscriptionMutation, Exact<{
    input: PushSubscriptionCreateInput;
}>>;
export declare const DeletePushSubscriptionDocument: DocumentNode<DeletePushSubscriptionMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const CreateReactionDocument: DocumentNode<CreateReactionMutation, Exact<{
    input: ReactionCreateInput;
}>>;
export declare const DeleteReactionDocument: DocumentNode<DeleteReactionMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const RefreshGoogleSheetsDataDocument: DocumentNode<RefreshGoogleSheetsDataMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const ResendOrganizationInviteDocument: DocumentNode<ResendOrganizationInviteMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const ArchiveRoadmapDocument: DocumentNode<ArchiveRoadmapMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const CreateRoadmapDocument: DocumentNode<CreateRoadmapMutation, Exact<{
    input: RoadmapCreateInput;
}>>;
export declare const DeleteRoadmapDocument: DocumentNode<DeleteRoadmapMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const CreateRoadmapToProjectDocument: DocumentNode<CreateRoadmapToProjectMutation, Exact<{
    input: RoadmapToProjectCreateInput;
}>>;
export declare const DeleteRoadmapToProjectDocument: DocumentNode<DeleteRoadmapToProjectMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateRoadmapToProjectDocument: DocumentNode<UpdateRoadmapToProjectMutation, Exact<{
    id: Scalars["String"];
    input: RoadmapToProjectUpdateInput;
}>>;
export declare const UnarchiveRoadmapDocument: DocumentNode<UnarchiveRoadmapMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateRoadmapDocument: DocumentNode<UpdateRoadmapMutation, Exact<{
    id: Scalars["String"];
    input: RoadmapUpdateInput;
}>>;
export declare const SamlTokenUserAccountAuthDocument: DocumentNode<SamlTokenUserAccountAuthMutation, Exact<{
    input: TokenUserAccountAuthInput;
}>>;
export declare const CreateTeamDocument: DocumentNode<CreateTeamMutation, Exact<{
    copySettingsFromTeamId?: Maybe<string> | undefined;
    input: TeamCreateInput;
}>>;
export declare const DeleteTeamCyclesDocument: DocumentNode<DeleteTeamCyclesMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const DeleteTeamDocument: DocumentNode<DeleteTeamMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const DeleteTeamKeyDocument: DocumentNode<DeleteTeamKeyMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const CreateTeamMembershipDocument: DocumentNode<CreateTeamMembershipMutation, Exact<{
    input: TeamMembershipCreateInput;
}>>;
export declare const DeleteTeamMembershipDocument: DocumentNode<DeleteTeamMembershipMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateTeamMembershipDocument: DocumentNode<UpdateTeamMembershipMutation, Exact<{
    id: Scalars["String"];
    input: TeamMembershipUpdateInput;
}>>;
export declare const UpdateTeamDocument: DocumentNode<UpdateTeamMutation, Exact<{
    id: Scalars["String"];
    input: TeamUpdateInput;
}>>;
export declare const CreateTemplateDocument: DocumentNode<CreateTemplateMutation, Exact<{
    input: TemplateCreateInput;
}>>;
export declare const DeleteTemplateDocument: DocumentNode<DeleteTemplateMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateTemplateDocument: DocumentNode<UpdateTemplateMutation, Exact<{
    id: Scalars["String"];
    input: TemplateUpdateInput;
}>>;
export declare const UserDemoteAdminDocument: DocumentNode<UserDemoteAdminMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UserDemoteMemberDocument: DocumentNode<UserDemoteMemberMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UserDiscordConnectDocument: DocumentNode<UserDiscordConnectMutation, Exact<{
    code: Scalars["String"];
    redirectUri: Scalars["String"];
}>>;
export declare const UserExternalUserDisconnectDocument: DocumentNode<UserExternalUserDisconnectMutation, Exact<{
    service: Scalars["String"];
}>>;
export declare const UpdateUserFlagDocument: DocumentNode<UpdateUserFlagMutation, Exact<{
    flag: UserFlagType;
    operation: UserFlagUpdateOperation;
}>>;
export declare const UserGitHubConnectDocument: DocumentNode<UserGitHubConnectMutation, Exact<{
    code: Scalars["String"];
}>>;
export declare const UserGoogleCalendarConnectDocument: DocumentNode<UserGoogleCalendarConnectMutation, Exact<{
    code: Scalars["String"];
}>>;
export declare const UserJiraConnectDocument: DocumentNode<UserJiraConnectMutation, Exact<{
    code: Scalars["String"];
}>>;
export declare const UserPromoteAdminDocument: DocumentNode<UserPromoteAdminMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UserPromoteMemberDocument: DocumentNode<UserPromoteMemberMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UserSettingsFlagIncrementDocument: DocumentNode<UserSettingsFlagIncrementMutation, Exact<{
    flag: Scalars["String"];
}>>;
export declare const UserSettingsFlagsResetDocument: DocumentNode<UserSettingsFlagsResetMutation, Exact<{
    flags?: Maybe<UserFlagType | UserFlagType[]> | undefined;
}>>;
export declare const UpdateUserSettingsDocument: DocumentNode<UpdateUserSettingsMutation, Exact<{
    id: Scalars["String"];
    input: UserSettingsUpdateInput;
}>>;
export declare const SuspendUserDocument: DocumentNode<SuspendUserMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UnsuspendUserDocument: DocumentNode<UnsuspendUserMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateUserDocument: DocumentNode<UpdateUserMutation, Exact<{
    id: Scalars["String"];
    input: UpdateUserInput;
}>>;
export declare const CreateViewPreferencesDocument: DocumentNode<CreateViewPreferencesMutation, Exact<{
    input: ViewPreferencesCreateInput;
}>>;
export declare const DeleteViewPreferencesDocument: DocumentNode<DeleteViewPreferencesMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateViewPreferencesDocument: DocumentNode<UpdateViewPreferencesMutation, Exact<{
    id: Scalars["String"];
    input: ViewPreferencesUpdateInput;
}>>;
export declare const CreateWebhookDocument: DocumentNode<CreateWebhookMutation, Exact<{
    input: WebhookCreateInput;
}>>;
export declare const DeleteWebhookDocument: DocumentNode<DeleteWebhookMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const UpdateWebhookDocument: DocumentNode<UpdateWebhookMutation, Exact<{
    id: Scalars["String"];
    input: WebhookUpdateInput;
}>>;
export declare const ArchiveWorkflowStateDocument: DocumentNode<ArchiveWorkflowStateMutation, Exact<{
    id: Scalars["String"];
}>>;
export declare const CreateWorkflowStateDocument: DocumentNode<CreateWorkflowStateMutation, Exact<{
    input: WorkflowStateCreateInput;
}>>;
export declare const UpdateWorkflowStateDocument: DocumentNode<UpdateWorkflowStateMutation, Exact<{
    id: Scalars["String"];
    input: WorkflowStateUpdateInput;
}>>;
export declare const ProjectMilestoneDocument: DocumentNode<ProjectMilestoneQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const ProjectMilestonesDocument: DocumentNode<ProjectMilestonesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<ProjectMilestoneFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AdministrableTeamsDocument: DocumentNode<AdministrableTeamsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<TeamFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const ApiKeysDocument: DocumentNode<ApiKeysQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const ApplicationInfoDocument: DocumentNode<ApplicationInfoQuery, Exact<{
    clientId: Scalars["String"];
}>>;
export declare const ApplicationWithAuthorizationDocument: DocumentNode<ApplicationWithAuthorizationQuery, Exact<{
    actor?: Maybe<string> | undefined;
    clientId: Scalars["String"];
    redirectUri?: Maybe<string> | undefined;
    scope: Array<Scalars["String"]> | Scalars["String"];
}>>;
export declare const AttachmentDocument: DocumentNode<AttachmentQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const AttachmentIssueDocument: DocumentNode<AttachmentIssueQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const AttachmentIssue_AttachmentsDocument: DocumentNode<AttachmentIssue_AttachmentsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<AttachmentFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentIssue_ChildrenDocument: DocumentNode<AttachmentIssue_ChildrenQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentIssue_CommentsDocument: DocumentNode<AttachmentIssue_CommentsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<CommentFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentIssue_HistoryDocument: DocumentNode<AttachmentIssue_HistoryQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentIssue_InverseRelationsDocument: DocumentNode<AttachmentIssue_InverseRelationsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentIssue_LabelsDocument: DocumentNode<AttachmentIssue_LabelsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueLabelFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentIssue_RelationsDocument: DocumentNode<AttachmentIssue_RelationsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentIssue_SubscribersDocument: DocumentNode<AttachmentIssue_SubscribersQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<UserFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    includeDisabled?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentsDocument: DocumentNode<AttachmentsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<AttachmentFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AttachmentsForUrlDocument: DocumentNode<AttachmentsForUrlQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
    url: Scalars["String"];
}>>;
export declare const AuditEntriesDocument: DocumentNode<AuditEntriesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<AuditEntryFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const AuditEntryTypesDocument: DocumentNode<AuditEntryTypesQuery, Exact<{
    [key: string]: never;
}>>;
export declare const AvailableUsersDocument: DocumentNode<AvailableUsersQuery, Exact<{
    [key: string]: never;
}>>;
export declare const CommentDocument: DocumentNode<CommentQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const Comment_ChildrenDocument: DocumentNode<Comment_ChildrenQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<CommentFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const CommentsDocument: DocumentNode<CommentsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<CommentFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const CustomViewDocument: DocumentNode<CustomViewQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const CustomViewsDocument: DocumentNode<CustomViewsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const CycleDocument: DocumentNode<CycleQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const Cycle_IssuesDocument: DocumentNode<Cycle_IssuesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Cycle_UncompletedIssuesUponCloseDocument: DocumentNode<Cycle_UncompletedIssuesUponCloseQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const CyclesDocument: DocumentNode<CyclesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<CycleFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const DocumentDocument: DocumentNode<DocumentQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const DocumentsDocument: DocumentNode<DocumentsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const EmbedInfoDocument: DocumentNode<EmbedInfoQuery, Exact<{
    url: Scalars["String"];
}>>;
export declare const EmbedInfo_EmbedDocument: DocumentNode<EmbedInfo_EmbedQuery, Exact<{
    url: Scalars["String"];
}>>;
export declare const EmojiDocument: DocumentNode<EmojiQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const EmojisDocument: DocumentNode<EmojisQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const FavoriteDocument: DocumentNode<FavoriteQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const Favorite_ChildrenDocument: DocumentNode<Favorite_ChildrenQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const FavoritesDocument: DocumentNode<FavoritesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const FigmaEmbedInfoDocument: DocumentNode<FigmaEmbedInfoQuery, Exact<{
    fileId: Scalars["String"];
    nodeId?: Maybe<string> | undefined;
}>>;
export declare const FigmaEmbedInfo_FigmaEmbedDocument: DocumentNode<FigmaEmbedInfo_FigmaEmbedQuery, Exact<{
    fileId: Scalars["String"];
    nodeId?: Maybe<string> | undefined;
}>>;
export declare const IntegrationDocument: DocumentNode<IntegrationQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const IntegrationTemplateDocument: DocumentNode<IntegrationTemplateQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const IntegrationTemplatesDocument: DocumentNode<IntegrationTemplatesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IntegrationsDocument: DocumentNode<IntegrationsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IntegrationsSettingsDocument: DocumentNode<IntegrationsSettingsQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const IssueDocument: DocumentNode<IssueQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const Issue_AttachmentsDocument: DocumentNode<Issue_AttachmentsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<AttachmentFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Issue_ChildrenDocument: DocumentNode<Issue_ChildrenQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Issue_CommentsDocument: DocumentNode<Issue_CommentsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<CommentFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Issue_HistoryDocument: DocumentNode<Issue_HistoryQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Issue_InverseRelationsDocument: DocumentNode<Issue_InverseRelationsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Issue_LabelsDocument: DocumentNode<Issue_LabelsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueLabelFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Issue_RelationsDocument: DocumentNode<Issue_RelationsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Issue_SubscribersDocument: DocumentNode<Issue_SubscribersQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<UserFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    includeDisabled?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssueFigmaFileKeySearchDocument: DocumentNode<IssueFigmaFileKeySearchQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    fileKey: Scalars["String"];
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssueFilterSuggestionDocument: DocumentNode<IssueFilterSuggestionQuery, Exact<{
    prompt: Scalars["String"];
}>>;
export declare const IssueImportCheckCsvDocument: DocumentNode<IssueImportCheckCsvQuery, Exact<{
    csvUrl: Scalars["String"];
    service: Scalars["String"];
}>>;
export declare const IssueImportFinishGithubOAuthDocument: DocumentNode<IssueImportFinishGithubOAuthQuery, Exact<{
    code: Scalars["String"];
}>>;
export declare const IssueLabelDocument: DocumentNode<IssueLabelQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const IssueLabel_ChildrenDocument: DocumentNode<IssueLabel_ChildrenQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueLabelFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssueLabel_IssuesDocument: DocumentNode<IssueLabel_IssuesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssueLabelsDocument: DocumentNode<IssueLabelsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueLabelFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssuePriorityValuesDocument: DocumentNode<IssuePriorityValuesQuery, Exact<{
    [key: string]: never;
}>>;
export declare const IssueRelationDocument: DocumentNode<IssueRelationQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const IssueRelationsDocument: DocumentNode<IssueRelationsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssueSearchDocument: DocumentNode<IssueSearchQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
    query?: Maybe<string> | undefined;
}>>;
export declare const IssueVcsBranchSearchDocument: DocumentNode<IssueVcsBranchSearchQuery, Exact<{
    branchName: Scalars["String"];
}>>;
export declare const IssueVcsBranchSearch_AttachmentsDocument: DocumentNode<IssueVcsBranchSearch_AttachmentsQuery, Exact<{
    branchName: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<AttachmentFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssueVcsBranchSearch_ChildrenDocument: DocumentNode<IssueVcsBranchSearch_ChildrenQuery, Exact<{
    branchName: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssueVcsBranchSearch_CommentsDocument: DocumentNode<IssueVcsBranchSearch_CommentsQuery, Exact<{
    branchName: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<CommentFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssueVcsBranchSearch_HistoryDocument: DocumentNode<IssueVcsBranchSearch_HistoryQuery, Exact<{
    branchName: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssueVcsBranchSearch_InverseRelationsDocument: DocumentNode<IssueVcsBranchSearch_InverseRelationsQuery, Exact<{
    branchName: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssueVcsBranchSearch_LabelsDocument: DocumentNode<IssueVcsBranchSearch_LabelsQuery, Exact<{
    branchName: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueLabelFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssueVcsBranchSearch_RelationsDocument: DocumentNode<IssueVcsBranchSearch_RelationsQuery, Exact<{
    branchName: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssueVcsBranchSearch_SubscribersDocument: DocumentNode<IssueVcsBranchSearch_SubscribersQuery, Exact<{
    branchName: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<UserFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    includeDisabled?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const IssuesDocument: DocumentNode<IssuesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const NotificationDocument: DocumentNode<NotificationQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const NotificationSubscriptionDocument: DocumentNode<NotificationSubscriptionQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const NotificationSubscriptionsDocument: DocumentNode<NotificationSubscriptionsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const NotificationsDocument: DocumentNode<NotificationsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const OrganizationDocument: DocumentNode<OrganizationQuery, Exact<{
    [key: string]: never;
}>>;
export declare const Organization_IntegrationsDocument: DocumentNode<Organization_IntegrationsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Organization_LabelsDocument: DocumentNode<Organization_LabelsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueLabelFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Organization_SubscriptionDocument: DocumentNode<Organization_SubscriptionQuery, Exact<{
    [key: string]: never;
}>>;
export declare const Organization_TeamsDocument: DocumentNode<Organization_TeamsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<TeamFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Organization_TemplatesDocument: DocumentNode<Organization_TemplatesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Organization_UsersDocument: DocumentNode<Organization_UsersQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    includeDisabled?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const OrganizationExistsDocument: DocumentNode<OrganizationExistsQuery, Exact<{
    urlKey: Scalars["String"];
}>>;
export declare const OrganizationInviteDocument: DocumentNode<OrganizationInviteQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const OrganizationInvitesDocument: DocumentNode<OrganizationInvitesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const ProjectDocument: DocumentNode<ProjectQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const Project_DocumentsDocument: DocumentNode<Project_DocumentsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Project_IssuesDocument: DocumentNode<Project_IssuesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Project_LinksDocument: DocumentNode<Project_LinksQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Project_MembersDocument: DocumentNode<Project_MembersQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<UserFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    includeDisabled?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Project_ProjectMilestonesDocument: DocumentNode<Project_ProjectMilestonesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Project_ProjectUpdatesDocument: DocumentNode<Project_ProjectUpdatesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Project_TeamsDocument: DocumentNode<Project_TeamsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<TeamFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const ProjectFilterSuggestionDocument: DocumentNode<ProjectFilterSuggestionQuery, Exact<{
    prompt: Scalars["String"];
}>>;
export declare const ProjectLinkDocument: DocumentNode<ProjectLinkQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const ProjectLinksDocument: DocumentNode<ProjectLinksQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const ProjectUpdateDocument: DocumentNode<ProjectUpdateQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const ProjectUpdateInteractionDocument: DocumentNode<ProjectUpdateInteractionQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const ProjectUpdateInteractionsDocument: DocumentNode<ProjectUpdateInteractionsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const ProjectUpdatesDocument: DocumentNode<ProjectUpdatesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const ProjectsDocument: DocumentNode<ProjectsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<ProjectFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const PushSubscriptionTestDocument: DocumentNode<PushSubscriptionTestQuery, Exact<{
    [key: string]: never;
}>>;
export declare const RateLimitStatusDocument: DocumentNode<RateLimitStatusQuery, Exact<{
    [key: string]: never;
}>>;
export declare const RoadmapDocument: DocumentNode<RoadmapQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const Roadmap_ProjectsDocument: DocumentNode<Roadmap_ProjectsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<ProjectFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const RoadmapToProjectDocument: DocumentNode<RoadmapToProjectQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const RoadmapToProjectsDocument: DocumentNode<RoadmapToProjectsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const RoadmapsDocument: DocumentNode<RoadmapsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const SearchDocumentsDocument: DocumentNode<SearchDocumentsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
    term: Scalars["String"];
}>>;
export declare const SearchDocuments_ArchivePayloadDocument: DocumentNode<SearchDocuments_ArchivePayloadQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
    term: Scalars["String"];
}>>;
export declare const SearchIssuesDocument: DocumentNode<SearchIssuesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
    term: Scalars["String"];
}>>;
export declare const SearchIssues_ArchivePayloadDocument: DocumentNode<SearchIssues_ArchivePayloadQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
    term: Scalars["String"];
}>>;
export declare const SearchProjectsDocument: DocumentNode<SearchProjectsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
    term: Scalars["String"];
}>>;
export declare const SearchProjects_ArchivePayloadDocument: DocumentNode<SearchProjects_ArchivePayloadQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
    term: Scalars["String"];
}>>;
export declare const SsoUrlFromEmailDocument: DocumentNode<SsoUrlFromEmailQuery, Exact<{
    email: Scalars["String"];
    isDesktop?: Maybe<boolean> | undefined;
}>>;
export declare const TeamDocument: DocumentNode<TeamQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const Team_CyclesDocument: DocumentNode<Team_CyclesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<CycleFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Team_IssuesDocument: DocumentNode<Team_IssuesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Team_LabelsDocument: DocumentNode<Team_LabelsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueLabelFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Team_MembersDocument: DocumentNode<Team_MembersQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<UserFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    includeDisabled?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Team_MembershipsDocument: DocumentNode<Team_MembershipsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Team_ProjectsDocument: DocumentNode<Team_ProjectsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<ProjectFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Team_StatesDocument: DocumentNode<Team_StatesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<WorkflowStateFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Team_TemplatesDocument: DocumentNode<Team_TemplatesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Team_WebhooksDocument: DocumentNode<Team_WebhooksQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const TeamMembershipDocument: DocumentNode<TeamMembershipQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const TeamMembershipsDocument: DocumentNode<TeamMembershipsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const TeamsDocument: DocumentNode<TeamsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<TeamFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const TemplateDocument: DocumentNode<TemplateQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const TemplatesDocument: DocumentNode<TemplatesQuery, Exact<{
    [key: string]: never;
}>>;
export declare const TemplatesForIntegrationDocument: DocumentNode<TemplatesForIntegrationQuery, Exact<{
    integrationType: Scalars["String"];
}>>;
export declare const UserDocument: DocumentNode<UserQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const User_AssignedIssuesDocument: DocumentNode<User_AssignedIssuesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const User_CreatedIssuesDocument: DocumentNode<User_CreatedIssuesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const User_TeamMembershipsDocument: DocumentNode<User_TeamMembershipsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const User_TeamsDocument: DocumentNode<User_TeamsQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<TeamFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const UserSettingsDocument: DocumentNode<UserSettingsQuery, Exact<{
    [key: string]: never;
}>>;
export declare const UsersDocument: DocumentNode<UsersQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<UserFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    includeDisabled?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const ViewerDocument: DocumentNode<ViewerQuery, Exact<{
    [key: string]: never;
}>>;
export declare const Viewer_AssignedIssuesDocument: DocumentNode<Viewer_AssignedIssuesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Viewer_CreatedIssuesDocument: DocumentNode<Viewer_CreatedIssuesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Viewer_TeamMembershipsDocument: DocumentNode<Viewer_TeamMembershipsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const Viewer_TeamsDocument: DocumentNode<Viewer_TeamsQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<TeamFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const WebhookDocument: DocumentNode<WebhookQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const WebhooksDocument: DocumentNode<WebhooksQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const WorkflowStateDocument: DocumentNode<WorkflowStateQuery, Exact<{
    id: Scalars["String"];
}>>;
export declare const WorkflowState_IssuesDocument: DocumentNode<WorkflowState_IssuesQuery, Exact<{
    id: Scalars["String"];
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<IssueFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export declare const WorkflowStatesDocument: DocumentNode<WorkflowStatesQuery, Exact<{
    after?: Maybe<string> | undefined;
    before?: Maybe<string> | undefined;
    filter?: Maybe<WorkflowStateFilter> | undefined;
    first?: Maybe<number> | undefined;
    includeArchived?: Maybe<boolean> | undefined;
    last?: Maybe<number> | undefined;
    orderBy?: Maybe<PaginationOrderBy> | undefined;
}>>;
export {};
//# sourceMappingURL=_generated_documents.d.ts.map