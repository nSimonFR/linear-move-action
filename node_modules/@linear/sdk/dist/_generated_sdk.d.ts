import { DocumentNode } from "graphql/language/ast";
import * as L from "./_generated_documents";
/** The function for calling the graphql client */
export declare type LinearRequest = <Response, Variables extends Record<string, unknown>>(doc: DocumentNode, variables?: Variables) => Promise<Response>;
/**
 * Base class to provide a request function
 *
 * @param request - function to call the graphql client
 */
export declare class Request {
    protected _request: LinearRequest;
    constructor(request: LinearRequest);
}
/** Fetch return type wrapped in a promise */
export declare type LinearFetch<Response> = Promise<Response>;
/**
 * Variables required for pagination
 * Follows the Relay spec
 */
export declare type LinearConnectionVariables = {
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
/**
 * Connection models containing a list of nodes and pagination information
 * Follows the Relay spec
 */
export declare class LinearConnection<Node> extends Request {
    pageInfo: PageInfo;
    nodes: Node[];
    constructor(request: LinearRequest);
}
/**
 * The base connection class to provide pagination
 * Follows the Relay spec
 *
 * @param request - function to call the graphql client
 * @param fetch - Function to refetch the connection given different pagination variables
 * @param nodes - The list of models to initialize the connection
 * @param pageInfo - The pagination information to initialize the connection
 */
export declare class Connection<Node> extends LinearConnection<Node> {
    private _fetch;
    constructor(request: LinearRequest, fetch: (variables?: LinearConnectionVariables) => LinearFetch<LinearConnection<Node> | undefined>, nodes: Node[], pageInfo: PageInfo);
    /** Add nodes to the end of the existing nodes */
    private _appendNodes;
    /** Add nodes to the start of the existing nodes */
    private _prependNodes;
    /** Update the pagination end cursor */
    private _appendPageInfo;
    /** Update the pagination start cursor */
    private _prependPageInfo;
    /** Fetch the next page of results and append to nodes */
    fetchNext(): Promise<this>;
    /** Fetch the previous page of results and prepend to nodes */
    fetchPrevious(): Promise<this>;
}
/**
 * An API key. Grants access to the user's resources.
 *
 * @param request - function to call the graphql client
 * @param data - L.ApiKeyFragment response data
 */
export declare class ApiKey extends Request {
    constructor(request: LinearRequest, data: L.ApiKeyFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The label of the API key. */
    label: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** Creates a new API key. */
    create(input: L.ApiKeyCreateInput): LinearFetch<ApiKeyPayload>;
    /** Deletes an API key. */
    delete(): LinearFetch<DeletePayload>;
}
/**
 * ApiKeyConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ApiKeyConnection model
 * @param data - ApiKeyConnection response data
 */
export declare class ApiKeyConnection extends Connection<ApiKey> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<ApiKey> | undefined>, data: L.ApiKeyConnectionFragment);
}
/**
 * ApiKeyPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ApiKeyPayloadFragment response data
 */
export declare class ApiKeyPayload extends Request {
    constructor(request: LinearRequest, data: L.ApiKeyPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The API key that was created. */
    apiKey: ApiKey;
}
/**
 * Public information of the OAuth application.
 *
 * @param request - function to call the graphql client
 * @param data - L.ApplicationFragment response data
 */
export declare class Application extends Request {
    constructor(request: LinearRequest, data: L.ApplicationFragment);
    /** OAuth application's client ID. */
    clientId: string;
    /** Information about the application. */
    description?: string;
    /** Name of the developer. */
    developer: string;
    /** Url of the developer (homepage or docs). */
    developerUrl: string;
    /** OAuth application's ID. */
    id: string;
    /** Image of the application. */
    imageUrl?: string;
    /** Application name. */
    name: string;
}
/**
 * A generic payload return from entity archive or deletion mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.ArchivePayloadFragment response data
 */
export declare class ArchivePayload extends Request {
    constructor(request: LinearRequest, data: L.ArchivePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * Contains requested archived model objects.
 *
 * @param request - function to call the graphql client
 * @param data - L.ArchiveResponseFragment response data
 */
export declare class ArchiveResponse extends Request {
    constructor(request: LinearRequest, data: L.ArchiveResponseFragment);
    /** A JSON serialized collection of model objects loaded from the archive */
    archive: string;
    /** The version of the remote database. Incremented by 1 for each migration run on the database. */
    databaseVersion: number;
    /** Whether the dependencies for the model objects are included in the archive. */
    includesDependencies: boolean;
    /** The total number of entities in the archive. */
    totalCount: number;
}
/**
 * Issue attachment (e.g. support ticket, pull request).
 *
 * @param request - function to call the graphql client
 * @param data - L.AttachmentFragment response data
 */
export declare class Attachment extends Request {
    private _creator?;
    private _issue;
    constructor(request: LinearRequest, data: L.AttachmentFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Indicates if attachments for the same source application should be grouped in the Linear UI. */
    groupBySource: boolean;
    /** The unique identifier of the entity. */
    id: string;
    /** Custom metadata related to the attachment. */
    metadata: Record<string, unknown>;
    /** Information about the source which created the attachment. */
    source?: Record<string, unknown>;
    /** An accessor helper to source.type, defines the source type of the attachment. */
    sourceType?: string;
    /** Content for the subtitle line in the Linear attachment widget. */
    subtitle?: string;
    /** Content for the title line in the Linear attachment widget. */
    title: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** Location of the attachment which is also used as an identifier. */
    url: string;
    /** The creator of the attachment. */
    get creator(): LinearFetch<User> | undefined;
    /** The issue this attachment belongs to. */
    get issue(): LinearFetch<Issue> | undefined;
    /** [DEPRECATED] Archives an issue attachment. */
    archive(): LinearFetch<AttachmentArchivePayload>;
    /** Creates a new attachment, or updates existing if the same `url` and `issueId` is used. */
    create(input: L.AttachmentCreateInput): LinearFetch<AttachmentPayload>;
    /** Deletes an issue attachment. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates an existing issue attachment. */
    update(input: L.AttachmentUpdateInput): LinearFetch<AttachmentPayload>;
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.AttachmentArchivePayloadFragment response data
 */
export declare class AttachmentArchivePayload extends Request {
    private _entity?;
    constructor(request: LinearRequest, data: L.AttachmentArchivePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The archived/unarchived entity. Null if entity was deleted. */
    get entity(): LinearFetch<Attachment> | undefined;
}
/**
 * AttachmentConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this AttachmentConnection model
 * @param data - AttachmentConnection response data
 */
export declare class AttachmentConnection extends Connection<Attachment> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Attachment> | undefined>, data: L.AttachmentConnectionFragment);
}
/**
 * AttachmentPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.AttachmentPayloadFragment response data
 */
export declare class AttachmentPayload extends Request {
    private _attachment;
    constructor(request: LinearRequest, data: L.AttachmentPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The issue attachment that was created. */
    get attachment(): LinearFetch<Attachment> | undefined;
}
/**
 * AttachmentSourcesPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.AttachmentSourcesPayloadFragment response data
 */
export declare class AttachmentSourcesPayload extends Request {
    constructor(request: LinearRequest, data: L.AttachmentSourcesPayloadFragment);
    /** A unique list of all source types used in this workspace */
    sources: Record<string, unknown>;
}
/**
 * Workspace audit log entry object.
 *
 * @param request - function to call the graphql client
 * @param data - L.AuditEntryFragment response data
 */
export declare class AuditEntry extends Request {
    private _actor?;
    constructor(request: LinearRequest, data: L.AuditEntryFragment);
    /** The ID of the user that caused the audit entry to be created. */
    actorId?: string;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** Country code of request resulting to audit entry. */
    countryCode?: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** IP from actor when entry was recorded. */
    ip?: string;
    /** Additional metadata related to the audit entry. */
    metadata?: Record<string, unknown>;
    /** Additional information related to the request which performed the action. */
    requestInformation?: Record<string, unknown>;
    type: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The user that caused the audit entry to be created. */
    get actor(): LinearFetch<User> | undefined;
    /** The organization the audit log belongs to. */
    get organization(): LinearFetch<Organization>;
}
/**
 * AuditEntryConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this AuditEntryConnection model
 * @param data - AuditEntryConnection response data
 */
export declare class AuditEntryConnection extends Connection<AuditEntry> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<AuditEntry> | undefined>, data: L.AuditEntryConnectionFragment);
}
/**
 * AuditEntryType model
 *
 * @param request - function to call the graphql client
 * @param data - L.AuditEntryTypeFragment response data
 */
export declare class AuditEntryType extends Request {
    constructor(request: LinearRequest, data: L.AuditEntryTypeFragment);
    /** Description of the audit entry type. */
    description: string;
    /** The audit entry type. */
    type: string;
}
/**
 * AuthResolverResponse model
 *
 * @param request - function to call the graphql client
 * @param data - L.AuthResolverResponseFragment response data
 */
export declare class AuthResolverResponse extends Request {
    constructor(request: LinearRequest, data: L.AuthResolverResponseFragment);
    /** Should the signup flow allow access for the domain. */
    allowDomainAccess?: boolean;
    /** Email for the authenticated account. */
    email?: string;
    /** User account ID. */
    id: string;
    /** ID of the organization last accessed by the user. */
    lastUsedOrganizationId?: string;
    /** JWT token for authentication of the account. */
    token?: string;
    /** Organizations this account has access to, but is not yet a member. */
    availableOrganizations?: Organization[];
    /** Users belonging to this account. */
    users: User[];
}
/**
 * A comment associated with an issue.
 *
 * @param request - function to call the graphql client
 * @param data - L.CommentFragment response data
 */
export declare class Comment extends Request {
    private _issue;
    private _parent?;
    private _user?;
    constructor(request: LinearRequest, data: L.CommentFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The comment content in markdown format. */
    body: string;
    /** The comment content as a Prosemirror document. */
    bodyData: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The time user edited the comment. */
    editedAt?: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** Emoji reaction summary, grouped by emoji type */
    reactionData: Record<string, unknown>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** Comment's URL. */
    url: string;
    /** The issue that the comment is associated with. */
    get issue(): LinearFetch<Issue> | undefined;
    /** The parent comment under which the current comment is nested. */
    get parent(): LinearFetch<Comment> | undefined;
    /** The user who wrote the comment. */
    get user(): LinearFetch<User> | undefined;
    /** The children of the comment. */
    children(variables?: Omit<L.Comment_ChildrenQueryVariables, "id">): LinearFetch<CommentConnection>;
    /** Creates a new comment. */
    create(input: L.CommentCreateInput): LinearFetch<CommentPayload>;
    /** Deletes a comment. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates a comment. */
    update(input: L.CommentUpdateInput): LinearFetch<CommentPayload>;
}
/**
 * CommentConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this CommentConnection model
 * @param data - CommentConnection response data
 */
export declare class CommentConnection extends Connection<Comment> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Comment> | undefined>, data: L.CommentConnectionFragment);
}
/**
 * CommentPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CommentPayloadFragment response data
 */
export declare class CommentPayload extends Request {
    private _comment;
    constructor(request: LinearRequest, data: L.CommentPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The comment that was created or updated. */
    get comment(): LinearFetch<Comment> | undefined;
}
/**
 * A company related to issue's origin.
 *
 * @param request - function to call the graphql client
 * @param data - L.CompanyFragment response data
 */
export declare class Company extends Request {
    private _creator;
    constructor(request: LinearRequest, data: L.CompanyFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** Custom company properties. */
    companyProperties: Record<string, unknown>;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Company ID in an external system. */
    externalId: string;
    /** The unique identifier of the entity. */
    id: string;
    /** Company logo URL. */
    logoUrl?: string;
    /** Company name. */
    name: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** Company website URL. */
    websiteUrl?: string;
    /** The user who added the company. */
    get creator(): LinearFetch<User> | undefined;
    /** The organization of the customer. */
    get organization(): LinearFetch<Organization>;
}
/**
 * CompanyConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this CompanyConnection model
 * @param data - CompanyConnection response data
 */
export declare class CompanyConnection extends Connection<Company> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Company> | undefined>, data: L.CompanyConnectionFragment);
}
/**
 * ContactPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ContactPayloadFragment response data
 */
export declare class ContactPayload extends Request {
    constructor(request: LinearRequest, data: L.ContactPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * CreateCsvExportReportPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CreateCsvExportReportPayloadFragment response data
 */
export declare class CreateCsvExportReportPayload extends Request {
    constructor(request: LinearRequest, data: L.CreateCsvExportReportPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * CreateOrJoinOrganizationResponse model
 *
 * @param request - function to call the graphql client
 * @param data - L.CreateOrJoinOrganizationResponseFragment response data
 */
export declare class CreateOrJoinOrganizationResponse extends Request {
    private _user;
    constructor(request: LinearRequest, data: L.CreateOrJoinOrganizationResponseFragment);
    get organization(): LinearFetch<Organization>;
    get user(): LinearFetch<User> | undefined;
}
/**
 * A custom view that has been saved by a user.
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomViewFragment response data
 */
export declare class CustomView extends Request {
    private _creator;
    private _team?;
    constructor(request: LinearRequest, data: L.CustomViewFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The color of the icon of the custom view. */
    color?: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The description of the custom view. */
    description?: string;
    /** The filter applied to issues in the custom view. */
    filterData: Record<string, unknown>;
    /** The filters applied to issues in the custom view. */
    filters: Record<string, unknown>;
    /** The icon of the custom view. */
    icon?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The name of the custom view. */
    name: string;
    /** Whether the custom view is shared with everyone in the organization. */
    shared: boolean;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The user who created the custom view. */
    get creator(): LinearFetch<User> | undefined;
    /** The organization of the custom view. */
    get organization(): LinearFetch<Organization>;
    /** The team associated with the custom view. */
    get team(): LinearFetch<Team> | undefined;
    /** Creates a new custom view. */
    create(input: L.CustomViewCreateInput): LinearFetch<CustomViewPayload>;
    /** Deletes a custom view. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates a custom view. */
    update(input: L.CustomViewUpdateInput): LinearFetch<CustomViewPayload>;
}
/**
 * CustomViewConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this CustomViewConnection model
 * @param data - CustomViewConnection response data
 */
export declare class CustomViewConnection extends Connection<CustomView> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<CustomView> | undefined>, data: L.CustomViewConnectionFragment);
}
/**
 * A custom view notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomViewNotificationSubscriptionFragment response data
 */
export declare class CustomViewNotificationSubscription extends Request {
    private _customView;
    private _cycle?;
    private _label?;
    private _project?;
    private _subscriber;
    private _team?;
    private _user?;
    constructor(request: LinearRequest, data: L.CustomViewNotificationSubscriptionFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The type of subscription. */
    notificationSubscriptionTypes: string[];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The custom view subscribed to. */
    get customView(): LinearFetch<CustomView> | undefined;
    /** The contextual cycle view associated with the notification subscription. */
    get cycle(): LinearFetch<Cycle> | undefined;
    /** The contextual label view associated with the notification subscription. */
    get label(): LinearFetch<IssueLabel> | undefined;
    /** The contextual project view associated with the notification subscription. */
    get project(): LinearFetch<Project> | undefined;
    /** The user that subscribed to receive notifications. */
    get subscriber(): LinearFetch<User> | undefined;
    /** The team associated with the notification subscription. */
    get team(): LinearFetch<Team> | undefined;
    /** The user view associated with the notification subscription. */
    get user(): LinearFetch<User> | undefined;
}
/**
 * CustomViewPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomViewPayloadFragment response data
 */
export declare class CustomViewPayload extends Request {
    private _customView;
    constructor(request: LinearRequest, data: L.CustomViewPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The custom view that was created or updated. */
    get customView(): LinearFetch<CustomView> | undefined;
}
/**
 * CustomViewSuggestionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomViewSuggestionPayloadFragment response data
 */
export declare class CustomViewSuggestionPayload extends Request {
    constructor(request: LinearRequest, data: L.CustomViewSuggestionPayloadFragment);
    /** The suggested view description. */
    description?: string;
    /** The suggested view icon. */
    icon?: string;
    /** The suggested view name. */
    name?: string;
}
/**
 * A set of issues to be resolved in a specified amount of time.
 *
 * @param request - function to call the graphql client
 * @param data - L.CycleFragment response data
 */
export declare class Cycle extends Request {
    private _team;
    constructor(request: LinearRequest, data: L.CycleFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the cycle was automatically archived by the auto pruning process. */
    autoArchivedAt?: Date;
    /** The completion time of the cycle. If null, the cycle hasn't been completed. */
    completedAt?: Date;
    /** The number of completed issues in the cycle after each day. */
    completedIssueCountHistory: number[];
    /** The number of completed estimation points after each day. */
    completedScopeHistory: number[];
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The cycle's description. */
    description?: string;
    /** The end time of the cycle. */
    endsAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The number of in progress estimation points after each day. */
    inProgressScopeHistory: number[];
    /** The total number of issues in the cycle after each day. */
    issueCountHistory: number[];
    /** The custom name of the cycle. */
    name?: string;
    /** The number of the cycle. */
    number: number;
    /** The overall progress of the cycle. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points. */
    progress: number;
    /** The total number of estimation points after each day. */
    scopeHistory: number[];
    /** The start time of the cycle. */
    startsAt: Date;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The team that the cycle is associated with. */
    get team(): LinearFetch<Team> | undefined;
    /** Issues associated with the cycle. */
    issues(variables?: Omit<L.Cycle_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Issues that weren't completed when the cycle was closed. */
    uncompletedIssuesUponClose(variables?: Omit<L.Cycle_UncompletedIssuesUponCloseQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Archives a cycle. */
    archive(): LinearFetch<CycleArchivePayload>;
    /** Creates a new cycle. */
    create(input: L.CycleCreateInput): LinearFetch<CyclePayload>;
    /** Updates a cycle. */
    update(input: L.CycleUpdateInput): LinearFetch<CyclePayload>;
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.CycleArchivePayloadFragment response data
 */
export declare class CycleArchivePayload extends Request {
    private _entity?;
    constructor(request: LinearRequest, data: L.CycleArchivePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The archived/unarchived entity. Null if entity was deleted. */
    get entity(): LinearFetch<Cycle> | undefined;
}
/**
 * CycleConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this CycleConnection model
 * @param data - CycleConnection response data
 */
export declare class CycleConnection extends Connection<Cycle> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Cycle> | undefined>, data: L.CycleConnectionFragment);
}
/**
 * A cycle notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.CycleNotificationSubscriptionFragment response data
 */
export declare class CycleNotificationSubscription extends Request {
    private _customView?;
    private _cycle;
    private _label?;
    private _project?;
    private _subscriber;
    private _team?;
    private _user?;
    constructor(request: LinearRequest, data: L.CycleNotificationSubscriptionFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The type of subscription. */
    notificationSubscriptionTypes: string[];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The contextual custom view associated with the notification subscription. */
    get customView(): LinearFetch<CustomView> | undefined;
    /** The cycle subscribed to. */
    get cycle(): LinearFetch<Cycle> | undefined;
    /** The contextual label view associated with the notification subscription. */
    get label(): LinearFetch<IssueLabel> | undefined;
    /** The contextual project view associated with the notification subscription. */
    get project(): LinearFetch<Project> | undefined;
    /** The user that subscribed to receive notifications. */
    get subscriber(): LinearFetch<User> | undefined;
    /** The team associated with the notification subscription. */
    get team(): LinearFetch<Team> | undefined;
    /** The user view associated with the notification subscription. */
    get user(): LinearFetch<User> | undefined;
}
/**
 * CyclePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CyclePayloadFragment response data
 */
export declare class CyclePayload extends Request {
    private _cycle?;
    constructor(request: LinearRequest, data: L.CyclePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The Cycle that was created or updated. */
    get cycle(): LinearFetch<Cycle> | undefined;
}
/**
 * A generic payload return from entity deletion mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.DeletePayloadFragment response data
 */
export declare class DeletePayload extends Request {
    constructor(request: LinearRequest, data: L.DeletePayloadFragment);
    /** The identifier of the deleted entity. */
    entityId: string;
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * A document for a project.
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentFragment response data
 */
export declare class Document extends Request {
    private _creator;
    private _project;
    private _updatedBy;
    constructor(request: LinearRequest, data: L.DocumentFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The color of the icon. */
    color?: string;
    /** The document content in markdown format. */
    content?: string;
    /** The document content as JSON. */
    contentData?: Record<string, unknown>;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The icon of the document. */
    icon?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The document's unique URL slug. */
    slugId: string;
    /** The document title. */
    title: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The user who created the document. */
    get creator(): LinearFetch<User> | undefined;
    /** The project that the document is associated with. */
    get project(): LinearFetch<Project> | undefined;
    /** The user who last updated the document. */
    get updatedBy(): LinearFetch<User> | undefined;
    /** Creates a new document. */
    create(input: L.DocumentCreateInput): LinearFetch<DocumentPayload>;
    /** Deletes a document. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates a document. */
    update(input: L.DocumentUpdateInput): LinearFetch<DocumentPayload>;
}
/**
 * DocumentConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this DocumentConnection model
 * @param data - DocumentConnection response data
 */
export declare class DocumentConnection extends Connection<Document> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Document> | undefined>, data: L.DocumentConnectionFragment);
}
/**
 * A document content for a project.
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentContentFragment response data
 */
export declare class DocumentContent extends Request {
    private _issue?;
    constructor(request: LinearRequest, data: L.DocumentContentFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The document content in markdown format. */
    content?: string;
    /** The document content as JSON. */
    contentData?: Record<string, unknown>;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The issue that the document is associated with. */
    get issue(): LinearFetch<Issue> | undefined;
}
/**
 * DocumentPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentPayloadFragment response data
 */
export declare class DocumentPayload extends Request {
    private _document;
    constructor(request: LinearRequest, data: L.DocumentPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The document that was created or updated. */
    get document(): LinearFetch<Document> | undefined;
}
/**
 * DocumentSearchPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentSearchPayloadFragment response data
 */
export declare class DocumentSearchPayload extends Request {
    constructor(request: LinearRequest, data: L.DocumentSearchPayloadFragment);
    /** Total number of results for query without filters applied. */
    totalCount: number;
    nodes: DocumentSearchResult[];
    /** Archived entities matching the search term along with all their dependencies. */
    archivePayload: ArchiveResponse;
    pageInfo: PageInfo;
}
/**
 * DocumentSearchResult model
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentSearchResultFragment response data
 */
export declare class DocumentSearchResult extends Request {
    private _creator;
    private _project;
    private _updatedBy;
    constructor(request: LinearRequest, data: L.DocumentSearchResultFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The color of the icon. */
    color?: string;
    /** The document content in markdown format. */
    content?: string;
    /** The document content as JSON. */
    contentData?: Record<string, unknown>;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The icon of the document. */
    icon?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** Metadata related to search result */
    metadata: Record<string, unknown>;
    /** The document's unique URL slug. */
    slugId: string;
    /** The document title. */
    title: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The user who created the document. */
    get creator(): LinearFetch<User> | undefined;
    /** The project that the document is associated with. */
    get project(): LinearFetch<Project> | undefined;
    /** The user who last updated the document. */
    get updatedBy(): LinearFetch<User> | undefined;
}
/**
 * DocumentSearchResultConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this DocumentSearchResultConnection model
 * @param data - DocumentSearchResultConnection response data
 */
export declare class DocumentSearchResultConnection extends Connection<DocumentSearchResult> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<DocumentSearchResult> | undefined>, data: L.DocumentSearchResultConnectionFragment);
}
/**
 * EmailUnsubscribePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.EmailUnsubscribePayloadFragment response data
 */
export declare class EmailUnsubscribePayload extends Request {
    constructor(request: LinearRequest, data: L.EmailUnsubscribePayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * EmailUserAccountAuthChallengeResponse model
 *
 * @param request - function to call the graphql client
 * @param data - L.EmailUserAccountAuthChallengeResponseFragment response data
 */
export declare class EmailUserAccountAuthChallengeResponse extends Request {
    constructor(request: LinearRequest, data: L.EmailUserAccountAuthChallengeResponseFragment);
    /** Supported challenge for this user account. Can be either verificationCode or password. */
    authType: string;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * Information for creating embedded content for the provided URL
 *
 * @param request - function to call the graphql client
 * @param data - L.EmbedFragment response data
 */
export declare class Embed extends Request {
    constructor(request: LinearRequest, data: L.EmbedFragment);
    /** The name of the author/owner of the resource */
    authorName?: string;
    /** The description of the content */
    description?: string;
    /** The height of embedded content (photo, video, rich) */
    height?: number;
    /** The HTML (video, rich) */
    html?: string;
    /** The name of the provider */
    providerName?: string;
    /** The height of the thumbnail preview image */
    thumbnailHeight?: number;
    /** The URL of the thumbnail preview image */
    thumbnailUrl?: string;
    /** The width of the thumbnail preview image */
    thumbnailWidth?: number;
    /** Title for the returned embed view */
    title?: string;
    /** The type of embed */
    type: string;
    /** The asset URL (photo) */
    url?: string;
    /** The width of embedded content (photo, video, rich) */
    width?: number;
}
/**
 * EmbedPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.EmbedPayloadFragment response data
 */
export declare class EmbedPayload extends Request {
    constructor(request: LinearRequest, data: L.EmbedPayloadFragment);
    /** Whether the query was successful */
    success: boolean;
    /** Embed information */
    embed?: Embed;
}
/**
 * A custom emoji.
 *
 * @param request - function to call the graphql client
 * @param data - L.EmojiFragment response data
 */
export declare class Emoji extends Request {
    private _creator;
    constructor(request: LinearRequest, data: L.EmojiFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The emoji's name. */
    name: string;
    /** The source of the emoji. */
    source: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The emoji image URL. */
    url: string;
    /** The user who created the emoji. */
    get creator(): LinearFetch<User> | undefined;
    /** The organization that the emoji belongs to. */
    get organization(): LinearFetch<Organization>;
    /** Creates a custom emoji. */
    create(input: L.EmojiCreateInput): LinearFetch<EmojiPayload>;
    /** Deletes an emoji. */
    delete(): LinearFetch<DeletePayload>;
}
/**
 * EmojiConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this EmojiConnection model
 * @param data - EmojiConnection response data
 */
export declare class EmojiConnection extends Connection<Emoji> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Emoji> | undefined>, data: L.EmojiConnectionFragment);
}
/**
 * EmojiPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.EmojiPayloadFragment response data
 */
export declare class EmojiPayload extends Request {
    private _emoji;
    constructor(request: LinearRequest, data: L.EmojiPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The emoji that was created. */
    get emoji(): LinearFetch<Emoji> | undefined;
}
/**
 * A basic entity.
 *
 * @param request - function to call the graphql client
 * @param data - L.EntityFragment response data
 */
export declare class Entity extends Request {
    constructor(request: LinearRequest, data: L.EntityFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
}
/**
 * User favorites presented in the sidebar.
 *
 * @param request - function to call the graphql client
 * @param data - L.FavoriteFragment response data
 */
export declare class Favorite extends Request {
    private _customView?;
    private _cycle?;
    private _document?;
    private _issue?;
    private _label?;
    private _owner;
    private _parent?;
    private _predefinedViewTeam?;
    private _project?;
    private _projectTeam?;
    private _roadmap?;
    private _user?;
    constructor(request: LinearRequest, data: L.FavoriteFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The name of the folder. Only applies to favorites of type folder. */
    folderName?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The type of favorited predefined view. */
    predefinedViewType?: string;
    /** The order of the item in the favorites list. */
    sortOrder: number;
    /** The type of the favorite. */
    type: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The favorited custom view. */
    get customView(): LinearFetch<CustomView> | undefined;
    /** The favorited cycle. */
    get cycle(): LinearFetch<Cycle> | undefined;
    /** The favorited document. */
    get document(): LinearFetch<Document> | undefined;
    /** The favorited issue. */
    get issue(): LinearFetch<Issue> | undefined;
    /** The favorited label. */
    get label(): LinearFetch<IssueLabel> | undefined;
    /** The owner of the favorite. */
    get owner(): LinearFetch<User> | undefined;
    /** The parent folder of the favorite. */
    get parent(): LinearFetch<Favorite> | undefined;
    /** The team of the favorited predefined view. */
    get predefinedViewTeam(): LinearFetch<Team> | undefined;
    /** The favorited project. */
    get project(): LinearFetch<Project> | undefined;
    /** The favorited team of the project. */
    get projectTeam(): LinearFetch<Team> | undefined;
    /** The favorited roadmap. */
    get roadmap(): LinearFetch<Roadmap> | undefined;
    /** The favorited user. */
    get user(): LinearFetch<User> | undefined;
    /** Children of the favorite. Only applies to favorites of type folder. */
    children(variables?: Omit<L.Favorite_ChildrenQueryVariables, "id">): LinearFetch<FavoriteConnection>;
    /** Creates a new favorite (project, cycle etc). */
    create(input: L.FavoriteCreateInput): LinearFetch<FavoritePayload>;
    /** Deletes a favorite reference. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates a favorite. */
    update(input: L.FavoriteUpdateInput): LinearFetch<FavoritePayload>;
}
/**
 * FavoriteConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this FavoriteConnection model
 * @param data - FavoriteConnection response data
 */
export declare class FavoriteConnection extends Connection<Favorite> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Favorite> | undefined>, data: L.FavoriteConnectionFragment);
}
/**
 * FavoritePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.FavoritePayloadFragment response data
 */
export declare class FavoritePayload extends Request {
    private _favorite;
    constructor(request: LinearRequest, data: L.FavoritePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The object that was added as a favorite. */
    get favorite(): LinearFetch<Favorite> | undefined;
}
/**
 * Object representing Figma preview information.
 *
 * @param request - function to call the graphql client
 * @param data - L.FigmaEmbedFragment response data
 */
export declare class FigmaEmbed extends Request {
    constructor(request: LinearRequest, data: L.FigmaEmbedFragment);
    /** Date when the file was updated at the time of embedding. */
    lastModified: Date;
    /** Figma file name. */
    name: string;
    /** Node name. */
    nodeName?: string;
    /** Figma screenshot URL. */
    url?: string;
}
/**
 * FigmaEmbedPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.FigmaEmbedPayloadFragment response data
 */
export declare class FigmaEmbedPayload extends Request {
    constructor(request: LinearRequest, data: L.FigmaEmbedPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
    /** Figma embed information. */
    figmaEmbed?: FigmaEmbed;
}
/**
 * A schedule for a team's first responder.
 *
 * @param request - function to call the graphql client
 * @param data - L.FirstResponderScheduleFragment response data
 */
export declare class FirstResponderSchedule extends Request {
    private _integration;
    private _team;
    constructor(request: LinearRequest, data: L.FirstResponderScheduleFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The id of the integration schedule used for scheduling. */
    integrationScheduleId?: string;
    /** The current schedule and available schedules. */
    scheduleData: Record<string, unknown>;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The integration used for scheduling. */
    get integration(): LinearFetch<Integration> | undefined;
    /** The team to which the schedule belongs to. */
    get team(): LinearFetch<Team> | undefined;
}
/**
 * FirstResponderScheduleConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this FirstResponderScheduleConnection model
 * @param data - FirstResponderScheduleConnection response data
 */
export declare class FirstResponderScheduleConnection extends Connection<FirstResponderSchedule> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<FirstResponderSchedule> | undefined>, data: L.FirstResponderScheduleConnectionFragment);
}
/**
 * FrontAttachmentPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.FrontAttachmentPayloadFragment response data
 */
export declare class FrontAttachmentPayload extends Request {
    constructor(request: LinearRequest, data: L.FrontAttachmentPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * Front specific settings.
 *
 * @param request - function to call the graphql client
 * @param data - L.FrontSettingsFragment response data
 */
export declare class FrontSettings extends Request {
    constructor(request: LinearRequest, data: L.FrontSettingsFragment);
    /** Whether a ticket should be automatically reopened when its linked Linear issue is cancelled. */
    automateTicketReopeningOnCancellation?: boolean;
    /** Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue */
    automateTicketReopeningOnComment?: boolean;
    /** Whether a ticket should be automatically reopened when its linked Linear issue is completed. */
    automateTicketReopeningOnCompletion?: boolean;
    /** Whether an internal message should be added when someone comments on an issue. */
    sendNoteOnComment?: boolean;
    /** Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled). */
    sendNoteOnStatusChange?: boolean;
}
/**
 * GitHubCommitIntegrationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.GitHubCommitIntegrationPayloadFragment response data
 */
export declare class GitHubCommitIntegrationPayload extends Request {
    private _integration?;
    constructor(request: LinearRequest, data: L.GitHubCommitIntegrationPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The webhook secret to provide to GitHub. */
    webhookSecret: string;
    /** The integration that was created or updated. */
    get integration(): LinearFetch<Integration> | undefined;
}
/**
 * Metadata and settings for a GitHub integration.
 *
 * @param request - function to call the graphql client
 * @param data - L.GitHubSettingsFragment response data
 */
export declare class GitHubSettings extends Request {
    constructor(request: LinearRequest, data: L.GitHubSettingsFragment);
    /** The avatar URL for the GitHub organization */
    orgAvatarUrl: string;
    /** The GitHub organization's name */
    orgLogin: string;
}
/**
 * GitHub OAuth token, plus information about the organizations the user is a member of.
 *
 * @param request - function to call the graphql client
 * @param data - L.GithubOAuthTokenPayloadFragment response data
 */
export declare class GithubOAuthTokenPayload extends Request {
    constructor(request: LinearRequest, data: L.GithubOAuthTokenPayloadFragment);
    /** The OAuth token if the operation to fetch it was successful. */
    token?: string;
    /** A list of the GitHub organizations the user is a member of with attached repositories. */
    organizations?: GithubOrg[];
}
/**
 * Relevant information for the GitHub organization.
 *
 * @param request - function to call the graphql client
 * @param data - L.GithubOrgFragment response data
 */
export declare class GithubOrg extends Request {
    constructor(request: LinearRequest, data: L.GithubOrgFragment);
    /** GitHub organization id. */
    id: string;
    /** Whether or not this org is the user's personal repositories. */
    isPersonal?: boolean;
    /** The login for the GitHub organization. */
    login: string;
    /** The name of the GitHub organization. */
    name: string;
    /** Repositories that the organization owns. */
    repositories: GithubRepo[];
}
/**
 * Relevant information for the GitHub repository.
 *
 * @param request - function to call the graphql client
 * @param data - L.GithubRepoFragment response data
 */
export declare class GithubRepo extends Request {
    constructor(request: LinearRequest, data: L.GithubRepoFragment);
    /** The id of the GitHub repository. */
    id: string;
    /** The name of the GitHub repository. */
    name: string;
}
/**
 * Google Sheets specific settings.
 *
 * @param request - function to call the graphql client
 * @param data - L.GoogleSheetsSettingsFragment response data
 */
export declare class GoogleSheetsSettings extends Request {
    constructor(request: LinearRequest, data: L.GoogleSheetsSettingsFragment);
    sheetId: number;
    spreadsheetId: string;
    spreadsheetUrl: string;
    updatedIssuesAt: Date;
}
/**
 * ImageUploadFromUrlPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ImageUploadFromUrlPayloadFragment response data
 */
export declare class ImageUploadFromUrlPayload extends Request {
    constructor(request: LinearRequest, data: L.ImageUploadFromUrlPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The URL containing the image. */
    url?: string;
}
/**
 * An integration with an external service.
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationFragment response data
 */
export declare class Integration extends Request {
    private _creator;
    private _team?;
    constructor(request: LinearRequest, data: L.IntegrationFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The integration's type. */
    service: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The user that added the integration. */
    get creator(): LinearFetch<User> | undefined;
    /** The organization that the integration is associated with. */
    get organization(): LinearFetch<Organization>;
    /** The team that the integration is associated with. */
    get team(): LinearFetch<Team> | undefined;
    /** Deletes an integration. */
    delete(): LinearFetch<DeletePayload>;
}
/**
 * IntegrationConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IntegrationConnection model
 * @param data - IntegrationConnection response data
 */
export declare class IntegrationConnection extends Connection<Integration> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Integration> | undefined>, data: L.IntegrationConnectionFragment);
}
/**
 * IntegrationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationPayloadFragment response data
 */
export declare class IntegrationPayload extends Request {
    private _integration?;
    constructor(request: LinearRequest, data: L.IntegrationPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The integration that was created or updated. */
    get integration(): LinearFetch<Integration> | undefined;
}
/**
 * IntegrationRequestPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationRequestPayloadFragment response data
 */
export declare class IntegrationRequestPayload extends Request {
    constructor(request: LinearRequest, data: L.IntegrationRequestPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * The integration resource's settings
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationSettingsFragment response data
 */
export declare class IntegrationSettings extends Request {
    constructor(request: LinearRequest, data: L.IntegrationSettingsFragment);
    front?: FrontSettings;
    gitHub?: GitHubSettings;
    googleSheets?: GoogleSheetsSettings;
    intercom?: IntercomSettings;
    jira?: JiraSettings;
    notion?: NotionSettings;
    pagerDuty?: PagerDutySettings;
    sentry?: SentrySettings;
    slackOrgProjectUpdatesPost?: SlackPostSettings;
    slackPost?: SlackPostSettings;
    slackProjectPost?: SlackPostSettings;
    zendesk?: ZendeskSettings;
}
/**
 * Join table between templates and integrations
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationTemplateFragment response data
 */
export declare class IntegrationTemplate extends Request {
    private _integration;
    private _template;
    constructor(request: LinearRequest, data: L.IntegrationTemplateFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The integration that the template is associated with. */
    get integration(): LinearFetch<Integration> | undefined;
    /** The template that the integration is associated with. */
    get template(): LinearFetch<Template> | undefined;
    /** Creates a new integrationTemplate join. */
    create(input: L.IntegrationTemplateCreateInput): LinearFetch<IntegrationTemplatePayload>;
    /** Deletes a integrationTemplate. */
    delete(): LinearFetch<DeletePayload>;
}
/**
 * IntegrationTemplateConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IntegrationTemplateConnection model
 * @param data - IntegrationTemplateConnection response data
 */
export declare class IntegrationTemplateConnection extends Connection<IntegrationTemplate> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<IntegrationTemplate> | undefined>, data: L.IntegrationTemplateConnectionFragment);
}
/**
 * IntegrationTemplatePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationTemplatePayloadFragment response data
 */
export declare class IntegrationTemplatePayload extends Request {
    private _integrationTemplate;
    constructor(request: LinearRequest, data: L.IntegrationTemplatePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The IntegrationTemplate that was created or updated. */
    get integrationTemplate(): LinearFetch<IntegrationTemplate> | undefined;
}
/**
 * The configuration of all integrations for a project or a team.
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationsSettingsFragment response data
 */
export declare class IntegrationsSettings extends Request {
    private _project?;
    private _team?;
    constructor(request: LinearRequest, data: L.IntegrationsSettingsFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** Whether to send a Slack message when a new issue is added to triage. */
    slackIssueAddedToTriage?: boolean;
    /** Whether to send a Slack message when a new issue is created for the project or the team. */
    slackIssueCreated?: boolean;
    /** Whether to send a Slack message when a comment is created on any of the project or team's issues. */
    slackIssueNewComment?: boolean;
    /** Whether to send a Slack message when an SLA is breached */
    slackIssueSlaBreached?: boolean;
    /** Whether to send a Slack message when an SLA is at high risk */
    slackIssueSlaHighRisk?: boolean;
    /** Whether to send a Slack message when any of the project or team's issues has a change in status. */
    slackIssueStatusChangedAll?: boolean;
    /** Whether to send a Slack message when any of the project or team's issues change to completed or cancelled. */
    slackIssueStatusChangedDone?: boolean;
    /** Whether to send a Slack message when a project update is created. */
    slackProjectUpdateCreated?: boolean;
    /** Whether to send a new project update to team Slack channels. */
    slackProjectUpdateCreatedToTeam?: boolean;
    /** Whether to send a new project update to workspace Slack channel. */
    slackProjectUpdateCreatedToWorkspace?: boolean;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** Project which those settings apply to. */
    get project(): LinearFetch<Project> | undefined;
    /** Team which those settings apply to. */
    get team(): LinearFetch<Team> | undefined;
    /** Creates new settings for one or more integrations. */
    create(input: L.IntegrationsSettingsCreateInput): LinearFetch<IntegrationsSettingsPayload>;
    /** Updates settings related to integrations for a project or a team. */
    update(input: L.IntegrationsSettingsUpdateInput): LinearFetch<IntegrationsSettingsPayload>;
}
/**
 * IntegrationsSettingsConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IntegrationsSettingsConnection model
 * @param data - IntegrationsSettingsConnection response data
 */
export declare class IntegrationsSettingsConnection extends Connection<IntegrationsSettings> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<IntegrationsSettings> | undefined>, data: L.IntegrationsSettingsConnectionFragment);
}
/**
 * IntegrationsSettingsPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationsSettingsPayloadFragment response data
 */
export declare class IntegrationsSettingsPayload extends Request {
    private _integrationsSettings;
    constructor(request: LinearRequest, data: L.IntegrationsSettingsPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The settings that were created or updated. */
    get integrationsSettings(): LinearFetch<IntegrationsSettings> | undefined;
}
/**
 * Intercom specific settings.
 *
 * @param request - function to call the graphql client
 * @param data - L.IntercomSettingsFragment response data
 */
export declare class IntercomSettings extends Request {
    constructor(request: LinearRequest, data: L.IntercomSettingsFragment);
    /** Whether a ticket should be automatically reopened when its linked Linear issue is cancelled. */
    automateTicketReopeningOnCancellation?: boolean;
    /** Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue */
    automateTicketReopeningOnComment?: boolean;
    /** Whether a ticket should be automatically reopened when its linked Linear issue is completed. */
    automateTicketReopeningOnCompletion?: boolean;
    /** Whether an internal message should be added when someone comments on an issue. */
    sendNoteOnComment?: boolean;
    /** Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled). */
    sendNoteOnStatusChange?: boolean;
}
/**
 * An issue.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueFragment response data
 */
export declare class Issue extends Request {
    private _assignee?;
    private _creator?;
    private _cycle?;
    private _favorite?;
    private _parent?;
    private _project?;
    private _projectMilestone?;
    private _snoozedBy?;
    private _state;
    private _team;
    constructor(request: LinearRequest, data: L.IssueFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the issue was automatically archived by the auto pruning process. */
    autoArchivedAt?: Date;
    /** The time at which the issue was automatically closed by the auto pruning process. */
    autoClosedAt?: Date;
    /** The order of the item in its column on the board. */
    boardOrder: number;
    /** Suggested branch name for the issue. */
    branchName: string;
    /** The time at which the issue was moved into canceled state. */
    canceledAt?: Date;
    /** The time at which the issue was moved into completed state. */
    completedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk). */
    customerTicketCount: number;
    /** The issue's description in markdown format. */
    description?: string;
    /** The date at which the issue is due. */
    dueDate?: L.Scalars["TimelessDate"];
    /** The estimate of the complexity of the issue.. */
    estimate?: number;
    /** The unique identifier of the entity. */
    id: string;
    /** Issue's human readable identifier (e.g. ENG-123). */
    identifier: string;
    /** The issue's unique number. */
    number: number;
    /** Previous identifiers of the issue if it has been moved between teams. */
    previousIdentifiers: string[];
    /** The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low. */
    priority: number;
    /** Label for the priority. */
    priorityLabel: string;
    /** The time until an issue will be snoozed in Triage view. */
    snoozedUntilAt?: Date;
    /** The order of the item in relation to other items in the organization. */
    sortOrder: number;
    /** The time at which the issue was moved into started state. */
    startedAt?: Date;
    /** The time at which the issue entered triage. */
    startedTriageAt?: Date;
    /** The order of the item in the sub-issue list. Only set if the issue has a parent. */
    subIssueSortOrder?: number;
    /** The issue's title. */
    title: string;
    /** A flag that indicates whether the issue is in the trash bin. */
    trashed?: boolean;
    /** The time at which the issue left triage. */
    triagedAt?: Date;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** Issue URL. */
    url: string;
    /** The user to whom the issue is assigned to. */
    get assignee(): LinearFetch<User> | undefined;
    /** The user who created the issue. */
    get creator(): LinearFetch<User> | undefined;
    /** The cycle that the issue is associated with. */
    get cycle(): LinearFetch<Cycle> | undefined;
    /** The users favorite associated with this issue. */
    get favorite(): LinearFetch<Favorite> | undefined;
    /** The parent of the issue. */
    get parent(): LinearFetch<Issue> | undefined;
    /** The project that the issue is associated with. */
    get project(): LinearFetch<Project> | undefined;
    /** The projectMilestone that the issue is associated with. */
    get projectMilestone(): LinearFetch<ProjectMilestone> | undefined;
    /** The user who snoozed the issue. */
    get snoozedBy(): LinearFetch<User> | undefined;
    /** The workflow state that the issue is associated with. */
    get state(): LinearFetch<WorkflowState> | undefined;
    /** The team that the issue is associated with. */
    get team(): LinearFetch<Team> | undefined;
    /** Attachments associated with the issue. */
    attachments(variables?: Omit<L.Issue_AttachmentsQueryVariables, "id">): LinearFetch<AttachmentConnection>;
    /** Children of the issue. */
    children(variables?: Omit<L.Issue_ChildrenQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Comments associated with the issue. */
    comments(variables?: Omit<L.Issue_CommentsQueryVariables, "id">): LinearFetch<CommentConnection>;
    /** History entries associated with the issue. */
    history(variables?: Omit<L.Issue_HistoryQueryVariables, "id">): LinearFetch<IssueHistoryConnection>;
    /** Inverse relations associated with this issue. */
    inverseRelations(variables?: Omit<L.Issue_InverseRelationsQueryVariables, "id">): LinearFetch<IssueRelationConnection>;
    /** Labels associated with this issue. */
    labels(variables?: Omit<L.Issue_LabelsQueryVariables, "id">): LinearFetch<IssueLabelConnection>;
    /** Relations associated with this issue. */
    relations(variables?: Omit<L.Issue_RelationsQueryVariables, "id">): LinearFetch<IssueRelationConnection>;
    /** Users who are subscribed to the issue. */
    subscribers(variables?: Omit<L.Issue_SubscribersQueryVariables, "id">): LinearFetch<UserConnection>;
    /** Archives an issue. */
    archive(variables?: Omit<L.ArchiveIssueMutationVariables, "id">): LinearFetch<IssueArchivePayload>;
    /** Creates a new issue. */
    create(input: L.IssueCreateInput): LinearFetch<IssuePayload>;
    /** Deletes (trashes) an issue. */
    delete(): LinearFetch<IssueArchivePayload>;
    /** Unarchives an issue. */
    unarchive(): LinearFetch<IssueArchivePayload>;
    /** Updates an issue. */
    update(input: L.IssueUpdateInput): LinearFetch<IssuePayload>;
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueArchivePayloadFragment response data
 */
export declare class IssueArchivePayload extends Request {
    private _entity?;
    constructor(request: LinearRequest, data: L.IssueArchivePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The archived/unarchived entity. Null if entity was deleted. */
    get entity(): LinearFetch<Issue> | undefined;
}
/**
 * IssueBatchPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueBatchPayloadFragment response data
 */
export declare class IssueBatchPayload extends Request {
    constructor(request: LinearRequest, data: L.IssueBatchPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The issues that were updated. */
    issues: Issue[];
}
/**
 * IssueConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IssueConnection model
 * @param data - IssueConnection response data
 */
export declare class IssueConnection extends Connection<Issue> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Issue> | undefined>, data: L.IssueConnectionFragment);
}
/**
 * IssueFilterSuggestionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueFilterSuggestionPayloadFragment response data
 */
export declare class IssueFilterSuggestionPayload extends Request {
    constructor(request: LinearRequest, data: L.IssueFilterSuggestionPayloadFragment);
    /** The json filter that is suggested. */
    filter?: Record<string, unknown>;
}
/**
 * A record of changes to an issue.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueHistoryFragment response data
 */
export declare class IssueHistory extends Request {
    private _actor?;
    private _attachment?;
    private _fromAssignee?;
    private _fromCycle?;
    private _fromParent?;
    private _fromProject?;
    private _fromState?;
    private _fromTeam?;
    private _issue;
    private _toAssignee?;
    private _toConvertedProject?;
    private _toCycle?;
    private _toParent?;
    private _toProject?;
    private _toState?;
    private _toTeam?;
    constructor(request: LinearRequest, data: L.IssueHistoryFragment);
    /** The id of user who made these changes. If null, possibly means that the change made by an integration. */
    actorId?: string;
    /** ID's of labels that were added. */
    addedLabelIds?: string[];
    /** Whether the issue is archived at the time of this history entry. */
    archived?: boolean;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The id of linked attachment. */
    attachmentId?: string;
    /** Whether the issue was auto-archived. */
    autoArchived?: boolean;
    /** Whether the issue was auto-closed. */
    autoClosed?: boolean;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The id of user from whom the issue was re-assigned from. */
    fromAssigneeId?: string;
    /** The id of previous cycle of the issue. */
    fromCycleId?: string;
    /** What the due date was changed from */
    fromDueDate?: L.Scalars["TimelessDate"];
    /** What the estimate was changed from. */
    fromEstimate?: number;
    /** The id of previous parent of the issue. */
    fromParentId?: string;
    /** What the priority was changed from. */
    fromPriority?: number;
    /** The id of previous project of the issue. */
    fromProjectId?: string;
    /** The id of previous workflow state of the issue. */
    fromStateId?: string;
    /** The id of team from which the issue was moved from. */
    fromTeamId?: string;
    /** What the title was changed from. */
    fromTitle?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** ID's of labels that were removed. */
    removedLabelIds?: string[];
    /** The id of user to whom the issue was assigned to. */
    toAssigneeId?: string;
    /** The id of new project created from the issue. */
    toConvertedProjectId?: string;
    /** The id of new cycle of the issue. */
    toCycleId?: string;
    /** What the due date was changed to */
    toDueDate?: L.Scalars["TimelessDate"];
    /** What the estimate was changed to. */
    toEstimate?: number;
    /** The id of new parent of the issue. */
    toParentId?: string;
    /** What the priority was changed to. */
    toPriority?: number;
    /** The id of new project of the issue. */
    toProjectId?: string;
    /** The id of new workflow state of the issue. */
    toStateId?: string;
    /** The id of team to which the issue was moved to. */
    toTeamId?: string;
    /** What the title was changed to. */
    toTitle?: string;
    /** Whether the issue was trashed or un-trashed. */
    trashed?: boolean;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** Whether the issue's description was updated. */
    updatedDescription?: boolean;
    /** Changed issue relationships. */
    relationChanges?: IssueRelationHistoryPayload[];
    /** The import record. */
    issueImport?: IssueImport;
    /** The user who made these changes. If null, possibly means that the change made by an integration. */
    get actor(): LinearFetch<User> | undefined;
    /** The linked attachment. */
    get attachment(): LinearFetch<Attachment> | undefined;
    /** The user from whom the issue was re-assigned from. */
    get fromAssignee(): LinearFetch<User> | undefined;
    /** The previous cycle of the issue. */
    get fromCycle(): LinearFetch<Cycle> | undefined;
    /** The previous parent of the issue. */
    get fromParent(): LinearFetch<Issue> | undefined;
    /** The previous project of the issue. */
    get fromProject(): LinearFetch<Project> | undefined;
    /** The previous workflow state of the issue. */
    get fromState(): LinearFetch<WorkflowState> | undefined;
    /** The team from which the issue was moved from. */
    get fromTeam(): LinearFetch<Team> | undefined;
    /** The issue that was changed. */
    get issue(): LinearFetch<Issue> | undefined;
    /** The user to whom the issue was assigned to. */
    get toAssignee(): LinearFetch<User> | undefined;
    /** The new project created from the issue. */
    get toConvertedProject(): LinearFetch<Project> | undefined;
    /** The new cycle of the issue. */
    get toCycle(): LinearFetch<Cycle> | undefined;
    /** The new parent of the issue. */
    get toParent(): LinearFetch<Issue> | undefined;
    /** The new project of the issue. */
    get toProject(): LinearFetch<Project> | undefined;
    /** The new workflow state of the issue. */
    get toState(): LinearFetch<WorkflowState> | undefined;
    /** The team to which the issue was moved to. */
    get toTeam(): LinearFetch<Team> | undefined;
}
/**
 * IssueHistoryConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IssueHistoryConnection model
 * @param data - IssueHistoryConnection response data
 */
export declare class IssueHistoryConnection extends Connection<IssueHistory> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<IssueHistory> | undefined>, data: L.IssueHistoryConnectionFragment);
}
/**
 * An import job for data from an external service
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueImportFragment response data
 */
export declare class IssueImport extends Request {
    constructor(request: LinearRequest, data: L.IssueImportFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The id for the user that started the job. */
    creatorId: string;
    /** File URL for the uploaded CSV for the import, if there is one. */
    csvFileUrl?: string;
    /** User readable error message, if one has occurred during the import. */
    error?: string;
    /** Error code and metadata, if one has occurred during the import */
    errorMetadata?: Record<string, unknown>;
    /** The unique identifier of the entity. */
    id: string;
    /** The data mapping configuration for the import job. */
    mapping?: Record<string, unknown>;
    /** Current step progress in % (0-100). */
    progress?: number;
    /** The service from which data will be imported. */
    service: string;
    /** The status for the import job. */
    status: string;
    /** New team's name in cases when teamId not set */
    teamName?: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** Deletes an import job. */
    delete(issueImportId: string): LinearFetch<IssueImportDeletePayload>;
    /** Updates the mapping for the issue import. */
    update(input: L.IssueImportUpdateInput): LinearFetch<IssueImportPayload>;
}
/**
 * IssueImportCheckPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueImportCheckPayloadFragment response data
 */
export declare class IssueImportCheckPayload extends Request {
    constructor(request: LinearRequest, data: L.IssueImportCheckPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * IssueImportDeletePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueImportDeletePayloadFragment response data
 */
export declare class IssueImportDeletePayload extends Request {
    constructor(request: LinearRequest, data: L.IssueImportDeletePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The import job that was deleted. */
    issueImport?: IssueImport;
}
/**
 * IssueImportPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueImportPayloadFragment response data
 */
export declare class IssueImportPayload extends Request {
    constructor(request: LinearRequest, data: L.IssueImportPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The import job that was created or updated. */
    issueImport?: IssueImport;
}
/**
 * Labels that can be associated with issues.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueLabelFragment response data
 */
export declare class IssueLabel extends Request {
    private _creator?;
    private _parent?;
    private _team?;
    constructor(request: LinearRequest, data: L.IssueLabelFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The label's color as a HEX string. */
    color: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The label's description. */
    description?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** Whether this label is considered to be a group. */
    isGroup: boolean;
    /** The label's name. */
    name: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The user who created the label. */
    get creator(): LinearFetch<User> | undefined;
    get organization(): LinearFetch<Organization>;
    /** The parent label. */
    get parent(): LinearFetch<IssueLabel> | undefined;
    /** The team that the label is associated with. If null, the label is associated with the global workspace. */
    get team(): LinearFetch<Team> | undefined;
    /** Children of the label. */
    children(variables?: Omit<L.IssueLabel_ChildrenQueryVariables, "id">): LinearFetch<IssueLabelConnection>;
    /** Issues associated with the label. */
    issues(variables?: Omit<L.IssueLabel_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Creates a new label. */
    create(input: L.IssueLabelCreateInput, variables?: Omit<L.CreateIssueLabelMutationVariables, "input">): LinearFetch<IssueLabelPayload>;
    /** Deletes an issue label. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates an label. */
    update(input: L.IssueLabelUpdateInput): LinearFetch<IssueLabelPayload>;
}
/**
 * IssueLabelConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IssueLabelConnection model
 * @param data - IssueLabelConnection response data
 */
export declare class IssueLabelConnection extends Connection<IssueLabel> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<IssueLabel> | undefined>, data: L.IssueLabelConnectionFragment);
}
/**
 * IssueLabelPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueLabelPayloadFragment response data
 */
export declare class IssueLabelPayload extends Request {
    private _issueLabel;
    constructor(request: LinearRequest, data: L.IssueLabelPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The label that was created or updated. */
    get issueLabel(): LinearFetch<IssueLabel> | undefined;
}
/**
 * An issue related notification
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueNotificationFragment response data
 */
export declare class IssueNotification extends Request {
    private _actor?;
    private _comment?;
    private _issue;
    private _team;
    private _user;
    constructor(request: LinearRequest, data: L.IssueNotificationFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /**
     * The time at when an email reminder for this notification was sent to the user. Null, if no email
     *     reminder has been sent.
     */
    emailedAt?: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** Name of the reaction emoji related to the notification. */
    reactionEmoji?: string;
    /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
    readAt?: Date;
    /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
    snoozedUntilAt?: Date;
    /** Notification type */
    type: string;
    /** The time at which a notification was unsnoozed.. */
    unsnoozedAt?: Date;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The user that caused the notification. */
    get actor(): LinearFetch<User> | undefined;
    /** The comment related to the notification. */
    get comment(): LinearFetch<Comment> | undefined;
    /** The issue related to the notification. */
    get issue(): LinearFetch<Issue> | undefined;
    /** The team related to the notification. */
    get team(): LinearFetch<Team> | undefined;
    /** The user that received the notification. */
    get user(): LinearFetch<User> | undefined;
}
/**
 * IssuePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssuePayloadFragment response data
 */
export declare class IssuePayload extends Request {
    private _issue?;
    constructor(request: LinearRequest, data: L.IssuePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The issue that was created or updated. */
    get issue(): LinearFetch<Issue> | undefined;
}
/**
 * IssuePriorityValue model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssuePriorityValueFragment response data
 */
export declare class IssuePriorityValue extends Request {
    constructor(request: LinearRequest, data: L.IssuePriorityValueFragment);
    /** Priority's label. */
    label: string;
    /** Priority's number value. */
    priority: number;
}
/**
 * A relation between two issues.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueRelationFragment response data
 */
export declare class IssueRelation extends Request {
    private _issue;
    private _relatedIssue;
    constructor(request: LinearRequest, data: L.IssueRelationFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The relationship of the issue with the related issue. */
    type: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The issue whose relationship is being described. */
    get issue(): LinearFetch<Issue> | undefined;
    /** The related issue. */
    get relatedIssue(): LinearFetch<Issue> | undefined;
    /** Creates a new issue relation. */
    create(input: L.IssueRelationCreateInput): LinearFetch<IssueRelationPayload>;
    /** Deletes an issue relation. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates an issue relation. */
    update(input: L.IssueRelationUpdateInput): LinearFetch<IssueRelationPayload>;
}
/**
 * IssueRelationConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IssueRelationConnection model
 * @param data - IssueRelationConnection response data
 */
export declare class IssueRelationConnection extends Connection<IssueRelation> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<IssueRelation> | undefined>, data: L.IssueRelationConnectionFragment);
}
/**
 * Issue relation history's payload
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueRelationHistoryPayloadFragment response data
 */
export declare class IssueRelationHistoryPayload extends Request {
    constructor(request: LinearRequest, data: L.IssueRelationHistoryPayloadFragment);
    /** The identifier of the related issue. */
    identifier: string;
    /** The type of the change. */
    type: string;
}
/**
 * IssueRelationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueRelationPayloadFragment response data
 */
export declare class IssueRelationPayload extends Request {
    private _issueRelation;
    constructor(request: LinearRequest, data: L.IssueRelationPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The issue relation that was created or updated. */
    get issueRelation(): LinearFetch<IssueRelation> | undefined;
}
/**
 * IssueSearchPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueSearchPayloadFragment response data
 */
export declare class IssueSearchPayload extends Request {
    constructor(request: LinearRequest, data: L.IssueSearchPayloadFragment);
    /** Total number of results for query without filters applied. */
    totalCount: number;
    nodes: IssueSearchResult[];
    /** Archived entities matching the search term along with all their dependencies. */
    archivePayload: ArchiveResponse;
    pageInfo: PageInfo;
}
/**
 * IssueSearchResult model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueSearchResultFragment response data
 */
export declare class IssueSearchResult extends Request {
    private _assignee?;
    private _creator?;
    private _cycle?;
    private _favorite?;
    private _parent?;
    private _project?;
    private _projectMilestone?;
    private _snoozedBy?;
    private _state;
    private _team;
    constructor(request: LinearRequest, data: L.IssueSearchResultFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the issue was automatically archived by the auto pruning process. */
    autoArchivedAt?: Date;
    /** The time at which the issue was automatically closed by the auto pruning process. */
    autoClosedAt?: Date;
    /** The order of the item in its column on the board. */
    boardOrder: number;
    /** Suggested branch name for the issue. */
    branchName: string;
    /** The time at which the issue was moved into canceled state. */
    canceledAt?: Date;
    /** The time at which the issue was moved into completed state. */
    completedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk). */
    customerTicketCount: number;
    /** The issue's description in markdown format. */
    description?: string;
    /** The date at which the issue is due. */
    dueDate?: L.Scalars["TimelessDate"];
    /** The estimate of the complexity of the issue.. */
    estimate?: number;
    /** The unique identifier of the entity. */
    id: string;
    /** Issue's human readable identifier (e.g. ENG-123). */
    identifier: string;
    /** Metadata related to search result */
    metadata: Record<string, unknown>;
    /** The issue's unique number. */
    number: number;
    /** Previous identifiers of the issue if it has been moved between teams. */
    previousIdentifiers: string[];
    /** The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low. */
    priority: number;
    /** Label for the priority. */
    priorityLabel: string;
    /** The time until an issue will be snoozed in Triage view. */
    snoozedUntilAt?: Date;
    /** The order of the item in relation to other items in the organization. */
    sortOrder: number;
    /** The time at which the issue was moved into started state. */
    startedAt?: Date;
    /** The time at which the issue entered triage. */
    startedTriageAt?: Date;
    /** The order of the item in the sub-issue list. Only set if the issue has a parent. */
    subIssueSortOrder?: number;
    /** The issue's title. */
    title: string;
    /** A flag that indicates whether the issue is in the trash bin. */
    trashed?: boolean;
    /** The time at which the issue left triage. */
    triagedAt?: Date;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** Issue URL. */
    url: string;
    /** The user to whom the issue is assigned to. */
    get assignee(): LinearFetch<User> | undefined;
    /** The user who created the issue. */
    get creator(): LinearFetch<User> | undefined;
    /** The cycle that the issue is associated with. */
    get cycle(): LinearFetch<Cycle> | undefined;
    /** The users favorite associated with this issue. */
    get favorite(): LinearFetch<Favorite> | undefined;
    /** The parent of the issue. */
    get parent(): LinearFetch<Issue> | undefined;
    /** The project that the issue is associated with. */
    get project(): LinearFetch<Project> | undefined;
    /** The projectMilestone that the issue is associated with. */
    get projectMilestone(): LinearFetch<ProjectMilestone> | undefined;
    /** The user who snoozed the issue. */
    get snoozedBy(): LinearFetch<User> | undefined;
    /** The workflow state that the issue is associated with. */
    get state(): LinearFetch<WorkflowState> | undefined;
    /** The team that the issue is associated with. */
    get team(): LinearFetch<Team> | undefined;
}
/**
 * IssueSearchResultConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IssueSearchResultConnection model
 * @param data - IssueSearchResultConnection response data
 */
export declare class IssueSearchResultConnection extends Connection<IssueSearchResult> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<IssueSearchResult> | undefined>, data: L.IssueSearchResultConnectionFragment);
}
/**
 * Tuple for mapping Jira projects to Linear teams.
 *
 * @param request - function to call the graphql client
 * @param data - L.JiraLinearMappingFragment response data
 */
export declare class JiraLinearMapping extends Request {
    constructor(request: LinearRequest, data: L.JiraLinearMappingFragment);
    /** The Jira id for this project. */
    jiraProjectId: string;
    /** The Linear team id to map to the given project. */
    linearTeamId: string;
}
/**
 * Metadata about a Jira project.
 *
 * @param request - function to call the graphql client
 * @param data - L.JiraProjectDataFragment response data
 */
export declare class JiraProjectData extends Request {
    constructor(request: LinearRequest, data: L.JiraProjectDataFragment);
    /** The Jira id for this project. */
    id: string;
    /** The Jira key for this project, such as ENG. */
    key: string;
    /** The Jira name for this project, such as Engineering. */
    name: string;
}
/**
 * Jira specific settings.
 *
 * @param request - function to call the graphql client
 * @param data - L.JiraSettingsFragment response data
 */
export declare class JiraSettings extends Request {
    constructor(request: LinearRequest, data: L.JiraSettingsFragment);
    /** The mapping of Jira project id => Linear team id. */
    projectMapping?: JiraLinearMapping[];
    /** The Jira projects for the organization. */
    projects: JiraProjectData[];
}
/**
 * A label notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.LabelNotificationSubscriptionFragment response data
 */
export declare class LabelNotificationSubscription extends Request {
    private _customView?;
    private _cycle?;
    private _label;
    private _project?;
    private _subscriber;
    private _team?;
    private _user?;
    constructor(request: LinearRequest, data: L.LabelNotificationSubscriptionFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The type of subscription. */
    notificationSubscriptionTypes: string[];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The contextual custom view associated with the notification subscription. */
    get customView(): LinearFetch<CustomView> | undefined;
    /** The contextual cycle view associated with the notification subscription. */
    get cycle(): LinearFetch<Cycle> | undefined;
    /** The label subscribed to. */
    get label(): LinearFetch<IssueLabel> | undefined;
    /** The contextual project view associated with the notification subscription. */
    get project(): LinearFetch<Project> | undefined;
    /** The user that subscribed to receive notifications. */
    get subscriber(): LinearFetch<User> | undefined;
    /** The team associated with the notification subscription. */
    get team(): LinearFetch<Team> | undefined;
    /** The user view associated with the notification subscription. */
    get user(): LinearFetch<User> | undefined;
}
/**
 * LogoutResponse model
 *
 * @param request - function to call the graphql client
 * @param data - L.LogoutResponseFragment response data
 */
export declare class LogoutResponse extends Request {
    constructor(request: LinearRequest, data: L.LogoutResponseFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * Node model
 *
 * @param request - function to call the graphql client
 * @param data - L.NodeFragment response data
 */
export declare class Node extends Request {
    constructor(request: LinearRequest, data: L.NodeFragment);
    /** The unique identifier of the entity. */
    id: string;
}
/**
 * A notification sent to a user.
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationFragment response data
 */
export declare class Notification extends Request {
    private _actor?;
    private _user;
    constructor(request: LinearRequest, data: L.NotificationFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /**
     * The time at when an email reminder for this notification was sent to the user. Null, if no email
     *     reminder has been sent.
     */
    emailedAt?: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
    readAt?: Date;
    /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
    snoozedUntilAt?: Date;
    /** Notification type */
    type: string;
    /** The time at which a notification was unsnoozed.. */
    unsnoozedAt?: Date;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The user that caused the notification. */
    get actor(): LinearFetch<User> | undefined;
    /** The user that received the notification. */
    get user(): LinearFetch<User> | undefined;
    /** Archives a notification. */
    archive(): LinearFetch<NotificationArchivePayload>;
    /** Unarchives a notification. */
    unarchive(): LinearFetch<NotificationArchivePayload>;
    /** Updates a notification. */
    update(input: L.NotificationUpdateInput): LinearFetch<NotificationPayload>;
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationArchivePayloadFragment response data
 */
export declare class NotificationArchivePayload extends Request {
    constructor(request: LinearRequest, data: L.NotificationArchivePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * NotificationBatchActionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationBatchActionPayloadFragment response data
 */
export declare class NotificationBatchActionPayload extends Request {
    constructor(request: LinearRequest, data: L.NotificationBatchActionPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The notifications that were updated. */
    notifications: Notification[];
}
/**
 * NotificationConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this NotificationConnection model
 * @param data - NotificationConnection response data
 */
export declare class NotificationConnection extends Connection<IssueNotification | OauthClientApprovalNotification | ProjectNotification | Notification> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<IssueNotification | OauthClientApprovalNotification | ProjectNotification | Notification> | undefined>, data: L.NotificationConnectionFragment);
}
/**
 * NotificationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationPayloadFragment response data
 */
export declare class NotificationPayload extends Request {
    constructor(request: LinearRequest, data: L.NotificationPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * Notification subscriptions for models.
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationSubscriptionFragment response data
 */
export declare class NotificationSubscription extends Request {
    private _customView?;
    private _cycle?;
    private _label?;
    private _project?;
    private _subscriber;
    private _team?;
    private _user?;
    constructor(request: LinearRequest, data: L.NotificationSubscriptionFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The contextual custom view associated with the notification subscription. */
    get customView(): LinearFetch<CustomView> | undefined;
    /** The contextual cycle view associated with the notification subscription. */
    get cycle(): LinearFetch<Cycle> | undefined;
    /** The contextual label view associated with the notification subscription. */
    get label(): LinearFetch<IssueLabel> | undefined;
    /** The contextual project view associated with the notification subscription. */
    get project(): LinearFetch<Project> | undefined;
    /** The user that subscribed to receive notifications. */
    get subscriber(): LinearFetch<User> | undefined;
    /** The team associated with the notification subscription. */
    get team(): LinearFetch<Team> | undefined;
    /** The user view associated with the notification subscription. */
    get user(): LinearFetch<User> | undefined;
    /** Creates a new notification subscription for a cycle, custom view, label, project or team. */
    create(input: L.NotificationSubscriptionCreateInput): LinearFetch<NotificationSubscriptionPayload>;
    /** Deletes a notification subscription reference. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates a notification subscription. */
    update(input: L.NotificationSubscriptionUpdateInput): LinearFetch<NotificationSubscriptionPayload>;
}
/**
 * NotificationSubscriptionConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this NotificationSubscriptionConnection model
 * @param data - NotificationSubscriptionConnection response data
 */
export declare class NotificationSubscriptionConnection extends Connection<CustomViewNotificationSubscription | CycleNotificationSubscription | LabelNotificationSubscription | ProjectNotificationSubscription | TeamNotificationSubscription | UserNotificationSubscription | NotificationSubscription> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<CustomViewNotificationSubscription | CycleNotificationSubscription | LabelNotificationSubscription | ProjectNotificationSubscription | TeamNotificationSubscription | UserNotificationSubscription | NotificationSubscription> | undefined>, data: L.NotificationSubscriptionConnectionFragment);
}
/**
 * NotificationSubscriptionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationSubscriptionPayloadFragment response data
 */
export declare class NotificationSubscriptionPayload extends Request {
    constructor(request: LinearRequest, data: L.NotificationSubscriptionPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * Notion specific settings.
 *
 * @param request - function to call the graphql client
 * @param data - L.NotionSettingsFragment response data
 */
export declare class NotionSettings extends Request {
    constructor(request: LinearRequest, data: L.NotionSettingsFragment);
    /** The ID of the Notion workspace being connected. */
    workspaceId: string;
    /** The name of the Notion workspace being connected. */
    workspaceName: string;
}
/**
 * OAuth2 client application
 *
 * @param request - function to call the graphql client
 * @param data - L.OauthClientFragment response data
 */
export declare class OauthClient extends Request {
    private _creator;
    constructor(request: LinearRequest, data: L.OauthClientFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** OAuth application's client ID. */
    clientId: string;
    /** OAuth application's client secret. */
    clientSecret: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Information about the application. */
    description?: string;
    /** Name of the developer. */
    developer: string;
    /** Url of the developer. */
    developerUrl: string;
    /** The unique identifier of the entity. */
    id: string;
    /** Image of the application. */
    imageUrl?: string;
    /** OAuth application's client name. */
    name: string;
    /** Whether the OAuth application is publicly visible, or only visible to the creating workspace. */
    publicEnabled: boolean;
    /** List of allowed redirect URIs for the application. */
    redirectUris: string[];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The resource types to request when creating new webhooks. */
    webhookResourceTypes: string[];
    /** Webhook secret token for verifying the origin on the recipient side. */
    webhookSecret?: string;
    /** Webhook URL */
    webhookUrl?: string;
    /** The user who created the OAuthClient. */
    get creator(): LinearFetch<User> | undefined;
    /** The organization that the OAuthClient is associated with. */
    get organization(): LinearFetch<Organization>;
}
/**
 * Request to install OAuth clients on organizations and the response to the request.
 *
 * @param request - function to call the graphql client
 * @param data - L.OauthClientApprovalFragment response data
 */
export declare class OauthClientApproval extends Request {
    constructor(request: LinearRequest, data: L.OauthClientApprovalFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The reason the request for the OAuth client approval was denied. */
    denyReason?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The uuid of the OAuth client being requested for installation. */
    oauthClientId: string;
    /** The reason the person wants to install this OAuth client. */
    requestReason?: string;
    /** The person who requested installing the OAuth client. */
    requesterId: string;
    /** The person who responded to the request to install the OAuth client. */
    responderId?: string;
    /** The scopes the app has requested. */
    scopes: string[];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
}
/**
 * An oauth client approval related notification
 *
 * @param request - function to call the graphql client
 * @param data - L.OauthClientApprovalNotificationFragment response data
 */
export declare class OauthClientApprovalNotification extends Request {
    private _actor?;
    private _user;
    constructor(request: LinearRequest, data: L.OauthClientApprovalNotificationFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /**
     * The time at when an email reminder for this notification was sent to the user. Null, if no email
     *     reminder has been sent.
     */
    emailedAt?: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
    readAt?: Date;
    /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
    snoozedUntilAt?: Date;
    /** Notification type */
    type: string;
    /** The time at which a notification was unsnoozed.. */
    unsnoozedAt?: Date;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The OAuth client approval request related to the notification. */
    oauthClientApproval: OauthClientApproval;
    /** The user that caused the notification. */
    get actor(): LinearFetch<User> | undefined;
    /** The user that received the notification. */
    get user(): LinearFetch<User> | undefined;
}
/**
 * OauthClientConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this OauthClientConnection model
 * @param data - OauthClientConnection response data
 */
export declare class OauthClientConnection extends Connection<OauthClient> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<OauthClient> | undefined>, data: L.OauthClientConnectionFragment);
}
/**
 * An organization. Organizations are root-level objects that contain user accounts and teams.
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationFragment response data
 */
export declare class Organization extends Request {
    constructor(request: LinearRequest, data: L.OrganizationFragment);
    /** Allowed authentication providers, empty array means all are allowed */
    allowedAuthServices: string[];
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Number of issues in the organization. */
    createdIssueCount: number;
    /** The time at which deletion of the organization was requested. */
    deletionRequestedAt?: Date;
    /** How git branches are formatted. If null, default formatting will be used. */
    gitBranchFormat?: string;
    /** Whether the Git integration linkback messages should be sent to private repositories. */
    gitLinkbackMessagesEnabled: boolean;
    /** Whether the Git integration linkback messages should be sent to public repositories. */
    gitPublicLinkbackMessagesEnabled: boolean;
    /** The unique identifier of the entity. */
    id: string;
    /** The organization's logo URL. */
    logoUrl?: string;
    /** The organization's name. */
    name: string;
    /** Rolling 30-day total upload volume for the organization, in megabytes. */
    periodUploadVolume: number;
    /** Previously used URL keys for the organization (last 3 are kept and redirected). */
    previousUrlKeys: string[];
    /** The hour at which to prompt for project updates. */
    projectUpdateRemindersHour: number;
    /** Whether the organization is using a roadmap. */
    roadmapEnabled: boolean;
    /** Whether SAML authentication is enabled for organization. */
    samlEnabled: boolean;
    /** Whether SCIM provisioning is enabled for organization. */
    scimEnabled: boolean;
    /** The time at which the trial of the plus plan will end. */
    trialEndsAt?: Date;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The organization's unique URL key. */
    urlKey: string;
    /** Number of active users in the organization. */
    userCount: number;
    /** The organization's subscription to a paid plan. */
    subscription?: PaidSubscription;
    /** Integrations associated with the organization. */
    integrations(variables?: L.Organization_IntegrationsQueryVariables): LinearFetch<IntegrationConnection>;
    /** Labels associated with the organization. */
    labels(variables?: L.Organization_LabelsQueryVariables): LinearFetch<IssueLabelConnection>;
    /** Teams associated with the organization. */
    teams(variables?: L.Organization_TeamsQueryVariables): LinearFetch<TeamConnection>;
    /** Templates associated with the organization. */
    templates(variables?: L.Organization_TemplatesQueryVariables): LinearFetch<TemplateConnection>;
    /** Users associated with the organization. */
    users(variables?: L.Organization_UsersQueryVariables): LinearFetch<UserConnection>;
    /** Delete's an organization. Administrator privileges required. */
    delete(input: L.DeleteOrganizationInput): LinearFetch<OrganizationDeletePayload>;
    /** Updates the user's organization. */
    update(input: L.UpdateOrganizationInput): LinearFetch<OrganizationPayload>;
}
/**
 * OrganizationCancelDeletePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationCancelDeletePayloadFragment response data
 */
export declare class OrganizationCancelDeletePayload extends Request {
    constructor(request: LinearRequest, data: L.OrganizationCancelDeletePayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * OrganizationDeletePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationDeletePayloadFragment response data
 */
export declare class OrganizationDeletePayload extends Request {
    constructor(request: LinearRequest, data: L.OrganizationDeletePayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * Defines the use of a domain by an organization.
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationDomainFragment response data
 */
export declare class OrganizationDomain extends Request {
    private _creator?;
    constructor(request: LinearRequest, data: L.OrganizationDomainFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** Whether the domains was claimed by the organization through DNS verification. */
    claimed?: boolean;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** Domain name */
    name: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** E-mail used to verify this domain */
    verificationEmail?: string;
    /** Is this domain verified */
    verified: boolean;
    /** The user who added the domain. */
    get creator(): LinearFetch<User> | undefined;
    /** Deletes a domain. */
    delete(): LinearFetch<DeletePayload>;
}
/**
 * OrganizationExistsPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationExistsPayloadFragment response data
 */
export declare class OrganizationExistsPayload extends Request {
    constructor(request: LinearRequest, data: L.OrganizationExistsPayloadFragment);
    /** Whether the organization exists. */
    exists: boolean;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * An invitation to the organization that has been sent via email.
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationInviteFragment response data
 */
export declare class OrganizationInvite extends Request {
    private _invitee?;
    private _inviter;
    constructor(request: LinearRequest, data: L.OrganizationInviteFragment);
    /** The time at which the invite was accepted. Null, if the invite hasn't been accepted */
    acceptedAt?: Date;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The invitees email address. */
    email: string;
    /** The time at which the invite will be expiring. Null, if the invite shouldn't expire */
    expiresAt?: Date;
    /** The invite was sent to external address. */
    external: boolean;
    /** The unique identifier of the entity. */
    id: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The user who has accepted the invite. Null, if the invite hasn't been accepted. */
    get invitee(): LinearFetch<User> | undefined;
    /** The user who created the invitation. */
    get inviter(): LinearFetch<User> | undefined;
    /** The organization that the invite is associated with. */
    get organization(): LinearFetch<Organization>;
    /** Creates a new organization invite. */
    create(input: L.OrganizationInviteCreateInput): LinearFetch<OrganizationInvitePayload>;
    /** Deletes an organization invite. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates an organization invite. */
    update(input: L.OrganizationInviteUpdateInput): LinearFetch<OrganizationInvitePayload>;
}
/**
 * OrganizationInviteConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this OrganizationInviteConnection model
 * @param data - OrganizationInviteConnection response data
 */
export declare class OrganizationInviteConnection extends Connection<OrganizationInvite> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<OrganizationInvite> | undefined>, data: L.OrganizationInviteConnectionFragment);
}
/**
 * OrganizationInviteFullDetailsPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationInviteFullDetailsPayloadFragment response data
 */
export declare class OrganizationInviteFullDetailsPayload extends Request {
    constructor(request: LinearRequest, data: L.OrganizationInviteFullDetailsPayloadFragment);
    /** Whether the invite has already been accepted. */
    accepted: boolean;
    /** When the invite was created. */
    createdAt: Date;
    /** The email of the invitee */
    email: string;
    /** Whether the invite has expired. */
    expired: boolean;
    /** The name of the inviter */
    inviter: string;
    /** ID of the workspace the invite is for. */
    organizationId: string;
    /** URL of the workspace logo the invite is for. */
    organizationLogoUrl?: string;
    /** Name of the workspace the invite is for. */
    organizationName: string;
}
/**
 * OrganizationInvitePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationInvitePayloadFragment response data
 */
export declare class OrganizationInvitePayload extends Request {
    private _organizationInvite;
    constructor(request: LinearRequest, data: L.OrganizationInvitePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The organization invite that was created or updated. */
    get organizationInvite(): LinearFetch<OrganizationInvite> | undefined;
}
/**
 * OrganizationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationPayloadFragment response data
 */
export declare class OrganizationPayload extends Request {
    constructor(request: LinearRequest, data: L.OrganizationPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The organization that was created or updated. */
    get organization(): LinearFetch<Organization>;
}
/**
 * OrganizationStartPlusTrialPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationStartPlusTrialPayloadFragment response data
 */
export declare class OrganizationStartPlusTrialPayload extends Request {
    constructor(request: LinearRequest, data: L.OrganizationStartPlusTrialPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * PageInfo model
 *
 * @param request - function to call the graphql client
 * @param data - L.PageInfoFragment response data
 */
export declare class PageInfo extends Request {
    constructor(request: LinearRequest, data: L.PageInfoFragment);
    /** Cursor representing the last result in the paginated results. */
    endCursor?: string;
    /** Indicates if there are more results when paginating forward. */
    hasNextPage: boolean;
    /** Indicates if there are more results when paginating backward. */
    hasPreviousPage: boolean;
    /** Cursor representing the first result in the paginated results. */
    startCursor?: string;
}
/**
 * Tuple for mapping PagerDuty schedule id to names.
 *
 * @param request - function to call the graphql client
 * @param data - L.PagerDutyScheduleMappingFragment response data
 */
export declare class PagerDutyScheduleMapping extends Request {
    constructor(request: LinearRequest, data: L.PagerDutyScheduleMappingFragment);
    /** The PagerDuty schedule id. */
    scheduleId: string;
    /** The PagerDuty schedule name. */
    scheduleName: string;
}
/**
 * PagerDuty specific settings.
 *
 * @param request - function to call the graphql client
 * @param data - L.PagerDutySettingsFragment response data
 */
export declare class PagerDutySettings extends Request {
    constructor(request: LinearRequest, data: L.PagerDutySettingsFragment);
    /** The mapping of PagerDuty schedule id to names. */
    scheduleMapping: PagerDutyScheduleMapping[];
}
/**
 * The paid subscription of an organization.
 *
 * @param request - function to call the graphql client
 * @param data - L.PaidSubscriptionFragment response data
 */
export declare class PaidSubscription extends Request {
    private _creator?;
    constructor(request: LinearRequest, data: L.PaidSubscriptionFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The date the subscription was canceled, if any. */
    canceledAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The date the subscription will be billed next. */
    nextBillingAt?: Date;
    /** The subscription type of a pending change. Null if no change pending. */
    pendingChangeType?: string;
    /** The number of seats in the subscription. */
    seats: number;
    /** The maximum number of seats that will be billed in the subscription. */
    seatsMaximum?: number;
    /** The minimum number of seats that will be billed in the subscription. */
    seatsMinimum?: number;
    /** The subscription type. */
    type: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The creator of the subscription. */
    get creator(): LinearFetch<User> | undefined;
    /** The organization that the subscription is associated with. */
    get organization(): LinearFetch<Organization>;
}
/**
 * A project.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectFragment response data
 */
export declare class Project extends Request {
    private _convertedFromIssue?;
    private _creator;
    private _integrationsSettings?;
    private _lead?;
    constructor(request: LinearRequest, data: L.ProjectFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the project was automatically archived by the auto pruning process. */
    autoArchivedAt?: Date;
    /** The time at which the project was moved into canceled state. */
    canceledAt?: Date;
    /** The project's color. */
    color: string;
    /** The time at which the project was moved into completed state. */
    completedAt?: Date;
    /** The number of completed issues in the project after each week. */
    completedIssueCountHistory: number[];
    /** The number of completed estimation points after each week. */
    completedScopeHistory: number[];
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The project's description. */
    description: string;
    /** The icon of the project. */
    icon?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The number of in progress estimation points after each week. */
    inProgressScopeHistory: number[];
    /** The total number of issues in the project after each week. */
    issueCountHistory: number[];
    /** The project's name. */
    name: string;
    /** The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points. */
    progress: number;
    /** The time until which project update reminders are paused. */
    projectUpdateRemindersPausedUntilAt?: Date;
    /** The overall scope (total estimate points) of the project. */
    scope: number;
    /** The total number of estimation points after each week. */
    scopeHistory: number[];
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments: boolean;
    /** Whether to send new issue status updates to Slack. */
    slackIssueStatuses: boolean;
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue: boolean;
    /** The project's unique URL slug. */
    slugId: string;
    /** The sort order for the project within the organization. */
    sortOrder: number;
    /** The estimated start date of the project. */
    startDate?: L.Scalars["TimelessDate"];
    /** The time at which the project was moved into started state. */
    startedAt?: Date;
    /** The type of the state. */
    state: string;
    /** The estimated completion date of the project. */
    targetDate?: L.Scalars["TimelessDate"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** Project URL. */
    url: string;
    /** The project was created based on this issue. */
    get convertedFromIssue(): LinearFetch<Issue> | undefined;
    /** The user who created the project. */
    get creator(): LinearFetch<User> | undefined;
    /** Settings for all integrations associated with that project. */
    get integrationsSettings(): LinearFetch<IntegrationsSettings> | undefined;
    /** The project lead. */
    get lead(): LinearFetch<User> | undefined;
    /** Documents associated with the project. */
    documents(variables?: Omit<L.Project_DocumentsQueryVariables, "id">): LinearFetch<DocumentConnection>;
    /** Issues associated with the project. */
    issues(variables?: Omit<L.Project_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Links associated with the project. */
    links(variables?: Omit<L.Project_LinksQueryVariables, "id">): LinearFetch<ProjectLinkConnection>;
    /** Users that are members of the project. */
    members(variables?: Omit<L.Project_MembersQueryVariables, "id">): LinearFetch<UserConnection>;
    /** Milestones associated with the project. */
    projectMilestones(variables?: Omit<L.Project_ProjectMilestonesQueryVariables, "id">): LinearFetch<ProjectMilestoneConnection>;
    /** Project updates associated with the project. */
    projectUpdates(variables?: Omit<L.Project_ProjectUpdatesQueryVariables, "id">): LinearFetch<ProjectUpdateConnection>;
    /** Teams associated with this project. */
    teams(variables?: Omit<L.Project_TeamsQueryVariables, "id">): LinearFetch<TeamConnection>;
    /** Archives a project. */
    archive(): LinearFetch<ProjectArchivePayload>;
    /** Creates a new project. */
    create(input: L.ProjectCreateInput): LinearFetch<ProjectPayload>;
    /** Deletes a project. All issues will be disassociated from the deleted project. */
    delete(): LinearFetch<DeletePayload>;
    /** Unarchives a project. */
    unarchive(): LinearFetch<ProjectArchivePayload>;
    /** Updates a project. */
    update(input: L.ProjectUpdateInput): LinearFetch<ProjectPayload>;
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectArchivePayloadFragment response data
 */
export declare class ProjectArchivePayload extends Request {
    private _entity?;
    constructor(request: LinearRequest, data: L.ProjectArchivePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The archived/unarchived entity. Null if entity was deleted. */
    get entity(): LinearFetch<Project> | undefined;
}
/**
 * ProjectConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ProjectConnection model
 * @param data - ProjectConnection response data
 */
export declare class ProjectConnection extends Connection<Project> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Project> | undefined>, data: L.ProjectConnectionFragment);
}
/**
 * ProjectFilterSuggestionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectFilterSuggestionPayloadFragment response data
 */
export declare class ProjectFilterSuggestionPayload extends Request {
    constructor(request: LinearRequest, data: L.ProjectFilterSuggestionPayloadFragment);
    /** The json filter that is suggested. */
    filter?: Record<string, unknown>;
}
/**
 * An external link for a project.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectLinkFragment response data
 */
export declare class ProjectLink extends Request {
    private _creator;
    private _project;
    constructor(request: LinearRequest, data: L.ProjectLinkFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The link's label. */
    label: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The link's URL. */
    url: string;
    /** The user who created the link. */
    get creator(): LinearFetch<User> | undefined;
    /** The project that the link is associated with. */
    get project(): LinearFetch<Project> | undefined;
    /** Creates a new project link. */
    create(input: L.ProjectLinkCreateInput): LinearFetch<ProjectLinkPayload>;
    /** Deletes a project link. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates a project link. */
    update(input: L.ProjectLinkUpdateInput): LinearFetch<ProjectLinkPayload>;
}
/**
 * ProjectLinkConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ProjectLinkConnection model
 * @param data - ProjectLinkConnection response data
 */
export declare class ProjectLinkConnection extends Connection<ProjectLink> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<ProjectLink> | undefined>, data: L.ProjectLinkConnectionFragment);
}
/**
 * ProjectLinkPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectLinkPayloadFragment response data
 */
export declare class ProjectLinkPayload extends Request {
    private _projectLink;
    constructor(request: LinearRequest, data: L.ProjectLinkPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The project that was created or updated. */
    get projectLink(): LinearFetch<ProjectLink> | undefined;
}
/**
 * A milestone for a project.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectMilestoneFragment response data
 */
export declare class ProjectMilestone extends Request {
    private _project;
    constructor(request: LinearRequest, data: L.ProjectMilestoneFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The description of the project milestone. */
    description?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The name of the project milestone. */
    name: string;
    /** The order of the milestone in relation to other milestones within a project. */
    sortOrder: number;
    /** The planned completion date of the milestone. */
    targetDate?: L.Scalars["TimelessDate"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The project of the milestone. */
    get project(): LinearFetch<Project> | undefined;
    /** Creates a new project milestone. */
    create(input: L.ProjectMilestoneCreateInput): LinearFetch<ProjectMilestonePayload>;
    /** Deletes a project milestone. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates a project milestone. */
    update(input: L.ProjectMilestoneUpdateInput): LinearFetch<ProjectMilestonePayload>;
}
/**
 * ProjectMilestoneConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ProjectMilestoneConnection model
 * @param data - ProjectMilestoneConnection response data
 */
export declare class ProjectMilestoneConnection extends Connection<ProjectMilestone> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<ProjectMilestone> | undefined>, data: L.ProjectMilestoneConnectionFragment);
}
/**
 * ProjectMilestonePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectMilestonePayloadFragment response data
 */
export declare class ProjectMilestonePayload extends Request {
    private _projectMilestone;
    constructor(request: LinearRequest, data: L.ProjectMilestonePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The project milestone that was created or updated. */
    get projectMilestone(): LinearFetch<ProjectMilestone> | undefined;
}
/**
 * A project related notification
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectNotificationFragment response data
 */
export declare class ProjectNotification extends Request {
    private _actor?;
    private _project;
    private _projectUpdate?;
    private _user;
    constructor(request: LinearRequest, data: L.ProjectNotificationFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /**
     * The time at when an email reminder for this notification was sent to the user. Null, if no email
     *     reminder has been sent.
     */
    emailedAt?: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
    readAt?: Date;
    /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
    snoozedUntilAt?: Date;
    /** Notification type */
    type: string;
    /** The time at which a notification was unsnoozed.. */
    unsnoozedAt?: Date;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The user that caused the notification. */
    get actor(): LinearFetch<User> | undefined;
    /** The project related to the notification. */
    get project(): LinearFetch<Project> | undefined;
    /** The project update related to the notification. */
    get projectUpdate(): LinearFetch<ProjectUpdate> | undefined;
    /** The user that received the notification. */
    get user(): LinearFetch<User> | undefined;
}
/**
 * A project notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectNotificationSubscriptionFragment response data
 */
export declare class ProjectNotificationSubscription extends Request {
    private _customView?;
    private _cycle?;
    private _label?;
    private _project;
    private _subscriber;
    private _team?;
    private _user?;
    constructor(request: LinearRequest, data: L.ProjectNotificationSubscriptionFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The type of subscription. */
    notificationSubscriptionTypes: string[];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The contextual custom view associated with the notification subscription. */
    get customView(): LinearFetch<CustomView> | undefined;
    /** The contextual cycle view associated with the notification subscription. */
    get cycle(): LinearFetch<Cycle> | undefined;
    /** The contextual label view associated with the notification subscription. */
    get label(): LinearFetch<IssueLabel> | undefined;
    /** The project subscribed to. */
    get project(): LinearFetch<Project> | undefined;
    /** The user that subscribed to receive notifications. */
    get subscriber(): LinearFetch<User> | undefined;
    /** The team associated with the notification subscription. */
    get team(): LinearFetch<Team> | undefined;
    /** The user view associated with the notification subscription. */
    get user(): LinearFetch<User> | undefined;
}
/**
 * ProjectPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectPayloadFragment response data
 */
export declare class ProjectPayload extends Request {
    private _project?;
    constructor(request: LinearRequest, data: L.ProjectPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The project that was created or updated. */
    get project(): LinearFetch<Project> | undefined;
}
/**
 * ProjectSearchPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectSearchPayloadFragment response data
 */
export declare class ProjectSearchPayload extends Request {
    constructor(request: LinearRequest, data: L.ProjectSearchPayloadFragment);
    /** Total number of results for query without filters applied. */
    totalCount: number;
    nodes: ProjectSearchResult[];
    /** Archived entities matching the search term along with all their dependencies. */
    archivePayload: ArchiveResponse;
    pageInfo: PageInfo;
}
/**
 * ProjectSearchResult model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectSearchResultFragment response data
 */
export declare class ProjectSearchResult extends Request {
    private _convertedFromIssue?;
    private _creator;
    private _integrationsSettings?;
    private _lead?;
    constructor(request: LinearRequest, data: L.ProjectSearchResultFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the project was automatically archived by the auto pruning process. */
    autoArchivedAt?: Date;
    /** The time at which the project was moved into canceled state. */
    canceledAt?: Date;
    /** The project's color. */
    color: string;
    /** The time at which the project was moved into completed state. */
    completedAt?: Date;
    /** The number of completed issues in the project after each week. */
    completedIssueCountHistory: number[];
    /** The number of completed estimation points after each week. */
    completedScopeHistory: number[];
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The project's description. */
    description: string;
    /** The icon of the project. */
    icon?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The number of in progress estimation points after each week. */
    inProgressScopeHistory: number[];
    /** The total number of issues in the project after each week. */
    issueCountHistory: number[];
    /** Metadata related to search result */
    metadata: Record<string, unknown>;
    /** The project's name. */
    name: string;
    /** The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points. */
    progress: number;
    /** The time until which project update reminders are paused. */
    projectUpdateRemindersPausedUntilAt?: Date;
    /** The overall scope (total estimate points) of the project. */
    scope: number;
    /** The total number of estimation points after each week. */
    scopeHistory: number[];
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments: boolean;
    /** Whether to send new issue status updates to Slack. */
    slackIssueStatuses: boolean;
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue: boolean;
    /** The project's unique URL slug. */
    slugId: string;
    /** The sort order for the project within the organization. */
    sortOrder: number;
    /** The estimated start date of the project. */
    startDate?: L.Scalars["TimelessDate"];
    /** The time at which the project was moved into started state. */
    startedAt?: Date;
    /** The type of the state. */
    state: string;
    /** The estimated completion date of the project. */
    targetDate?: L.Scalars["TimelessDate"];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** Project URL. */
    url: string;
    /** The project was created based on this issue. */
    get convertedFromIssue(): LinearFetch<Issue> | undefined;
    /** The user who created the project. */
    get creator(): LinearFetch<User> | undefined;
    /** Settings for all integrations associated with that project. */
    get integrationsSettings(): LinearFetch<IntegrationsSettings> | undefined;
    /** The project lead. */
    get lead(): LinearFetch<User> | undefined;
}
/**
 * ProjectSearchResultConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ProjectSearchResultConnection model
 * @param data - ProjectSearchResultConnection response data
 */
export declare class ProjectSearchResultConnection extends Connection<ProjectSearchResult> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<ProjectSearchResult> | undefined>, data: L.ProjectSearchResultConnectionFragment);
}
/**
 * A update associated with an project.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectUpdateFragment response data
 */
export declare class ProjectUpdate extends Request {
    private _project;
    private _user;
    constructor(request: LinearRequest, data: L.ProjectUpdateFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The update content in markdown format. */
    body: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The time the project update was edited. */
    editedAt?: Date;
    /** The unique identifier of the entity. */
    id: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The URL to the project update. */
    url: string;
    /** The project that the update is associated with. */
    get project(): LinearFetch<Project> | undefined;
    /** The user who wrote the update. */
    get user(): LinearFetch<User> | undefined;
    /** Creates a new project update. */
    create(input: L.ProjectUpdateCreateInput): LinearFetch<ProjectUpdatePayload>;
    /** Deletes a project update. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates a project update. */
    update(input: L.ProjectUpdateUpdateInput): LinearFetch<ProjectUpdatePayload>;
}
/**
 * ProjectUpdateConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ProjectUpdateConnection model
 * @param data - ProjectUpdateConnection response data
 */
export declare class ProjectUpdateConnection extends Connection<ProjectUpdate> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<ProjectUpdate> | undefined>, data: L.ProjectUpdateConnectionFragment);
}
/**
 * Holds information about when a user has interacted with a project update.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectUpdateInteractionFragment response data
 */
export declare class ProjectUpdateInteraction extends Request {
    private _projectUpdate;
    private _user;
    constructor(request: LinearRequest, data: L.ProjectUpdateInteractionFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The time at which the user read the project update. */
    readAt: Date;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The project update that has been interacted with. */
    get projectUpdate(): LinearFetch<ProjectUpdate> | undefined;
    /** The user that has interacted with the project update. */
    get user(): LinearFetch<User> | undefined;
    /** Creates a new interaction on a project update. */
    create(input: L.ProjectUpdateInteractionCreateInput): LinearFetch<ProjectUpdateInteractionPayload>;
}
/**
 * ProjectUpdateInteractionConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ProjectUpdateInteractionConnection model
 * @param data - ProjectUpdateInteractionConnection response data
 */
export declare class ProjectUpdateInteractionConnection extends Connection<ProjectUpdateInteraction> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<ProjectUpdateInteraction> | undefined>, data: L.ProjectUpdateInteractionConnectionFragment);
}
/**
 * ProjectUpdateInteractionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectUpdateInteractionPayloadFragment response data
 */
export declare class ProjectUpdateInteractionPayload extends Request {
    private _projectUpdateInteraction;
    constructor(request: LinearRequest, data: L.ProjectUpdateInteractionPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The project update interaction that was created or updated. */
    get projectUpdateInteraction(): LinearFetch<ProjectUpdateInteraction> | undefined;
}
/**
 * ProjectUpdatePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectUpdatePayloadFragment response data
 */
export declare class ProjectUpdatePayload extends Request {
    private _projectUpdate;
    constructor(request: LinearRequest, data: L.ProjectUpdatePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The project update that was created or updated. */
    get projectUpdate(): LinearFetch<ProjectUpdate> | undefined;
}
/**
 * ProjectUpdateWithInteractionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectUpdateWithInteractionPayloadFragment response data
 */
export declare class ProjectUpdateWithInteractionPayload extends Request {
    private _interaction;
    private _projectUpdate;
    constructor(request: LinearRequest, data: L.ProjectUpdateWithInteractionPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The project update that was created or updated. */
    get interaction(): LinearFetch<ProjectUpdateInteraction> | undefined;
    /** The project update that was created or updated. */
    get projectUpdate(): LinearFetch<ProjectUpdate> | undefined;
}
/**
 * A user's web browser push notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.PushSubscriptionFragment response data
 */
export declare class PushSubscription extends Request {
    constructor(request: LinearRequest, data: L.PushSubscriptionFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** Creates a push subscription. */
    create(input: L.PushSubscriptionCreateInput): LinearFetch<PushSubscriptionPayload>;
    /** Deletes a push subscription. */
    delete(): LinearFetch<PushSubscriptionPayload>;
}
/**
 * PushSubscriptionConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this PushSubscriptionConnection model
 * @param data - PushSubscriptionConnection response data
 */
export declare class PushSubscriptionConnection extends Connection<PushSubscription> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<PushSubscription> | undefined>, data: L.PushSubscriptionConnectionFragment);
}
/**
 * PushSubscriptionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.PushSubscriptionPayloadFragment response data
 */
export declare class PushSubscriptionPayload extends Request {
    constructor(request: LinearRequest, data: L.PushSubscriptionPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * PushSubscriptionTestPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.PushSubscriptionTestPayloadFragment response data
 */
export declare class PushSubscriptionTestPayload extends Request {
    constructor(request: LinearRequest, data: L.PushSubscriptionTestPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * RateLimitPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.RateLimitPayloadFragment response data
 */
export declare class RateLimitPayload extends Request {
    constructor(request: LinearRequest, data: L.RateLimitPayloadFragment);
    /** The identifier we rate limit on. */
    identifier?: string;
    /** The kind of rate limit selected for this request. */
    kind: string;
    /** The state of the rate limit. */
    limits: RateLimitResultPayload[];
}
/**
 * RateLimitResultPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.RateLimitResultPayloadFragment response data
 */
export declare class RateLimitResultPayload extends Request {
    constructor(request: LinearRequest, data: L.RateLimitResultPayloadFragment);
    /** The total allowed quantity for this type of limit. */
    allowedAmount: number;
    /** The period in which the rate limit is fully replenished in ms. */
    period: number;
    /** The remaining quantity for this type of limit after this request. */
    remainingAmount: number;
    /** The requested quantity for this type of limit. */
    requestedAmount: number;
    /** The timestamp after the rate limit is fully replenished as a UNIX timestamp. */
    reset: number;
    /** What is being rate limited. */
    type: string;
}
/**
 * A reaction associated with a comment or a project update.
 *
 * @param request - function to call the graphql client
 * @param data - L.ReactionFragment response data
 */
export declare class Reaction extends Request {
    private _user?;
    constructor(request: LinearRequest, data: L.ReactionFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Name of the reaction's emoji. */
    emoji: string;
    /** The unique identifier of the entity. */
    id: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The user who reacted. */
    get user(): LinearFetch<User> | undefined;
    /** Creates a new reaction. */
    create(input: L.ReactionCreateInput): LinearFetch<ReactionPayload>;
    /** Deletes a reaction. */
    delete(): LinearFetch<DeletePayload>;
}
/**
 * ReactionConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ReactionConnection model
 * @param data - ReactionConnection response data
 */
export declare class ReactionConnection extends Connection<Reaction> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Reaction> | undefined>, data: L.ReactionConnectionFragment);
}
/**
 * ReactionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ReactionPayloadFragment response data
 */
export declare class ReactionPayload extends Request {
    constructor(request: LinearRequest, data: L.ReactionPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    success: boolean;
    reaction: Reaction;
}
/**
 * A roadmap for projects.
 *
 * @param request - function to call the graphql client
 * @param data - L.RoadmapFragment response data
 */
export declare class Roadmap extends Request {
    private _creator;
    private _owner;
    constructor(request: LinearRequest, data: L.RoadmapFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The roadmap's color. */
    color?: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The description of the roadmap. */
    description?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The name of the roadmap. */
    name: string;
    /** The roadmap's unique URL slug. */
    slugId: string;
    /** The sort order of the roadmap within the organization. */
    sortOrder: number;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The user who created the roadmap. */
    get creator(): LinearFetch<User> | undefined;
    /** The organization of the roadmap. */
    get organization(): LinearFetch<Organization>;
    /** The user who owns the roadmap. */
    get owner(): LinearFetch<User> | undefined;
    /** Projects associated with the roadmap. */
    projects(variables?: Omit<L.Roadmap_ProjectsQueryVariables, "id">): LinearFetch<ProjectConnection>;
    /** Archives a roadmap. */
    archive(): LinearFetch<RoadmapArchivePayload>;
    /** Creates a new roadmap. */
    create(input: L.RoadmapCreateInput): LinearFetch<RoadmapPayload>;
    /** Deletes a roadmap. */
    delete(): LinearFetch<DeletePayload>;
    /** Unarchives a roadmap. */
    unarchive(): LinearFetch<RoadmapArchivePayload>;
    /** Updates a roadmap. */
    update(input: L.RoadmapUpdateInput): LinearFetch<RoadmapPayload>;
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.RoadmapArchivePayloadFragment response data
 */
export declare class RoadmapArchivePayload extends Request {
    private _entity?;
    constructor(request: LinearRequest, data: L.RoadmapArchivePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The archived/unarchived entity. Null if entity was deleted. */
    get entity(): LinearFetch<Roadmap> | undefined;
}
/**
 * RoadmapConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this RoadmapConnection model
 * @param data - RoadmapConnection response data
 */
export declare class RoadmapConnection extends Connection<Roadmap> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Roadmap> | undefined>, data: L.RoadmapConnectionFragment);
}
/**
 * RoadmapPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.RoadmapPayloadFragment response data
 */
export declare class RoadmapPayload extends Request {
    private _roadmap;
    constructor(request: LinearRequest, data: L.RoadmapPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The roadmap that was created or updated. */
    get roadmap(): LinearFetch<Roadmap> | undefined;
}
/**
 * Join table between projects and roadmaps
 *
 * @param request - function to call the graphql client
 * @param data - L.RoadmapToProjectFragment response data
 */
export declare class RoadmapToProject extends Request {
    private _project;
    private _roadmap;
    constructor(request: LinearRequest, data: L.RoadmapToProjectFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The sort order of the project within the roadmap. */
    sortOrder: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The project that the roadmap is associated with. */
    get project(): LinearFetch<Project> | undefined;
    /** The roadmap that the project is associated with. */
    get roadmap(): LinearFetch<Roadmap> | undefined;
    /** Creates a new roadmapToProject join. */
    create(input: L.RoadmapToProjectCreateInput): LinearFetch<RoadmapToProjectPayload>;
    /** Deletes a roadmapToProject. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates a roadmapToProject. */
    update(input: L.RoadmapToProjectUpdateInput): LinearFetch<RoadmapToProjectPayload>;
}
/**
 * RoadmapToProjectConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this RoadmapToProjectConnection model
 * @param data - RoadmapToProjectConnection response data
 */
export declare class RoadmapToProjectConnection extends Connection<RoadmapToProject> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<RoadmapToProject> | undefined>, data: L.RoadmapToProjectConnectionFragment);
}
/**
 * RoadmapToProjectPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.RoadmapToProjectPayloadFragment response data
 */
export declare class RoadmapToProjectPayload extends Request {
    private _roadmapToProject;
    constructor(request: LinearRequest, data: L.RoadmapToProjectPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The roadmapToProject that was created or updated. */
    get roadmapToProject(): LinearFetch<RoadmapToProject> | undefined;
}
/**
 * SamlConfiguration model
 *
 * @param request - function to call the graphql client
 * @param data - L.SamlConfigurationFragment response data
 */
export declare class SamlConfiguration extends Request {
    constructor(request: LinearRequest, data: L.SamlConfigurationFragment);
    /** The issuer's custom entity ID. */
    issuerEntityId?: string;
    /** Binding method for authentication call. Can be either `post` (default) or `redirect`. */
    ssoBinding?: string;
    /** Sign in endpoint URL for the identity provider. */
    ssoEndpoint?: string;
    /** The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`. */
    ssoSignAlgo?: string;
    /** X.509 Signing Certificate in string form. */
    ssoSigningCert?: string;
}
/**
 * The organization's SAML configuration
 *
 * @param request - function to call the graphql client
 * @param data - L.SamlConfigurationPayloadFragment response data
 */
export declare class SamlConfigurationPayload extends Request {
    constructor(request: LinearRequest, data: L.SamlConfigurationPayloadFragment);
    /** The issuer's custom entity ID. */
    issuerEntityId?: string;
    /** Binding method for authentication call. Can be either `post` (default) or `redirect`. */
    ssoBinding?: string;
    /** Sign in endpoint URL for the identity provider. */
    ssoEndpoint?: string;
    /** The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`. */
    ssoSignAlgo?: string;
}
/**
 * Sentry specific settings.
 *
 * @param request - function to call the graphql client
 * @param data - L.SentrySettingsFragment response data
 */
export declare class SentrySettings extends Request {
    constructor(request: LinearRequest, data: L.SentrySettingsFragment);
    /** The slug of the Sentry organization being connected. */
    organizationSlug: string;
}
/**
 * Slack notification specific settings.
 *
 * @param request - function to call the graphql client
 * @param data - L.SlackPostSettingsFragment response data
 */
export declare class SlackPostSettings extends Request {
    constructor(request: LinearRequest, data: L.SlackPostSettingsFragment);
    channel: string;
    channelId: string;
    configurationUrl: string;
}
/**
 * SsoUrlFromEmailResponse model
 *
 * @param request - function to call the graphql client
 * @param data - L.SsoUrlFromEmailResponseFragment response data
 */
export declare class SsoUrlFromEmailResponse extends Request {
    constructor(request: LinearRequest, data: L.SsoUrlFromEmailResponseFragment);
    /** SAML SSO sign-in URL. */
    samlSsoUrl: string;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * Contains either the full serialized state of the application or delta packets that the requester can
 *   apply to the local data set in order to be up-to-date.
 *
 * @param request - function to call the graphql client
 * @param data - L.SyncResponseFragment response data
 */
export declare class SyncResponse extends Request {
    constructor(request: LinearRequest, data: L.SyncResponseFragment);
    /** The version of the remote database. Incremented by 1 for each migration run on the database. */
    databaseVersion: number;
    /**
     * JSON serialized delta changes that the client can apply to its local state
     *     in order to catch up with the state of the world.
     */
    delta?: string;
    /** The last sync id covered by the response. */
    lastSyncId: number;
    /**
     * The full state of the organization as a serialized JSON object.
     *     Mutually exclusive with the delta property
     */
    state?: string;
    /** The sync groups that the user is subscribed to. */
    subscribedSyncGroups: string[];
}
/**
 * SynchronizedPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.SynchronizedPayloadFragment response data
 */
export declare class SynchronizedPayload extends Request {
    constructor(request: LinearRequest, data: L.SynchronizedPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
}
/**
 * An organizational unit that contains issues.
 *
 * @param request - function to call the graphql client
 * @param data - L.TeamFragment response data
 */
export declare class Team extends Request {
    private _activeCycle?;
    private _defaultIssueState?;
    private _defaultTemplateForMembers?;
    private _defaultTemplateForNonMembers?;
    private _draftWorkflowState?;
    private _integrationsSettings?;
    private _markedAsDuplicateWorkflowState?;
    private _mergeWorkflowState?;
    private _reviewWorkflowState?;
    private _startWorkflowState?;
    private _triageIssueState?;
    constructor(request: LinearRequest, data: L.TeamFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** Period after which automatically closed and completed issues are automatically archived in months. */
    autoArchivePeriod: number;
    /** Period after which issues are automatically closed in months. Null/undefined means disabled. */
    autoClosePeriod?: number;
    /** The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state. */
    autoCloseStateId?: string;
    /** The team's color. */
    color?: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Calendar feed URL (iCal) for cycles. */
    cycleCalenderUrl: string;
    /** The cooldown time after each cycle in weeks. */
    cycleCooldownTime: number;
    /** The duration of a cycle in weeks. */
    cycleDuration: number;
    /** Auto assign completed issues to current cycle. */
    cycleIssueAutoAssignCompleted: boolean;
    /** Auto assign started issues to current cycle. */
    cycleIssueAutoAssignStarted: boolean;
    /** Only allow issues issues with cycles in Active Issues. */
    cycleLockToActive: boolean;
    /** The day of the week that a new cycle starts. */
    cycleStartDay: number;
    /** Whether the team uses cycles. */
    cyclesEnabled: boolean;
    /** What to use as an default estimate for unestimated issues. */
    defaultIssueEstimate: number;
    /** The id of the default template to use for new issues created by members of the team. */
    defaultTemplateForMembersId?: string;
    /** The id of the default template to use for new issues created by non-members of the team. */
    defaultTemplateForNonMembersId?: string;
    /** The team's description. */
    description?: string;
    /** Whether to group recent issue history entries. */
    groupIssueHistory: boolean;
    /** The icon of the team. */
    icon?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** Unique hash for the team to be used in invite URLs. */
    inviteHash: string;
    /** Number of issues in the team. */
    issueCount: number;
    /** Whether to allow zeros in issues estimates. */
    issueEstimationAllowZero: boolean;
    /** Whether to add additional points to the estimate scale. */
    issueEstimationExtended: boolean;
    /** The issue estimation type to use. Must be one of "notUsed", "exponential", "fibonacci", "linear", "tShirt". */
    issueEstimationType: string;
    /** Whether issues without priority should be sorted first. */
    issueOrderingNoPriorityFirst: boolean;
    /** Whether to move issues to bottom of the column when changing state. */
    issueSortOrderDefaultToBottom: boolean;
    /** The team's unique key. The key is used in URLs. */
    key: string;
    /** The team's name. */
    name: string;
    /** Whether the team is private or not. */
    private: boolean;
    /** Whether an issue needs to have a priority set before leaving triage */
    requirePriorityToLeaveTriage: boolean;
    /** Whether to send new issue comment notifications to Slack. */
    slackIssueComments: boolean;
    /** Whether to send new issue status updates to Slack. */
    slackIssueStatuses: boolean;
    /** Whether to send new issue notifications to Slack. */
    slackNewIssue: boolean;
    /** The timezone of the team. Defaults to "America/Los_Angeles" */
    timezone: string;
    /** Whether triage mode is enabled for the team or not. */
    triageEnabled: boolean;
    /** How many upcoming cycles to create. */
    upcomingCycleCount: number;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** Team's currently active cycle. */
    get activeCycle(): LinearFetch<Cycle> | undefined;
    /** The default workflow state into which issues are set when they are opened by team members. */
    get defaultIssueState(): LinearFetch<WorkflowState> | undefined;
    /** The default template to use for new issues created by members of the team. */
    get defaultTemplateForMembers(): LinearFetch<Template> | undefined;
    /** The default template to use for new issues created by non-members of the team. */
    get defaultTemplateForNonMembers(): LinearFetch<Template> | undefined;
    /** The workflow state into which issues are moved when a PR has been opened as draft. */
    get draftWorkflowState(): LinearFetch<WorkflowState> | undefined;
    /** Settings for all integrations associated with that team. */
    get integrationsSettings(): LinearFetch<IntegrationsSettings> | undefined;
    /** The workflow state into which issues are moved when they are marked as a duplicate of another issue. Defaults to the first canceled state. */
    get markedAsDuplicateWorkflowState(): LinearFetch<WorkflowState> | undefined;
    /** The workflow state into which issues are moved when a PR has been merged. */
    get mergeWorkflowState(): LinearFetch<WorkflowState> | undefined;
    /** The organization that the team is associated with. */
    get organization(): LinearFetch<Organization>;
    /** The workflow state into which issues are moved when a review has been requested for the PR. */
    get reviewWorkflowState(): LinearFetch<WorkflowState> | undefined;
    /** The workflow state into which issues are moved when a PR has been opened. */
    get startWorkflowState(): LinearFetch<WorkflowState> | undefined;
    /** The workflow state into which issues are set when they are opened by non-team members or integrations if triage is enabled. */
    get triageIssueState(): LinearFetch<WorkflowState> | undefined;
    /** Cycles associated with the team. */
    cycles(variables?: Omit<L.Team_CyclesQueryVariables, "id">): LinearFetch<CycleConnection>;
    /** Issues associated with the team. */
    issues(variables?: Omit<L.Team_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Labels associated with the team. */
    labels(variables?: Omit<L.Team_LabelsQueryVariables, "id">): LinearFetch<IssueLabelConnection>;
    /** Users who are members of this team. */
    members(variables?: Omit<L.Team_MembersQueryVariables, "id">): LinearFetch<UserConnection>;
    /** Memberships associated with the team. For easier access of the same data, use `members` query. */
    memberships(variables?: Omit<L.Team_MembershipsQueryVariables, "id">): LinearFetch<TeamMembershipConnection>;
    /** Projects associated with the team. */
    projects(variables?: Omit<L.Team_ProjectsQueryVariables, "id">): LinearFetch<ProjectConnection>;
    /** The states that define the workflow associated with the team. */
    states(variables?: Omit<L.Team_StatesQueryVariables, "id">): LinearFetch<WorkflowStateConnection>;
    /** Templates associated with the team. */
    templates(variables?: Omit<L.Team_TemplatesQueryVariables, "id">): LinearFetch<TemplateConnection>;
    /** Webhooks associated with the team. */
    webhooks(variables?: Omit<L.Team_WebhooksQueryVariables, "id">): LinearFetch<WebhookConnection>;
    /** Creates a new team. The user who creates the team will automatically be added as a member to the newly created team. */
    create(input: L.TeamCreateInput, variables?: Omit<L.CreateTeamMutationVariables, "input">): LinearFetch<TeamPayload>;
    /** Deletes a team. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates a team. */
    update(input: L.TeamUpdateInput): LinearFetch<TeamPayload>;
}
/**
 * TeamConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this TeamConnection model
 * @param data - TeamConnection response data
 */
export declare class TeamConnection extends Connection<Team> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Team> | undefined>, data: L.TeamConnectionFragment);
}
/**
 * Defines the membership of a user to a team.
 *
 * @param request - function to call the graphql client
 * @param data - L.TeamMembershipFragment response data
 */
export declare class TeamMembership extends Request {
    private _team;
    private _user;
    constructor(request: LinearRequest, data: L.TeamMembershipFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** Whether the user is the owner of the team */
    owner?: boolean;
    /** The order of the item in the users team list. */
    sortOrder: number;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The team that the membership is associated with. */
    get team(): LinearFetch<Team> | undefined;
    /** The user that the membership is associated with. */
    get user(): LinearFetch<User> | undefined;
    /** Creates a new team membership. */
    create(input: L.TeamMembershipCreateInput): LinearFetch<TeamMembershipPayload>;
    /** Deletes a team membership. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates a team membership. */
    update(input: L.TeamMembershipUpdateInput): LinearFetch<TeamMembershipPayload>;
}
/**
 * TeamMembershipConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this TeamMembershipConnection model
 * @param data - TeamMembershipConnection response data
 */
export declare class TeamMembershipConnection extends Connection<TeamMembership> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<TeamMembership> | undefined>, data: L.TeamMembershipConnectionFragment);
}
/**
 * TeamMembershipPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.TeamMembershipPayloadFragment response data
 */
export declare class TeamMembershipPayload extends Request {
    private _teamMembership?;
    constructor(request: LinearRequest, data: L.TeamMembershipPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The team membership that was created or updated. */
    get teamMembership(): LinearFetch<TeamMembership> | undefined;
}
/**
 * A team notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.TeamNotificationSubscriptionFragment response data
 */
export declare class TeamNotificationSubscription extends Request {
    private _customView?;
    private _cycle?;
    private _label?;
    private _project?;
    private _subscriber;
    private _team;
    private _user?;
    constructor(request: LinearRequest, data: L.TeamNotificationSubscriptionFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The type of subscription. */
    notificationSubscriptionTypes: string[];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The contextual custom view associated with the notification subscription. */
    get customView(): LinearFetch<CustomView> | undefined;
    /** The contextual cycle view associated with the notification subscription. */
    get cycle(): LinearFetch<Cycle> | undefined;
    /** The contextual label view associated with the notification subscription. */
    get label(): LinearFetch<IssueLabel> | undefined;
    /** The contextual project view associated with the notification subscription. */
    get project(): LinearFetch<Project> | undefined;
    /** The user that subscribed to receive notifications. */
    get subscriber(): LinearFetch<User> | undefined;
    /** The team subscribed to. */
    get team(): LinearFetch<Team> | undefined;
    /** The user view associated with the notification subscription. */
    get user(): LinearFetch<User> | undefined;
}
/**
 * TeamPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.TeamPayloadFragment response data
 */
export declare class TeamPayload extends Request {
    private _team?;
    constructor(request: LinearRequest, data: L.TeamPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The team that was created or updated. */
    get team(): LinearFetch<Team> | undefined;
}
/**
 * A template object used for creating entities faster.
 *
 * @param request - function to call the graphql client
 * @param data - L.TemplateFragment response data
 */
export declare class Template extends Request {
    private _creator?;
    private _lastUpdatedBy?;
    private _team?;
    constructor(request: LinearRequest, data: L.TemplateFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Template description. */
    description?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The name of the template. */
    name: string;
    /** Template data. */
    templateData: Record<string, unknown>;
    /** The entity type this template is for. */
    type: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The user who created the template. */
    get creator(): LinearFetch<User> | undefined;
    /** The user who last updated the template. */
    get lastUpdatedBy(): LinearFetch<User> | undefined;
    /** The organization that the template is associated with. If null, the template is associated with a particular team. */
    get organization(): LinearFetch<Organization>;
    /** The team that the template is associated with. If null, the template is global to the workspace. */
    get team(): LinearFetch<Team> | undefined;
    /** Creates a new template. */
    create(input: L.TemplateCreateInput): LinearFetch<TemplatePayload>;
    /** Deletes a template. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates an existing template. */
    update(input: L.TemplateUpdateInput): LinearFetch<TemplatePayload>;
}
/**
 * TemplateConnection model
 *
 * @param request - function to call the graphql client
 * @param data - L.TemplateConnectionFragment response data
 */
export declare class TemplateConnection extends Request {
    constructor(request: LinearRequest, data: L.TemplateConnectionFragment);
    pageInfo: PageInfo;
    get nodes(): LinearFetch<Template[]>;
}
/**
 * TemplatePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.TemplatePayloadFragment response data
 */
export declare class TemplatePayload extends Request {
    private _template;
    constructor(request: LinearRequest, data: L.TemplatePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The template that was created or updated. */
    get template(): LinearFetch<Template> | undefined;
}
/**
 * Object representing Google Cloud upload policy, plus additional data.
 *
 * @param request - function to call the graphql client
 * @param data - L.UploadFileFragment response data
 */
export declare class UploadFile extends Request {
    constructor(request: LinearRequest, data: L.UploadFileFragment);
    /** The asset URL for the uploaded file. (assigned automatically) */
    assetUrl: string;
    /** The content type. */
    contentType: string;
    /** The filename. */
    filename: string;
    metaData?: Record<string, unknown>;
    /** The size of the uploaded file. */
    size: number;
    /** The signed URL the for the uploaded file. (assigned automatically) */
    uploadUrl: string;
    headers: UploadFileHeader[];
}
/**
 * UploadFileHeader model
 *
 * @param request - function to call the graphql client
 * @param data - L.UploadFileHeaderFragment response data
 */
export declare class UploadFileHeader extends Request {
    constructor(request: LinearRequest, data: L.UploadFileHeaderFragment);
    /** Upload file header key. */
    key: string;
    /** Upload file header value. */
    value: string;
}
/**
 * UploadPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UploadPayloadFragment response data
 */
export declare class UploadPayload extends Request {
    constructor(request: LinearRequest, data: L.UploadPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** Object describing the file to be uploaded. */
    uploadFile?: UploadFile;
}
/**
 * A user that has access to the the resources of an organization.
 *
 * @param request - function to call the graphql client
 * @param data - L.UserFragment response data
 */
export declare class User extends Request {
    constructor(request: LinearRequest, data: L.UserFragment);
    /** Whether the user account is active or disabled (suspended). */
    active: boolean;
    /** Whether the user is an organization administrator. */
    admin: boolean;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** An URL to the user's avatar image. */
    avatarUrl?: string;
    /** [DEPRECATED] Hash for the user to be used in calendar URLs. */
    calendarHash?: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Number of issues created. */
    createdIssueCount: number;
    /** A short description of the user, either its title or bio. */
    description?: string;
    /** Reason why is the account disabled. */
    disableReason?: string;
    /** The user's display (nick) name. Unique within each organization. */
    displayName: string;
    /** The user's email address. */
    email: string;
    /** Whether the user is a guest in the workspace and limited to accessing a subset of teams. */
    guest: boolean;
    /** The unique identifier of the entity. */
    id: string;
    /** Unique hash for the user to be used in invite URLs. */
    inviteHash: string;
    /** Whether the user is the currently authenticated user. */
    isMe: boolean;
    /** The last time the user was seen online. If null, the user is currently online. */
    lastSeen?: Date;
    /** The user's full name. */
    name: string;
    /** The emoji to represent the user current status. */
    statusEmoji?: string;
    /** The label of the user current status. */
    statusLabel?: string;
    /** A date at which the user current status should be cleared. */
    statusUntilAt?: Date;
    /** The local timezone of the user. */
    timezone?: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** User's profile URL. */
    url: string;
    /** Organization the user belongs to. */
    get organization(): LinearFetch<Organization>;
    /** Issues assigned to the user. */
    assignedIssues(variables?: Omit<L.User_AssignedIssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Issues created by the user. */
    createdIssues(variables?: Omit<L.User_CreatedIssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Memberships associated with the user. For easier access of the same data, use `teams` query. */
    teamMemberships(variables?: Omit<L.User_TeamMembershipsQueryVariables, "id">): LinearFetch<TeamMembershipConnection>;
    /** Teams the user is part of. */
    teams(variables?: Omit<L.User_TeamsQueryVariables, "id">): LinearFetch<TeamConnection>;
    /** Suspends a user. Can only be called by an admin. */
    suspend(): LinearFetch<UserAdminPayload>;
    /** Un-suspends a user. Can only be called by an admin. */
    unsuspend(): LinearFetch<UserAdminPayload>;
    /** Updates a user. Only available to organization admins and the user themselves. */
    update(input: L.UpdateUserInput): LinearFetch<UserPayload>;
}
/**
 * A user account.
 *
 * @param request - function to call the graphql client
 * @param data - L.UserAccountFragment response data
 */
export declare class UserAccount extends Request {
    constructor(request: LinearRequest, data: L.UserAccountFragment);
    /** The time at which the model was archived. */
    archivedAt?: Date;
    /** The time at which the model was created. */
    createdAt: Date;
    /** The user's email address. */
    email: string;
    /** The models identifier. */
    id: string;
    /** The user's name. */
    name?: string;
    /** The authentication service used to create the account. */
    service: string;
    /** The time at which the model was updated. */
    updatedAt: Date;
    /** Users belonging to the account. */
    users: User[];
}
/**
 * UserAdminPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UserAdminPayloadFragment response data
 */
export declare class UserAdminPayload extends Request {
    constructor(request: LinearRequest, data: L.UserAdminPayloadFragment);
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * Public information of the OAuth application, plus whether the application has been authorized for the given scopes.
 *
 * @param request - function to call the graphql client
 * @param data - L.UserAuthorizedApplicationFragment response data
 */
export declare class UserAuthorizedApplication extends Request {
    constructor(request: LinearRequest, data: L.UserAuthorizedApplicationFragment);
    /** Error associated with the application needing to be requested for approval in the workspace */
    approvalErrorCode?: string;
    /** OAuth application's client ID. */
    clientId: string;
    /** Whether the application was created by Linear. */
    createdByLinear: boolean;
    /** Information about the application. */
    description?: string;
    /** Name of the developer. */
    developer: string;
    /** Url of the developer (homepage or docs). */
    developerUrl: string;
    /** OAuth application's ID. */
    id: string;
    /** Image of the application. */
    imageUrl?: string;
    /** Whether the user has authorized the application for the given scopes. */
    isAuthorized: boolean;
    /** Application name. */
    name: string;
    /** Whether or not webhooks are enabled for the application. */
    webhooksEnabled: boolean;
}
/**
 * UserConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this UserConnection model
 * @param data - UserConnection response data
 */
export declare class UserConnection extends Connection<User> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<User> | undefined>, data: L.UserConnectionFragment);
}
/**
 * A user notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.UserNotificationSubscriptionFragment response data
 */
export declare class UserNotificationSubscription extends Request {
    private _customView?;
    private _cycle?;
    private _label?;
    private _project?;
    private _subscriber;
    private _team?;
    private _user;
    constructor(request: LinearRequest, data: L.UserNotificationSubscriptionFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The type of subscription. */
    notificationSubscriptionTypes: string[];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The contextual custom view associated with the notification subscription. */
    get customView(): LinearFetch<CustomView> | undefined;
    /** The contextual cycle view associated with the notification subscription. */
    get cycle(): LinearFetch<Cycle> | undefined;
    /** The contextual label view associated with the notification subscription. */
    get label(): LinearFetch<IssueLabel> | undefined;
    /** The contextual project view associated with the notification subscription. */
    get project(): LinearFetch<Project> | undefined;
    /** The user that subscribed to receive notifications. */
    get subscriber(): LinearFetch<User> | undefined;
    /** The team associated with the notification subscription. */
    get team(): LinearFetch<Team> | undefined;
    /** The user subscribed to. */
    get user(): LinearFetch<User> | undefined;
}
/**
 * UserPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UserPayloadFragment response data
 */
export declare class UserPayload extends Request {
    private _user?;
    constructor(request: LinearRequest, data: L.UserPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The user that was created or updated. */
    get user(): LinearFetch<User> | undefined;
}
/**
 * The settings of a user as a JSON object.
 *
 * @param request - function to call the graphql client
 * @param data - L.UserSettingsFragment response data
 */
export declare class UserSettings extends Request {
    private _user;
    constructor(request: LinearRequest, data: L.UserSettingsFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** Hash for the user to be used in calendar URLs. */
    calendarHash?: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The notification channel settings the user has selected. */
    notificationPreferences: Record<string, unknown>;
    /** Whether to show full user names instead of display names. */
    showFullUserNames: boolean;
    /** The email types the user has unsubscribed from. */
    unsubscribedFrom: string[];
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The user associated with these settings. */
    get user(): LinearFetch<User> | undefined;
    /** Updates the user's settings. */
    update(input: L.UserSettingsUpdateInput): LinearFetch<UserSettingsPayload>;
}
/**
 * UserSettingsFlagPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UserSettingsFlagPayloadFragment response data
 */
export declare class UserSettingsFlagPayload extends Request {
    constructor(request: LinearRequest, data: L.UserSettingsFlagPayloadFragment);
    /** The flag key which was updated. */
    flag: string;
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The flag value after update. */
    value: number;
}
/**
 * UserSettingsFlagsResetPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UserSettingsFlagsResetPayloadFragment response data
 */
export declare class UserSettingsFlagsResetPayload extends Request {
    constructor(request: LinearRequest, data: L.UserSettingsFlagsResetPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
}
/**
 * UserSettingsPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UserSettingsPayloadFragment response data
 */
export declare class UserSettingsPayload extends Request {
    constructor(request: LinearRequest, data: L.UserSettingsPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The user's settings. */
    get userSettings(): LinearFetch<UserSettings>;
}
/**
 * View preferences.
 *
 * @param request - function to call the graphql client
 * @param data - L.ViewPreferencesFragment response data
 */
export declare class ViewPreferences extends Request {
    constructor(request: LinearRequest, data: L.ViewPreferencesFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The unique identifier of the entity. */
    id: string;
    /** The view preference type. */
    type: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The view type. */
    viewType: string;
    /** Creates a new ViewPreferences object. */
    create(input: L.ViewPreferencesCreateInput): LinearFetch<ViewPreferencesPayload>;
    /** Deletes a ViewPreferences. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates an existing ViewPreferences object. */
    update(input: L.ViewPreferencesUpdateInput): LinearFetch<ViewPreferencesPayload>;
}
/**
 * ViewPreferencesPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ViewPreferencesPayloadFragment response data
 */
export declare class ViewPreferencesPayload extends Request {
    constructor(request: LinearRequest, data: L.ViewPreferencesPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The view preferences entity being mutated. */
    viewPreferences: ViewPreferences;
}
/**
 * A webhook used to send HTTP notifications over data updates
 *
 * @param request - function to call the graphql client
 * @param data - L.WebhookFragment response data
 */
export declare class Webhook extends Request {
    private _creator?;
    private _team?;
    constructor(request: LinearRequest, data: L.WebhookFragment);
    /** Whether the Webhook is enabled for all public teams, including teams created after the webhook was created. */
    allPublicTeams: boolean;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Whether the Webhook is enabled. */
    enabled: boolean;
    /** The unique identifier of the entity. */
    id: string;
    /** Webhook label */
    label?: string;
    /** The resource types this webhook is subscribed to. */
    resourceTypes: string[];
    /** Secret token for verifying the origin on the recipient side. */
    secret?: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** Webhook URL */
    url?: string;
    /** The user who created the webhook. */
    get creator(): LinearFetch<User> | undefined;
    /** The team that the webhook is associated with. If null, the webhook is associated with all public teams of the organization. */
    get team(): LinearFetch<Team> | undefined;
    /** Creates a new webhook. */
    create(input: L.WebhookCreateInput): LinearFetch<WebhookPayload>;
    /** Deletes a Webhook. */
    delete(): LinearFetch<DeletePayload>;
    /** Updates an existing Webhook. */
    update(input: L.WebhookUpdateInput): LinearFetch<WebhookPayload>;
}
/**
 * WebhookConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this WebhookConnection model
 * @param data - WebhookConnection response data
 */
export declare class WebhookConnection extends Connection<Webhook> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Webhook> | undefined>, data: L.WebhookConnectionFragment);
}
/**
 * WebhookPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.WebhookPayloadFragment response data
 */
export declare class WebhookPayload extends Request {
    private _webhook;
    constructor(request: LinearRequest, data: L.WebhookPayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The webhook entity being mutated. */
    get webhook(): LinearFetch<Webhook> | undefined;
}
/**
 * WorkflowCronJobDefinition model
 *
 * @param request - function to call the graphql client
 * @param data - L.WorkflowCronJobDefinitionFragment response data
 */
export declare class WorkflowCronJobDefinition extends Request {
    private _creator;
    private _team;
    constructor(request: LinearRequest, data: L.WorkflowCronJobDefinitionFragment);
    /** An array of activities that will be executed as part of the workflow cron job. */
    activities: Record<string, unknown>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The description of the workflow cron job. */
    description?: string;
    enabled: boolean;
    /** The unique identifier of the entity. */
    id: string;
    /** The name of the workflow cron job. */
    name: string;
    /** Cron schedule which is used to execute the workflow cron job. */
    schedule: Record<string, unknown>;
    /** The sort order of the workflow cron job definition within its siblings. */
    sortOrder: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The user who created the workflow cron job. */
    get creator(): LinearFetch<User> | undefined;
    /** The team associated with the workflow cron job. */
    get team(): LinearFetch<Team> | undefined;
}
/**
 * WorkflowCronJobDefinitionConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this WorkflowCronJobDefinitionConnection model
 * @param data - WorkflowCronJobDefinitionConnection response data
 */
export declare class WorkflowCronJobDefinitionConnection extends Connection<WorkflowCronJobDefinition> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<WorkflowCronJobDefinition> | undefined>, data: L.WorkflowCronJobDefinitionConnectionFragment);
}
/**
 * WorkflowDefinition model
 *
 * @param request - function to call the graphql client
 * @param data - L.WorkflowDefinitionFragment response data
 */
export declare class WorkflowDefinition extends Request {
    private _creator;
    private _customView?;
    private _cycle?;
    private _label?;
    private _project?;
    private _team?;
    private _user?;
    constructor(request: LinearRequest, data: L.WorkflowDefinitionFragment);
    /** An array of activities that will be executed as part of the workflow. */
    activities: Record<string, unknown>;
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The conditions that need to be match for the workflow to be triggered. */
    conditions: Record<string, unknown>;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** The description of the workflow. */
    description?: string;
    enabled: boolean;
    /** The name of the group that the workflow belongs to. */
    groupName?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The name of the workflow. */
    name: string;
    /** The sort order of the workflow definition within its siblings. */
    sortOrder: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The user who created the workflow. */
    get creator(): LinearFetch<User> | undefined;
    /** The context custom view associated with the workflow. */
    get customView(): LinearFetch<CustomView> | undefined;
    /** The contextual cycle view associated with the workflow. */
    get cycle(): LinearFetch<Cycle> | undefined;
    /** The contextual label view associated with the workflow. */
    get label(): LinearFetch<IssueLabel> | undefined;
    /** The contextual project view associated with the workflow. */
    get project(): LinearFetch<Project> | undefined;
    /** The team associated with the workflow. If not set, the workflow is associated with the entire organization. */
    get team(): LinearFetch<Team> | undefined;
    /** The contextual user view associated with the workflow. */
    get user(): LinearFetch<User> | undefined;
}
/**
 * WorkflowDefinitionConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this WorkflowDefinitionConnection model
 * @param data - WorkflowDefinitionConnection response data
 */
export declare class WorkflowDefinitionConnection extends Connection<WorkflowDefinition> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<WorkflowDefinition> | undefined>, data: L.WorkflowDefinitionConnectionFragment);
}
/**
 * A state in a team workflow.
 *
 * @param request - function to call the graphql client
 * @param data - L.WorkflowStateFragment response data
 */
export declare class WorkflowState extends Request {
    private _team;
    constructor(request: LinearRequest, data: L.WorkflowStateFragment);
    /** The time at which the entity was archived. Null if the entity has not been archived. */
    archivedAt?: Date;
    /** The state's UI color as a HEX string. */
    color: string;
    /** The time at which the entity was created. */
    createdAt: Date;
    /** Description of the state. */
    description?: string;
    /** The unique identifier of the entity. */
    id: string;
    /** The state's name. */
    name: string;
    /** The position of the state in the team flow. */
    position: number;
    /** The type of the state. */
    type: string;
    /**
     * The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
     *     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
     *     been updated after creation.
     */
    updatedAt: Date;
    /** The team to which this state belongs to. */
    get team(): LinearFetch<Team> | undefined;
    /** Issues belonging in this state. */
    issues(variables?: Omit<L.WorkflowState_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
    /** Archives a state. Only states with issues that have all been archived can be archived. */
    archive(): LinearFetch<WorkflowStateArchivePayload>;
    /** Creates a new state, adding it to the workflow of a team. */
    create(input: L.WorkflowStateCreateInput): LinearFetch<WorkflowStatePayload>;
    /** Updates a state. */
    update(input: L.WorkflowStateUpdateInput): LinearFetch<WorkflowStatePayload>;
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.WorkflowStateArchivePayloadFragment response data
 */
export declare class WorkflowStateArchivePayload extends Request {
    private _entity?;
    constructor(request: LinearRequest, data: L.WorkflowStateArchivePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The archived/unarchived entity. Null if entity was deleted. */
    get entity(): LinearFetch<WorkflowState> | undefined;
}
/**
 * WorkflowStateConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this WorkflowStateConnection model
 * @param data - WorkflowStateConnection response data
 */
export declare class WorkflowStateConnection extends Connection<WorkflowState> {
    constructor(request: LinearRequest, fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<WorkflowState> | undefined>, data: L.WorkflowStateConnectionFragment);
}
/**
 * WorkflowStatePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.WorkflowStatePayloadFragment response data
 */
export declare class WorkflowStatePayload extends Request {
    private _workflowState;
    constructor(request: LinearRequest, data: L.WorkflowStatePayloadFragment);
    /** The identifier of the last sync operation. */
    lastSyncId: number;
    /** Whether the operation was successful. */
    success: boolean;
    /** The state that was created or updated. */
    get workflowState(): LinearFetch<WorkflowState> | undefined;
}
/**
 * Zendesk specific settings.
 *
 * @param request - function to call the graphql client
 * @param data - L.ZendeskSettingsFragment response data
 */
export declare class ZendeskSettings extends Request {
    constructor(request: LinearRequest, data: L.ZendeskSettingsFragment);
    /** Whether a ticket should be automatically reopened when its linked Linear issue is cancelled. */
    automateTicketReopeningOnCancellation?: boolean;
    /** Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue */
    automateTicketReopeningOnComment?: boolean;
    /** Whether a ticket should be automatically reopened when its linked Linear issue is completed. */
    automateTicketReopeningOnCompletion?: boolean;
    /** The ID of the Linear bot user. */
    botUserId?: string;
    /** Whether an internal message should be added when someone comments on an issue. */
    sendNoteOnComment?: boolean;
    /** Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled). */
    sendNoteOnStatusChange?: boolean;
    /** The subdomain of the Zendesk organization being connected. */
    subdomain: string;
    /** The URL of the connected Zendesk organization. */
    url: string;
}
/**
 * A fetchable AirbyteIntegrationConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AirbyteIntegrationConnectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AirbyteIntegrationConnect mutation and return a IntegrationPayload
     *
     * @param input - required input to pass to airbyteIntegrationConnect
     * @returns parsed response from AirbyteIntegrationConnectMutation
     */
    fetch(input: L.AirbyteConfigurationInput): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable CreateApiKey Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateApiKeyMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateApiKey mutation and return a ApiKeyPayload
     *
     * @param input - required input to pass to createApiKey
     * @returns parsed response from CreateApiKeyMutation
     */
    fetch(input: L.ApiKeyCreateInput): LinearFetch<ApiKeyPayload>;
}
/**
 * A fetchable DeleteApiKey Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteApiKeyMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteApiKey mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteApiKey
     * @returns parsed response from DeleteApiKeyMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable ArchiveAttachment Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ArchiveAttachmentMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ArchiveAttachment mutation and return a AttachmentArchivePayload
     *
     * @param id - required id to pass to archiveAttachment
     * @returns parsed response from ArchiveAttachmentMutation
     */
    fetch(id: string): LinearFetch<AttachmentArchivePayload>;
}
/**
 * A fetchable CreateAttachment Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateAttachmentMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateAttachment mutation and return a AttachmentPayload
     *
     * @param input - required input to pass to createAttachment
     * @returns parsed response from CreateAttachmentMutation
     */
    fetch(input: L.AttachmentCreateInput): LinearFetch<AttachmentPayload>;
}
/**
 * A fetchable DeleteAttachment Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteAttachmentMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteAttachment mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteAttachment
     * @returns parsed response from DeleteAttachmentMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable AttachmentLinkDiscord Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentLinkDiscordMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentLinkDiscord mutation and return a AttachmentPayload
     *
     * @param channelId - required channelId to pass to attachmentLinkDiscord
     * @param issueId - required issueId to pass to attachmentLinkDiscord
     * @param messageId - required messageId to pass to attachmentLinkDiscord
     * @param url - required url to pass to attachmentLinkDiscord
     * @returns parsed response from AttachmentLinkDiscordMutation
     */
    fetch(channelId: string, issueId: string, messageId: string, url: string): LinearFetch<AttachmentPayload>;
}
/**
 * A fetchable AttachmentLinkFront Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentLinkFrontMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentLinkFront mutation and return a FrontAttachmentPayload
     *
     * @param conversationId - required conversationId to pass to attachmentLinkFront
     * @param issueId - required issueId to pass to attachmentLinkFront
     * @returns parsed response from AttachmentLinkFrontMutation
     */
    fetch(conversationId: string, issueId: string): LinearFetch<FrontAttachmentPayload>;
}
/**
 * A fetchable AttachmentLinkIntercom Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentLinkIntercomMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentLinkIntercom mutation and return a AttachmentPayload
     *
     * @param conversationId - required conversationId to pass to attachmentLinkIntercom
     * @param issueId - required issueId to pass to attachmentLinkIntercom
     * @returns parsed response from AttachmentLinkIntercomMutation
     */
    fetch(conversationId: string, issueId: string): LinearFetch<AttachmentPayload>;
}
/**
 * A fetchable AttachmentLinkJiraIssue Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentLinkJiraIssueMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentLinkJiraIssue mutation and return a AttachmentPayload
     *
     * @param issueId - required issueId to pass to attachmentLinkJiraIssue
     * @param jiraIssueId - required jiraIssueId to pass to attachmentLinkJiraIssue
     * @returns parsed response from AttachmentLinkJiraIssueMutation
     */
    fetch(issueId: string, jiraIssueId: string): LinearFetch<AttachmentPayload>;
}
/**
 * A fetchable AttachmentLinkSlack Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentLinkSlackMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentLinkSlack mutation and return a AttachmentPayload
     *
     * @param channel - required channel to pass to attachmentLinkSlack
     * @param issueId - required issueId to pass to attachmentLinkSlack
     * @param latest - required latest to pass to attachmentLinkSlack
     * @param url - required url to pass to attachmentLinkSlack
     * @param variables - variables without 'channel', 'issueId', 'latest', 'url' to pass into the AttachmentLinkSlackMutation
     * @returns parsed response from AttachmentLinkSlackMutation
     */
    fetch(channel: string, issueId: string, latest: string, url: string, variables?: Omit<L.AttachmentLinkSlackMutationVariables, "channel" | "issueId" | "latest" | "url">): LinearFetch<AttachmentPayload>;
}
/**
 * A fetchable AttachmentLinkUrl Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentLinkUrlMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentLinkUrl mutation and return a AttachmentPayload
     *
     * @param issueId - required issueId to pass to attachmentLinkURL
     * @param url - required url to pass to attachmentLinkURL
     * @param variables - variables without 'issueId', 'url' to pass into the AttachmentLinkUrlMutation
     * @returns parsed response from AttachmentLinkUrlMutation
     */
    fetch(issueId: string, url: string, variables?: Omit<L.AttachmentLinkUrlMutationVariables, "issueId" | "url">): LinearFetch<AttachmentPayload>;
}
/**
 * A fetchable AttachmentLinkZendesk Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentLinkZendeskMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentLinkZendesk mutation and return a AttachmentPayload
     *
     * @param issueId - required issueId to pass to attachmentLinkZendesk
     * @param ticketId - required ticketId to pass to attachmentLinkZendesk
     * @returns parsed response from AttachmentLinkZendeskMutation
     */
    fetch(issueId: string, ticketId: string): LinearFetch<AttachmentPayload>;
}
/**
 * A fetchable AttachmentUnsyncSlack Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentUnsyncSlackMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentUnsyncSlack mutation and return a AttachmentPayload
     *
     * @param id - required id to pass to attachmentUnsyncSlack
     * @returns parsed response from AttachmentUnsyncSlackMutation
     */
    fetch(id: string): LinearFetch<AttachmentPayload>;
}
/**
 * A fetchable UpdateAttachment Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateAttachmentMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateAttachment mutation and return a AttachmentPayload
     *
     * @param id - required id to pass to updateAttachment
     * @param input - required input to pass to updateAttachment
     * @returns parsed response from UpdateAttachmentMutation
     */
    fetch(id: string, input: L.AttachmentUpdateInput): LinearFetch<AttachmentPayload>;
}
/**
 * A fetchable CreateComment Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateCommentMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateComment mutation and return a CommentPayload
     *
     * @param input - required input to pass to createComment
     * @returns parsed response from CreateCommentMutation
     */
    fetch(input: L.CommentCreateInput): LinearFetch<CommentPayload>;
}
/**
 * A fetchable DeleteComment Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteCommentMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteComment mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteComment
     * @returns parsed response from DeleteCommentMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable UpdateComment Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateCommentMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateComment mutation and return a CommentPayload
     *
     * @param id - required id to pass to updateComment
     * @param input - required input to pass to updateComment
     * @returns parsed response from UpdateCommentMutation
     */
    fetch(id: string, input: L.CommentUpdateInput): LinearFetch<CommentPayload>;
}
/**
 * A fetchable CreateContact Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateContactMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateContact mutation and return a ContactPayload
     *
     * @param input - required input to pass to createContact
     * @returns parsed response from CreateContactMutation
     */
    fetch(input: L.ContactCreateInput): LinearFetch<ContactPayload>;
}
/**
 * A fetchable CreateCsvExportReport Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateCsvExportReportMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateCsvExportReport mutation and return a CreateCsvExportReportPayload
     *
     * @param variables - variables to pass into the CreateCsvExportReportMutation
     * @returns parsed response from CreateCsvExportReportMutation
     */
    fetch(variables?: L.CreateCsvExportReportMutationVariables): LinearFetch<CreateCsvExportReportPayload>;
}
/**
 * A fetchable CreateOrganizationFromOnboarding Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateOrganizationFromOnboardingMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateOrganizationFromOnboarding mutation and return a CreateOrJoinOrganizationResponse
     *
     * @param input - required input to pass to createOrganizationFromOnboarding
     * @param variables - variables without 'input' to pass into the CreateOrganizationFromOnboardingMutation
     * @returns parsed response from CreateOrganizationFromOnboardingMutation
     */
    fetch(input: L.CreateOrganizationInput, variables?: Omit<L.CreateOrganizationFromOnboardingMutationVariables, "input">): LinearFetch<CreateOrJoinOrganizationResponse>;
}
/**
 * A fetchable CreateCustomView Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateCustomViewMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateCustomView mutation and return a CustomViewPayload
     *
     * @param input - required input to pass to createCustomView
     * @returns parsed response from CreateCustomViewMutation
     */
    fetch(input: L.CustomViewCreateInput): LinearFetch<CustomViewPayload>;
}
/**
 * A fetchable DeleteCustomView Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteCustomViewMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteCustomView mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteCustomView
     * @returns parsed response from DeleteCustomViewMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable UpdateCustomView Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateCustomViewMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateCustomView mutation and return a CustomViewPayload
     *
     * @param id - required id to pass to updateCustomView
     * @param input - required input to pass to updateCustomView
     * @returns parsed response from UpdateCustomViewMutation
     */
    fetch(id: string, input: L.CustomViewUpdateInput): LinearFetch<CustomViewPayload>;
}
/**
 * A fetchable ArchiveCycle Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ArchiveCycleMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ArchiveCycle mutation and return a CycleArchivePayload
     *
     * @param id - required id to pass to archiveCycle
     * @returns parsed response from ArchiveCycleMutation
     */
    fetch(id: string): LinearFetch<CycleArchivePayload>;
}
/**
 * A fetchable CreateCycle Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateCycleMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateCycle mutation and return a CyclePayload
     *
     * @param input - required input to pass to createCycle
     * @returns parsed response from CreateCycleMutation
     */
    fetch(input: L.CycleCreateInput): LinearFetch<CyclePayload>;
}
/**
 * A fetchable UpdateCycle Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateCycleMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateCycle mutation and return a CyclePayload
     *
     * @param id - required id to pass to updateCycle
     * @param input - required input to pass to updateCycle
     * @returns parsed response from UpdateCycleMutation
     */
    fetch(id: string, input: L.CycleUpdateInput): LinearFetch<CyclePayload>;
}
/**
 * A fetchable CreateDocument Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateDocumentMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateDocument mutation and return a DocumentPayload
     *
     * @param input - required input to pass to createDocument
     * @returns parsed response from CreateDocumentMutation
     */
    fetch(input: L.DocumentCreateInput): LinearFetch<DocumentPayload>;
}
/**
 * A fetchable DeleteDocument Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteDocumentMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteDocument mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteDocument
     * @returns parsed response from DeleteDocumentMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable UpdateDocument Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateDocumentMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateDocument mutation and return a DocumentPayload
     *
     * @param id - required id to pass to updateDocument
     * @param input - required input to pass to updateDocument
     * @returns parsed response from UpdateDocumentMutation
     */
    fetch(id: string, input: L.DocumentUpdateInput): LinearFetch<DocumentPayload>;
}
/**
 * A fetchable EmailTokenUserAccountAuth Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class EmailTokenUserAccountAuthMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the EmailTokenUserAccountAuth mutation and return a AuthResolverResponse
     *
     * @param input - required input to pass to emailTokenUserAccountAuth
     * @returns parsed response from EmailTokenUserAccountAuthMutation
     */
    fetch(input: L.TokenUserAccountAuthInput): LinearFetch<AuthResolverResponse>;
}
/**
 * A fetchable EmailUnsubscribe Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class EmailUnsubscribeMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the EmailUnsubscribe mutation and return a EmailUnsubscribePayload
     *
     * @param input - required input to pass to emailUnsubscribe
     * @returns parsed response from EmailUnsubscribeMutation
     */
    fetch(input: L.EmailUnsubscribeInput): LinearFetch<EmailUnsubscribePayload>;
}
/**
 * A fetchable EmailUserAccountAuthChallenge Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class EmailUserAccountAuthChallengeMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the EmailUserAccountAuthChallenge mutation and return a EmailUserAccountAuthChallengeResponse
     *
     * @param input - required input to pass to emailUserAccountAuthChallenge
     * @returns parsed response from EmailUserAccountAuthChallengeMutation
     */
    fetch(input: L.EmailUserAccountAuthChallengeInput): LinearFetch<EmailUserAccountAuthChallengeResponse>;
}
/**
 * A fetchable CreateEmoji Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateEmojiMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateEmoji mutation and return a EmojiPayload
     *
     * @param input - required input to pass to createEmoji
     * @returns parsed response from CreateEmojiMutation
     */
    fetch(input: L.EmojiCreateInput): LinearFetch<EmojiPayload>;
}
/**
 * A fetchable DeleteEmoji Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteEmojiMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteEmoji mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteEmoji
     * @returns parsed response from DeleteEmojiMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable CreateFavorite Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateFavoriteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateFavorite mutation and return a FavoritePayload
     *
     * @param input - required input to pass to createFavorite
     * @returns parsed response from CreateFavoriteMutation
     */
    fetch(input: L.FavoriteCreateInput): LinearFetch<FavoritePayload>;
}
/**
 * A fetchable DeleteFavorite Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteFavoriteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteFavorite mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteFavorite
     * @returns parsed response from DeleteFavoriteMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable UpdateFavorite Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateFavoriteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateFavorite mutation and return a FavoritePayload
     *
     * @param id - required id to pass to updateFavorite
     * @param input - required input to pass to updateFavorite
     * @returns parsed response from UpdateFavoriteMutation
     */
    fetch(id: string, input: L.FavoriteUpdateInput): LinearFetch<FavoritePayload>;
}
/**
 * A fetchable FileUpload Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class FileUploadMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the FileUpload mutation and return a UploadPayload
     *
     * @param contentType - required contentType to pass to fileUpload
     * @param filename - required filename to pass to fileUpload
     * @param size - required size to pass to fileUpload
     * @param variables - variables without 'contentType', 'filename', 'size' to pass into the FileUploadMutation
     * @returns parsed response from FileUploadMutation
     */
    fetch(contentType: string, filename: string, size: number, variables?: Omit<L.FileUploadMutationVariables, "contentType" | "filename" | "size">): LinearFetch<UploadPayload>;
}
/**
 * A fetchable GoogleUserAccountAuth Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class GoogleUserAccountAuthMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the GoogleUserAccountAuth mutation and return a AuthResolverResponse
     *
     * @param input - required input to pass to googleUserAccountAuth
     * @returns parsed response from GoogleUserAccountAuthMutation
     */
    fetch(input: L.GoogleUserAccountAuthInput): LinearFetch<AuthResolverResponse>;
}
/**
 * A fetchable ImageUploadFromUrl Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ImageUploadFromUrlMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ImageUploadFromUrl mutation and return a ImageUploadFromUrlPayload
     *
     * @param url - required url to pass to imageUploadFromUrl
     * @returns parsed response from ImageUploadFromUrlMutation
     */
    fetch(url: string): LinearFetch<ImageUploadFromUrlPayload>;
}
/**
 * A fetchable ImportFileUpload Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ImportFileUploadMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ImportFileUpload mutation and return a UploadPayload
     *
     * @param contentType - required contentType to pass to importFileUpload
     * @param filename - required filename to pass to importFileUpload
     * @param size - required size to pass to importFileUpload
     * @param variables - variables without 'contentType', 'filename', 'size' to pass into the ImportFileUploadMutation
     * @returns parsed response from ImportFileUploadMutation
     */
    fetch(contentType: string, filename: string, size: number, variables?: Omit<L.ImportFileUploadMutationVariables, "contentType" | "filename" | "size">): LinearFetch<UploadPayload>;
}
/**
 * A fetchable DeleteIntegration Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteIntegrationMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteIntegration mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteIntegration
     * @returns parsed response from DeleteIntegrationMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable IntegrationDiscord Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationDiscordMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationDiscord mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationDiscord
     * @param redirectUri - required redirectUri to pass to integrationDiscord
     * @returns parsed response from IntegrationDiscordMutation
     */
    fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationFigma Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationFigmaMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationFigma mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationFigma
     * @param redirectUri - required redirectUri to pass to integrationFigma
     * @returns parsed response from IntegrationFigmaMutation
     */
    fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationFront Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationFrontMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationFront mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationFront
     * @param redirectUri - required redirectUri to pass to integrationFront
     * @returns parsed response from IntegrationFrontMutation
     */
    fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable CreateIntegrationGithubCommit Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateIntegrationGithubCommitMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateIntegrationGithubCommit mutation and return a GitHubCommitIntegrationPayload
     *
     * @returns parsed response from CreateIntegrationGithubCommitMutation
     */
    fetch(): LinearFetch<GitHubCommitIntegrationPayload>;
}
/**
 * A fetchable IntegrationGithubConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationGithubConnectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationGithubConnect mutation and return a IntegrationPayload
     *
     * @param installationId - required installationId to pass to integrationGithubConnect
     * @returns parsed response from IntegrationGithubConnectMutation
     */
    fetch(installationId: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationGitlabConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationGitlabConnectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationGitlabConnect mutation and return a IntegrationPayload
     *
     * @param accessToken - required accessToken to pass to integrationGitlabConnect
     * @param gitlabUrl - required gitlabUrl to pass to integrationGitlabConnect
     * @returns parsed response from IntegrationGitlabConnectMutation
     */
    fetch(accessToken: string, gitlabUrl: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationGoogleSheets Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationGoogleSheetsMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationGoogleSheets mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationGoogleSheets
     * @returns parsed response from IntegrationGoogleSheetsMutation
     */
    fetch(code: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationIntercom Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationIntercomMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationIntercom mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationIntercom
     * @param redirectUri - required redirectUri to pass to integrationIntercom
     * @param variables - variables without 'code', 'redirectUri' to pass into the IntegrationIntercomMutation
     * @returns parsed response from IntegrationIntercomMutation
     */
    fetch(code: string, redirectUri: string, variables?: Omit<L.IntegrationIntercomMutationVariables, "code" | "redirectUri">): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable DeleteIntegrationIntercom Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteIntegrationIntercomMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteIntegrationIntercom mutation and return a IntegrationPayload
     *
     * @returns parsed response from DeleteIntegrationIntercomMutation
     */
    fetch(): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable UpdateIntegrationIntercomSettings Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateIntegrationIntercomSettingsMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateIntegrationIntercomSettings mutation and return a IntegrationPayload
     *
     * @param input - required input to pass to updateIntegrationIntercomSettings
     * @returns parsed response from UpdateIntegrationIntercomSettingsMutation
     */
    fetch(input: L.IntercomSettingsInput): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationLoom Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationLoomMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationLoom mutation and return a IntegrationPayload
     *
     * @returns parsed response from IntegrationLoomMutation
     */
    fetch(): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationRequest Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationRequestMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationRequest mutation and return a IntegrationRequestPayload
     *
     * @param input - required input to pass to integrationRequest
     * @returns parsed response from IntegrationRequestMutation
     */
    fetch(input: L.IntegrationRequestInput): LinearFetch<IntegrationRequestPayload>;
}
/**
 * A fetchable IntegrationSentryConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationSentryConnectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationSentryConnect mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationSentryConnect
     * @param installationId - required installationId to pass to integrationSentryConnect
     * @param organizationSlug - required organizationSlug to pass to integrationSentryConnect
     * @returns parsed response from IntegrationSentryConnectMutation
     */
    fetch(code: string, installationId: string, organizationSlug: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationSlack Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationSlackMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationSlack mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationSlack
     * @param redirectUri - required redirectUri to pass to integrationSlack
     * @param variables - variables without 'code', 'redirectUri' to pass into the IntegrationSlackMutation
     * @returns parsed response from IntegrationSlackMutation
     */
    fetch(code: string, redirectUri: string, variables?: Omit<L.IntegrationSlackMutationVariables, "code" | "redirectUri">): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationSlackAsks Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationSlackAsksMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationSlackAsks mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationSlackAsks
     * @param redirectUri - required redirectUri to pass to integrationSlackAsks
     * @returns parsed response from IntegrationSlackAsksMutation
     */
    fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationSlackImportEmojis Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationSlackImportEmojisMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationSlackImportEmojis mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationSlackImportEmojis
     * @param redirectUri - required redirectUri to pass to integrationSlackImportEmojis
     * @returns parsed response from IntegrationSlackImportEmojisMutation
     */
    fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationSlackOrgProjectUpdatesPost Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationSlackOrgProjectUpdatesPostMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationSlackOrgProjectUpdatesPost mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationSlackOrgProjectUpdatesPost
     * @param redirectUri - required redirectUri to pass to integrationSlackOrgProjectUpdatesPost
     * @returns parsed response from IntegrationSlackOrgProjectUpdatesPostMutation
     */
    fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationSlackPersonal Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationSlackPersonalMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationSlackPersonal mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationSlackPersonal
     * @param redirectUri - required redirectUri to pass to integrationSlackPersonal
     * @returns parsed response from IntegrationSlackPersonalMutation
     */
    fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationSlackPost Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationSlackPostMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationSlackPost mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationSlackPost
     * @param redirectUri - required redirectUri to pass to integrationSlackPost
     * @param teamId - required teamId to pass to integrationSlackPost
     * @param variables - variables without 'code', 'redirectUri', 'teamId' to pass into the IntegrationSlackPostMutation
     * @returns parsed response from IntegrationSlackPostMutation
     */
    fetch(code: string, redirectUri: string, teamId: string, variables?: Omit<L.IntegrationSlackPostMutationVariables, "code" | "redirectUri" | "teamId">): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationSlackProjectPost Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationSlackProjectPostMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationSlackProjectPost mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationSlackProjectPost
     * @param projectId - required projectId to pass to integrationSlackProjectPost
     * @param redirectUri - required redirectUri to pass to integrationSlackProjectPost
     * @param service - required service to pass to integrationSlackProjectPost
     * @returns parsed response from IntegrationSlackProjectPostMutation
     */
    fetch(code: string, projectId: string, redirectUri: string, service: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable CreateIntegrationTemplate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateIntegrationTemplateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateIntegrationTemplate mutation and return a IntegrationTemplatePayload
     *
     * @param input - required input to pass to createIntegrationTemplate
     * @returns parsed response from CreateIntegrationTemplateMutation
     */
    fetch(input: L.IntegrationTemplateCreateInput): LinearFetch<IntegrationTemplatePayload>;
}
/**
 * A fetchable DeleteIntegrationTemplate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteIntegrationTemplateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteIntegrationTemplate mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteIntegrationTemplate
     * @returns parsed response from DeleteIntegrationTemplateMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable IntegrationUpdateSlack Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationUpdateSlackMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationUpdateSlack mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationUpdateSlack
     * @param redirectUri - required redirectUri to pass to integrationUpdateSlack
     * @returns parsed response from IntegrationUpdateSlackMutation
     */
    fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable IntegrationZendesk Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationZendeskMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationZendesk mutation and return a IntegrationPayload
     *
     * @param code - required code to pass to integrationZendesk
     * @param redirectUri - required redirectUri to pass to integrationZendesk
     * @param scope - required scope to pass to integrationZendesk
     * @param subdomain - required subdomain to pass to integrationZendesk
     * @returns parsed response from IntegrationZendeskMutation
     */
    fetch(code: string, redirectUri: string, scope: string, subdomain: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable CreateIntegrationsSettings Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateIntegrationsSettingsMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateIntegrationsSettings mutation and return a IntegrationsSettingsPayload
     *
     * @param input - required input to pass to createIntegrationsSettings
     * @returns parsed response from CreateIntegrationsSettingsMutation
     */
    fetch(input: L.IntegrationsSettingsCreateInput): LinearFetch<IntegrationsSettingsPayload>;
}
/**
 * A fetchable UpdateIntegrationsSettings Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateIntegrationsSettingsMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateIntegrationsSettings mutation and return a IntegrationsSettingsPayload
     *
     * @param id - required id to pass to updateIntegrationsSettings
     * @param input - required input to pass to updateIntegrationsSettings
     * @returns parsed response from UpdateIntegrationsSettingsMutation
     */
    fetch(id: string, input: L.IntegrationsSettingsUpdateInput): LinearFetch<IntegrationsSettingsPayload>;
}
/**
 * A fetchable ArchiveIssue Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ArchiveIssueMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ArchiveIssue mutation and return a IssueArchivePayload
     *
     * @param id - required id to pass to archiveIssue
     * @param variables - variables without 'id' to pass into the ArchiveIssueMutation
     * @returns parsed response from ArchiveIssueMutation
     */
    fetch(id: string, variables?: Omit<L.ArchiveIssueMutationVariables, "id">): LinearFetch<IssueArchivePayload>;
}
/**
 * A fetchable UpdateIssueBatch Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateIssueBatchMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateIssueBatch mutation and return a IssueBatchPayload
     *
     * @param ids - required ids to pass to updateIssueBatch
     * @param input - required input to pass to updateIssueBatch
     * @returns parsed response from UpdateIssueBatchMutation
     */
    fetch(ids: L.Scalars["UUID"][], input: L.IssueUpdateInput): LinearFetch<IssueBatchPayload>;
}
/**
 * A fetchable CreateIssue Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateIssueMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateIssue mutation and return a IssuePayload
     *
     * @param input - required input to pass to createIssue
     * @returns parsed response from CreateIssueMutation
     */
    fetch(input: L.IssueCreateInput): LinearFetch<IssuePayload>;
}
/**
 * A fetchable DeleteIssue Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteIssueMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteIssue mutation and return a IssueArchivePayload
     *
     * @param id - required id to pass to deleteIssue
     * @returns parsed response from DeleteIssueMutation
     */
    fetch(id: string): LinearFetch<IssueArchivePayload>;
}
/**
 * A fetchable IssueImportCreateAsana Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueImportCreateAsanaMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueImportCreateAsana mutation and return a IssueImportPayload
     *
     * @param asanaTeamName - required asanaTeamName to pass to issueImportCreateAsana
     * @param asanaToken - required asanaToken to pass to issueImportCreateAsana
     * @param variables - variables without 'asanaTeamName', 'asanaToken' to pass into the IssueImportCreateAsanaMutation
     * @returns parsed response from IssueImportCreateAsanaMutation
     */
    fetch(asanaTeamName: string, asanaToken: string, variables?: Omit<L.IssueImportCreateAsanaMutationVariables, "asanaTeamName" | "asanaToken">): LinearFetch<IssueImportPayload>;
}
/**
 * A fetchable IssueImportCreateCsvJira Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueImportCreateCsvJiraMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueImportCreateCsvJira mutation and return a IssueImportPayload
     *
     * @param csvUrl - required csvUrl to pass to issueImportCreateCSVJira
     * @param variables - variables without 'csvUrl' to pass into the IssueImportCreateCsvJiraMutation
     * @returns parsed response from IssueImportCreateCsvJiraMutation
     */
    fetch(csvUrl: string, variables?: Omit<L.IssueImportCreateCsvJiraMutationVariables, "csvUrl">): LinearFetch<IssueImportPayload>;
}
/**
 * A fetchable IssueImportCreateClubhouse Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueImportCreateClubhouseMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueImportCreateClubhouse mutation and return a IssueImportPayload
     *
     * @param clubhouseGroupName - required clubhouseGroupName to pass to issueImportCreateClubhouse
     * @param clubhouseToken - required clubhouseToken to pass to issueImportCreateClubhouse
     * @param variables - variables without 'clubhouseGroupName', 'clubhouseToken' to pass into the IssueImportCreateClubhouseMutation
     * @returns parsed response from IssueImportCreateClubhouseMutation
     */
    fetch(clubhouseGroupName: string, clubhouseToken: string, variables?: Omit<L.IssueImportCreateClubhouseMutationVariables, "clubhouseGroupName" | "clubhouseToken">): LinearFetch<IssueImportPayload>;
}
/**
 * A fetchable IssueImportCreateGithub Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueImportCreateGithubMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueImportCreateGithub mutation and return a IssueImportPayload
     *
     * @param githubRepoName - required githubRepoName to pass to issueImportCreateGithub
     * @param githubRepoOwner - required githubRepoOwner to pass to issueImportCreateGithub
     * @param githubToken - required githubToken to pass to issueImportCreateGithub
     * @param variables - variables without 'githubRepoName', 'githubRepoOwner', 'githubToken' to pass into the IssueImportCreateGithubMutation
     * @returns parsed response from IssueImportCreateGithubMutation
     */
    fetch(githubRepoName: string, githubRepoOwner: string, githubToken: string, variables?: Omit<L.IssueImportCreateGithubMutationVariables, "githubRepoName" | "githubRepoOwner" | "githubToken">): LinearFetch<IssueImportPayload>;
}
/**
 * A fetchable IssueImportCreateJira Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueImportCreateJiraMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueImportCreateJira mutation and return a IssueImportPayload
     *
     * @param jiraEmail - required jiraEmail to pass to issueImportCreateJira
     * @param jiraHostname - required jiraHostname to pass to issueImportCreateJira
     * @param jiraProject - required jiraProject to pass to issueImportCreateJira
     * @param jiraToken - required jiraToken to pass to issueImportCreateJira
     * @param variables - variables without 'jiraEmail', 'jiraHostname', 'jiraProject', 'jiraToken' to pass into the IssueImportCreateJiraMutation
     * @returns parsed response from IssueImportCreateJiraMutation
     */
    fetch(jiraEmail: string, jiraHostname: string, jiraProject: string, jiraToken: string, variables?: Omit<L.IssueImportCreateJiraMutationVariables, "jiraEmail" | "jiraHostname" | "jiraProject" | "jiraToken">): LinearFetch<IssueImportPayload>;
}
/**
 * A fetchable DeleteIssueImport Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteIssueImportMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteIssueImport mutation and return a IssueImportDeletePayload
     *
     * @param issueImportId - required issueImportId to pass to deleteIssueImport
     * @returns parsed response from DeleteIssueImportMutation
     */
    fetch(issueImportId: string): LinearFetch<IssueImportDeletePayload>;
}
/**
 * A fetchable IssueImportProcess Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueImportProcessMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueImportProcess mutation and return a IssueImportPayload
     *
     * @param issueImportId - required issueImportId to pass to issueImportProcess
     * @param mapping - required mapping to pass to issueImportProcess
     * @returns parsed response from IssueImportProcessMutation
     */
    fetch(issueImportId: string, mapping: Record<string, unknown>): LinearFetch<IssueImportPayload>;
}
/**
 * A fetchable UpdateIssueImport Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateIssueImportMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateIssueImport mutation and return a IssueImportPayload
     *
     * @param id - required id to pass to updateIssueImport
     * @param input - required input to pass to updateIssueImport
     * @returns parsed response from UpdateIssueImportMutation
     */
    fetch(id: string, input: L.IssueImportUpdateInput): LinearFetch<IssueImportPayload>;
}
/**
 * A fetchable CreateIssueLabel Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateIssueLabelMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateIssueLabel mutation and return a IssueLabelPayload
     *
     * @param input - required input to pass to createIssueLabel
     * @param variables - variables without 'input' to pass into the CreateIssueLabelMutation
     * @returns parsed response from CreateIssueLabelMutation
     */
    fetch(input: L.IssueLabelCreateInput, variables?: Omit<L.CreateIssueLabelMutationVariables, "input">): LinearFetch<IssueLabelPayload>;
}
/**
 * A fetchable DeleteIssueLabel Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteIssueLabelMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteIssueLabel mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteIssueLabel
     * @returns parsed response from DeleteIssueLabelMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable UpdateIssueLabel Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateIssueLabelMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateIssueLabel mutation and return a IssueLabelPayload
     *
     * @param id - required id to pass to updateIssueLabel
     * @param input - required input to pass to updateIssueLabel
     * @returns parsed response from UpdateIssueLabelMutation
     */
    fetch(id: string, input: L.IssueLabelUpdateInput): LinearFetch<IssueLabelPayload>;
}
/**
 * A fetchable CreateIssueRelation Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateIssueRelationMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateIssueRelation mutation and return a IssueRelationPayload
     *
     * @param input - required input to pass to createIssueRelation
     * @returns parsed response from CreateIssueRelationMutation
     */
    fetch(input: L.IssueRelationCreateInput): LinearFetch<IssueRelationPayload>;
}
/**
 * A fetchable DeleteIssueRelation Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteIssueRelationMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteIssueRelation mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteIssueRelation
     * @returns parsed response from DeleteIssueRelationMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable UpdateIssueRelation Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateIssueRelationMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateIssueRelation mutation and return a IssueRelationPayload
     *
     * @param id - required id to pass to updateIssueRelation
     * @param input - required input to pass to updateIssueRelation
     * @returns parsed response from UpdateIssueRelationMutation
     */
    fetch(id: string, input: L.IssueRelationUpdateInput): LinearFetch<IssueRelationPayload>;
}
/**
 * A fetchable IssueReminder Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class IssueReminderMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueReminder mutation and return a IssuePayload
     *
     * @param id - required id to pass to issueReminder
     * @param reminderAt - required reminderAt to pass to issueReminder
     * @returns parsed response from IssueReminderMutation
     */
    fetch(id: string, reminderAt: Date): LinearFetch<IssuePayload>;
}
/**
 * A fetchable UnarchiveIssue Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UnarchiveIssueMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UnarchiveIssue mutation and return a IssueArchivePayload
     *
     * @param id - required id to pass to unarchiveIssue
     * @returns parsed response from UnarchiveIssueMutation
     */
    fetch(id: string): LinearFetch<IssueArchivePayload>;
}
/**
 * A fetchable UpdateIssue Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateIssueMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateIssue mutation and return a IssuePayload
     *
     * @param id - required id to pass to updateIssue
     * @param input - required input to pass to updateIssue
     * @returns parsed response from UpdateIssueMutation
     */
    fetch(id: string, input: L.IssueUpdateInput): LinearFetch<IssuePayload>;
}
/**
 * A fetchable JoinOrganizationFromOnboarding Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class JoinOrganizationFromOnboardingMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the JoinOrganizationFromOnboarding mutation and return a CreateOrJoinOrganizationResponse
     *
     * @param input - required input to pass to joinOrganizationFromOnboarding
     * @returns parsed response from JoinOrganizationFromOnboardingMutation
     */
    fetch(input: L.JoinOrganizationInput): LinearFetch<CreateOrJoinOrganizationResponse>;
}
/**
 * A fetchable LeaveOrganization Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class LeaveOrganizationMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the LeaveOrganization mutation and return a CreateOrJoinOrganizationResponse
     *
     * @param organizationId - required organizationId to pass to leaveOrganization
     * @returns parsed response from LeaveOrganizationMutation
     */
    fetch(organizationId: string): LinearFetch<CreateOrJoinOrganizationResponse>;
}
/**
 * A fetchable Logout Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class LogoutMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Logout mutation and return a LogoutResponse
     *
     * @returns parsed response from LogoutMutation
     */
    fetch(): LinearFetch<LogoutResponse>;
}
/**
 * A fetchable ArchiveNotification Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ArchiveNotificationMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ArchiveNotification mutation and return a NotificationArchivePayload
     *
     * @param id - required id to pass to archiveNotification
     * @returns parsed response from ArchiveNotificationMutation
     */
    fetch(id: string): LinearFetch<NotificationArchivePayload>;
}
/**
 * A fetchable NotificationArchiveAll Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationArchiveAllMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the NotificationArchiveAll mutation and return a NotificationBatchActionPayload
     *
     * @param input - required input to pass to notificationArchiveAll
     * @returns parsed response from NotificationArchiveAllMutation
     */
    fetch(input: L.NotificationEntityInput): LinearFetch<NotificationBatchActionPayload>;
}
/**
 * A fetchable NotificationMarkReadAll Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationMarkReadAllMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the NotificationMarkReadAll mutation and return a NotificationBatchActionPayload
     *
     * @param input - required input to pass to notificationMarkReadAll
     * @param readAt - required readAt to pass to notificationMarkReadAll
     * @returns parsed response from NotificationMarkReadAllMutation
     */
    fetch(input: L.NotificationEntityInput, readAt: Date): LinearFetch<NotificationBatchActionPayload>;
}
/**
 * A fetchable NotificationMarkUnreadAll Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationMarkUnreadAllMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the NotificationMarkUnreadAll mutation and return a NotificationBatchActionPayload
     *
     * @param input - required input to pass to notificationMarkUnreadAll
     * @returns parsed response from NotificationMarkUnreadAllMutation
     */
    fetch(input: L.NotificationEntityInput): LinearFetch<NotificationBatchActionPayload>;
}
/**
 * A fetchable NotificationSnoozeAll Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationSnoozeAllMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the NotificationSnoozeAll mutation and return a NotificationBatchActionPayload
     *
     * @param input - required input to pass to notificationSnoozeAll
     * @param snoozedUntilAt - required snoozedUntilAt to pass to notificationSnoozeAll
     * @returns parsed response from NotificationSnoozeAllMutation
     */
    fetch(input: L.NotificationEntityInput, snoozedUntilAt: Date): LinearFetch<NotificationBatchActionPayload>;
}
/**
 * A fetchable CreateNotificationSubscription Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateNotificationSubscriptionMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateNotificationSubscription mutation and return a NotificationSubscriptionPayload
     *
     * @param input - required input to pass to createNotificationSubscription
     * @returns parsed response from CreateNotificationSubscriptionMutation
     */
    fetch(input: L.NotificationSubscriptionCreateInput): LinearFetch<NotificationSubscriptionPayload>;
}
/**
 * A fetchable DeleteNotificationSubscription Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteNotificationSubscriptionMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteNotificationSubscription mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteNotificationSubscription
     * @returns parsed response from DeleteNotificationSubscriptionMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable UpdateNotificationSubscription Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateNotificationSubscriptionMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateNotificationSubscription mutation and return a NotificationSubscriptionPayload
     *
     * @param id - required id to pass to updateNotificationSubscription
     * @param input - required input to pass to updateNotificationSubscription
     * @returns parsed response from UpdateNotificationSubscriptionMutation
     */
    fetch(id: string, input: L.NotificationSubscriptionUpdateInput): LinearFetch<NotificationSubscriptionPayload>;
}
/**
 * A fetchable UnarchiveNotification Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UnarchiveNotificationMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UnarchiveNotification mutation and return a NotificationArchivePayload
     *
     * @param id - required id to pass to unarchiveNotification
     * @returns parsed response from UnarchiveNotificationMutation
     */
    fetch(id: string): LinearFetch<NotificationArchivePayload>;
}
/**
 * A fetchable NotificationUnsnoozeAll Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationUnsnoozeAllMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the NotificationUnsnoozeAll mutation and return a NotificationBatchActionPayload
     *
     * @param input - required input to pass to notificationUnsnoozeAll
     * @param unsnoozedAt - required unsnoozedAt to pass to notificationUnsnoozeAll
     * @returns parsed response from NotificationUnsnoozeAllMutation
     */
    fetch(input: L.NotificationEntityInput, unsnoozedAt: Date): LinearFetch<NotificationBatchActionPayload>;
}
/**
 * A fetchable UpdateNotification Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateNotificationMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateNotification mutation and return a NotificationPayload
     *
     * @param id - required id to pass to updateNotification
     * @param input - required input to pass to updateNotification
     * @returns parsed response from UpdateNotificationMutation
     */
    fetch(id: string, input: L.NotificationUpdateInput): LinearFetch<NotificationPayload>;
}
/**
 * A fetchable DeleteOrganizationCancel Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteOrganizationCancelMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteOrganizationCancel mutation and return a OrganizationCancelDeletePayload
     *
     * @returns parsed response from DeleteOrganizationCancelMutation
     */
    fetch(): LinearFetch<OrganizationCancelDeletePayload>;
}
/**
 * A fetchable DeleteOrganization Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteOrganizationMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteOrganization mutation and return a OrganizationDeletePayload
     *
     * @param input - required input to pass to deleteOrganization
     * @returns parsed response from DeleteOrganizationMutation
     */
    fetch(input: L.DeleteOrganizationInput): LinearFetch<OrganizationDeletePayload>;
}
/**
 * A fetchable OrganizationDeleteChallenge Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationDeleteChallengeMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationDeleteChallenge mutation and return a OrganizationDeletePayload
     *
     * @returns parsed response from OrganizationDeleteChallengeMutation
     */
    fetch(): LinearFetch<OrganizationDeletePayload>;
}
/**
 * A fetchable DeleteOrganizationDomain Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteOrganizationDomainMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteOrganizationDomain mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteOrganizationDomain
     * @returns parsed response from DeleteOrganizationDomainMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable CreateOrganizationInvite Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateOrganizationInviteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateOrganizationInvite mutation and return a OrganizationInvitePayload
     *
     * @param input - required input to pass to createOrganizationInvite
     * @returns parsed response from CreateOrganizationInviteMutation
     */
    fetch(input: L.OrganizationInviteCreateInput): LinearFetch<OrganizationInvitePayload>;
}
/**
 * A fetchable DeleteOrganizationInvite Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteOrganizationInviteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteOrganizationInvite mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteOrganizationInvite
     * @returns parsed response from DeleteOrganizationInviteMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable UpdateOrganizationInvite Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateOrganizationInviteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateOrganizationInvite mutation and return a OrganizationInvitePayload
     *
     * @param id - required id to pass to updateOrganizationInvite
     * @param input - required input to pass to updateOrganizationInvite
     * @returns parsed response from UpdateOrganizationInviteMutation
     */
    fetch(id: string, input: L.OrganizationInviteUpdateInput): LinearFetch<OrganizationInvitePayload>;
}
/**
 * A fetchable OrganizationStartPlusTrial Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationStartPlusTrialMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationStartPlusTrial mutation and return a OrganizationStartPlusTrialPayload
     *
     * @returns parsed response from OrganizationStartPlusTrialMutation
     */
    fetch(): LinearFetch<OrganizationStartPlusTrialPayload>;
}
/**
 * A fetchable UpdateOrganization Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateOrganizationMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateOrganization mutation and return a OrganizationPayload
     *
     * @param input - required input to pass to updateOrganization
     * @returns parsed response from UpdateOrganizationMutation
     */
    fetch(input: L.UpdateOrganizationInput): LinearFetch<OrganizationPayload>;
}
/**
 * A fetchable ArchiveProject Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ArchiveProjectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ArchiveProject mutation and return a ProjectArchivePayload
     *
     * @param id - required id to pass to archiveProject
     * @returns parsed response from ArchiveProjectMutation
     */
    fetch(id: string): LinearFetch<ProjectArchivePayload>;
}
/**
 * A fetchable CreateProject Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateProjectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateProject mutation and return a ProjectPayload
     *
     * @param input - required input to pass to createProject
     * @returns parsed response from CreateProjectMutation
     */
    fetch(input: L.ProjectCreateInput): LinearFetch<ProjectPayload>;
}
/**
 * A fetchable DeleteProject Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteProjectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteProject mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteProject
     * @returns parsed response from DeleteProjectMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable CreateProjectLink Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateProjectLinkMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateProjectLink mutation and return a ProjectLinkPayload
     *
     * @param input - required input to pass to createProjectLink
     * @returns parsed response from CreateProjectLinkMutation
     */
    fetch(input: L.ProjectLinkCreateInput): LinearFetch<ProjectLinkPayload>;
}
/**
 * A fetchable DeleteProjectLink Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteProjectLinkMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteProjectLink mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteProjectLink
     * @returns parsed response from DeleteProjectLinkMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable UpdateProjectLink Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateProjectLinkMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateProjectLink mutation and return a ProjectLinkPayload
     *
     * @param id - required id to pass to updateProjectLink
     * @param input - required input to pass to updateProjectLink
     * @returns parsed response from UpdateProjectLinkMutation
     */
    fetch(id: string, input: L.ProjectLinkUpdateInput): LinearFetch<ProjectLinkPayload>;
}
/**
 * A fetchable CreateProjectMilestone Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateProjectMilestoneMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateProjectMilestone mutation and return a ProjectMilestonePayload
     *
     * @param input - required input to pass to createProjectMilestone
     * @returns parsed response from CreateProjectMilestoneMutation
     */
    fetch(input: L.ProjectMilestoneCreateInput): LinearFetch<ProjectMilestonePayload>;
}
/**
 * A fetchable DeleteProjectMilestone Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteProjectMilestoneMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteProjectMilestone mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteProjectMilestone
     * @returns parsed response from DeleteProjectMilestoneMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable UpdateProjectMilestone Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateProjectMilestoneMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateProjectMilestone mutation and return a ProjectMilestonePayload
     *
     * @param id - required id to pass to updateProjectMilestone
     * @param input - required input to pass to updateProjectMilestone
     * @returns parsed response from UpdateProjectMilestoneMutation
     */
    fetch(id: string, input: L.ProjectMilestoneUpdateInput): LinearFetch<ProjectMilestonePayload>;
}
/**
 * A fetchable UnarchiveProject Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UnarchiveProjectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UnarchiveProject mutation and return a ProjectArchivePayload
     *
     * @param id - required id to pass to unarchiveProject
     * @returns parsed response from UnarchiveProjectMutation
     */
    fetch(id: string): LinearFetch<ProjectArchivePayload>;
}
/**
 * A fetchable UpdateProject Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateProjectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateProject mutation and return a ProjectPayload
     *
     * @param id - required id to pass to updateProject
     * @param input - required input to pass to updateProject
     * @returns parsed response from UpdateProjectMutation
     */
    fetch(id: string, input: L.ProjectUpdateInput): LinearFetch<ProjectPayload>;
}
/**
 * A fetchable CreateProjectUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateProjectUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateProjectUpdate mutation and return a ProjectUpdatePayload
     *
     * @param input - required input to pass to createProjectUpdate
     * @returns parsed response from CreateProjectUpdateMutation
     */
    fetch(input: L.ProjectUpdateCreateInput): LinearFetch<ProjectUpdatePayload>;
}
/**
 * A fetchable DeleteProjectUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteProjectUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteProjectUpdate mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteProjectUpdate
     * @returns parsed response from DeleteProjectUpdateMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable CreateProjectUpdateInteraction Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateProjectUpdateInteractionMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateProjectUpdateInteraction mutation and return a ProjectUpdateInteractionPayload
     *
     * @param input - required input to pass to createProjectUpdateInteraction
     * @returns parsed response from CreateProjectUpdateInteractionMutation
     */
    fetch(input: L.ProjectUpdateInteractionCreateInput): LinearFetch<ProjectUpdateInteractionPayload>;
}
/**
 * A fetchable ProjectUpdateMarkAsRead Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectUpdateMarkAsReadMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectUpdateMarkAsRead mutation and return a ProjectUpdateWithInteractionPayload
     *
     * @param id - required id to pass to projectUpdateMarkAsRead
     * @returns parsed response from ProjectUpdateMarkAsReadMutation
     */
    fetch(id: string): LinearFetch<ProjectUpdateWithInteractionPayload>;
}
/**
 * A fetchable UpdateProjectUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateProjectUpdateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateProjectUpdate mutation and return a ProjectUpdatePayload
     *
     * @param id - required id to pass to updateProjectUpdate
     * @param input - required input to pass to updateProjectUpdate
     * @returns parsed response from UpdateProjectUpdateMutation
     */
    fetch(id: string, input: L.ProjectUpdateUpdateInput): LinearFetch<ProjectUpdatePayload>;
}
/**
 * A fetchable CreatePushSubscription Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreatePushSubscriptionMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreatePushSubscription mutation and return a PushSubscriptionPayload
     *
     * @param input - required input to pass to createPushSubscription
     * @returns parsed response from CreatePushSubscriptionMutation
     */
    fetch(input: L.PushSubscriptionCreateInput): LinearFetch<PushSubscriptionPayload>;
}
/**
 * A fetchable DeletePushSubscription Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeletePushSubscriptionMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeletePushSubscription mutation and return a PushSubscriptionPayload
     *
     * @param id - required id to pass to deletePushSubscription
     * @returns parsed response from DeletePushSubscriptionMutation
     */
    fetch(id: string): LinearFetch<PushSubscriptionPayload>;
}
/**
 * A fetchable CreateReaction Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateReactionMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateReaction mutation and return a ReactionPayload
     *
     * @param input - required input to pass to createReaction
     * @returns parsed response from CreateReactionMutation
     */
    fetch(input: L.ReactionCreateInput): LinearFetch<ReactionPayload>;
}
/**
 * A fetchable DeleteReaction Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteReactionMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteReaction mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteReaction
     * @returns parsed response from DeleteReactionMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable RefreshGoogleSheetsData Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class RefreshGoogleSheetsDataMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the RefreshGoogleSheetsData mutation and return a IntegrationPayload
     *
     * @param id - required id to pass to refreshGoogleSheetsData
     * @returns parsed response from RefreshGoogleSheetsDataMutation
     */
    fetch(id: string): LinearFetch<IntegrationPayload>;
}
/**
 * A fetchable ResendOrganizationInvite Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ResendOrganizationInviteMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ResendOrganizationInvite mutation and return a DeletePayload
     *
     * @param id - required id to pass to resendOrganizationInvite
     * @returns parsed response from ResendOrganizationInviteMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable ArchiveRoadmap Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ArchiveRoadmapMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ArchiveRoadmap mutation and return a RoadmapArchivePayload
     *
     * @param id - required id to pass to archiveRoadmap
     * @returns parsed response from ArchiveRoadmapMutation
     */
    fetch(id: string): LinearFetch<RoadmapArchivePayload>;
}
/**
 * A fetchable CreateRoadmap Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateRoadmapMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateRoadmap mutation and return a RoadmapPayload
     *
     * @param input - required input to pass to createRoadmap
     * @returns parsed response from CreateRoadmapMutation
     */
    fetch(input: L.RoadmapCreateInput): LinearFetch<RoadmapPayload>;
}
/**
 * A fetchable DeleteRoadmap Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteRoadmapMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteRoadmap mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteRoadmap
     * @returns parsed response from DeleteRoadmapMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable CreateRoadmapToProject Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateRoadmapToProjectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateRoadmapToProject mutation and return a RoadmapToProjectPayload
     *
     * @param input - required input to pass to createRoadmapToProject
     * @returns parsed response from CreateRoadmapToProjectMutation
     */
    fetch(input: L.RoadmapToProjectCreateInput): LinearFetch<RoadmapToProjectPayload>;
}
/**
 * A fetchable DeleteRoadmapToProject Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteRoadmapToProjectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteRoadmapToProject mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteRoadmapToProject
     * @returns parsed response from DeleteRoadmapToProjectMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable UpdateRoadmapToProject Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateRoadmapToProjectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateRoadmapToProject mutation and return a RoadmapToProjectPayload
     *
     * @param id - required id to pass to updateRoadmapToProject
     * @param input - required input to pass to updateRoadmapToProject
     * @returns parsed response from UpdateRoadmapToProjectMutation
     */
    fetch(id: string, input: L.RoadmapToProjectUpdateInput): LinearFetch<RoadmapToProjectPayload>;
}
/**
 * A fetchable UnarchiveRoadmap Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UnarchiveRoadmapMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UnarchiveRoadmap mutation and return a RoadmapArchivePayload
     *
     * @param id - required id to pass to unarchiveRoadmap
     * @returns parsed response from UnarchiveRoadmapMutation
     */
    fetch(id: string): LinearFetch<RoadmapArchivePayload>;
}
/**
 * A fetchable UpdateRoadmap Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateRoadmapMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateRoadmap mutation and return a RoadmapPayload
     *
     * @param id - required id to pass to updateRoadmap
     * @param input - required input to pass to updateRoadmap
     * @returns parsed response from UpdateRoadmapMutation
     */
    fetch(id: string, input: L.RoadmapUpdateInput): LinearFetch<RoadmapPayload>;
}
/**
 * A fetchable SamlTokenUserAccountAuth Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class SamlTokenUserAccountAuthMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the SamlTokenUserAccountAuth mutation and return a AuthResolverResponse
     *
     * @param input - required input to pass to samlTokenUserAccountAuth
     * @returns parsed response from SamlTokenUserAccountAuthMutation
     */
    fetch(input: L.TokenUserAccountAuthInput): LinearFetch<AuthResolverResponse>;
}
/**
 * A fetchable CreateTeam Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateTeamMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateTeam mutation and return a TeamPayload
     *
     * @param input - required input to pass to createTeam
     * @param variables - variables without 'input' to pass into the CreateTeamMutation
     * @returns parsed response from CreateTeamMutation
     */
    fetch(input: L.TeamCreateInput, variables?: Omit<L.CreateTeamMutationVariables, "input">): LinearFetch<TeamPayload>;
}
/**
 * A fetchable DeleteTeamCycles Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteTeamCyclesMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteTeamCycles mutation and return a TeamPayload
     *
     * @param id - required id to pass to deleteTeamCycles
     * @returns parsed response from DeleteTeamCyclesMutation
     */
    fetch(id: string): LinearFetch<TeamPayload>;
}
/**
 * A fetchable DeleteTeam Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteTeamMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteTeam mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteTeam
     * @returns parsed response from DeleteTeamMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable DeleteTeamKey Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteTeamKeyMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteTeamKey mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteTeamKey
     * @returns parsed response from DeleteTeamKeyMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable CreateTeamMembership Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateTeamMembershipMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateTeamMembership mutation and return a TeamMembershipPayload
     *
     * @param input - required input to pass to createTeamMembership
     * @returns parsed response from CreateTeamMembershipMutation
     */
    fetch(input: L.TeamMembershipCreateInput): LinearFetch<TeamMembershipPayload>;
}
/**
 * A fetchable DeleteTeamMembership Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteTeamMembershipMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteTeamMembership mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteTeamMembership
     * @returns parsed response from DeleteTeamMembershipMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable UpdateTeamMembership Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateTeamMembershipMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateTeamMembership mutation and return a TeamMembershipPayload
     *
     * @param id - required id to pass to updateTeamMembership
     * @param input - required input to pass to updateTeamMembership
     * @returns parsed response from UpdateTeamMembershipMutation
     */
    fetch(id: string, input: L.TeamMembershipUpdateInput): LinearFetch<TeamMembershipPayload>;
}
/**
 * A fetchable UpdateTeam Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateTeamMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateTeam mutation and return a TeamPayload
     *
     * @param id - required id to pass to updateTeam
     * @param input - required input to pass to updateTeam
     * @returns parsed response from UpdateTeamMutation
     */
    fetch(id: string, input: L.TeamUpdateInput): LinearFetch<TeamPayload>;
}
/**
 * A fetchable CreateTemplate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateTemplateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateTemplate mutation and return a TemplatePayload
     *
     * @param input - required input to pass to createTemplate
     * @returns parsed response from CreateTemplateMutation
     */
    fetch(input: L.TemplateCreateInput): LinearFetch<TemplatePayload>;
}
/**
 * A fetchable DeleteTemplate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteTemplateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteTemplate mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteTemplate
     * @returns parsed response from DeleteTemplateMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable UpdateTemplate Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateTemplateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateTemplate mutation and return a TemplatePayload
     *
     * @param id - required id to pass to updateTemplate
     * @param input - required input to pass to updateTemplate
     * @returns parsed response from UpdateTemplateMutation
     */
    fetch(id: string, input: L.TemplateUpdateInput): LinearFetch<TemplatePayload>;
}
/**
 * A fetchable UserDemoteAdmin Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserDemoteAdminMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserDemoteAdmin mutation and return a UserAdminPayload
     *
     * @param id - required id to pass to userDemoteAdmin
     * @returns parsed response from UserDemoteAdminMutation
     */
    fetch(id: string): LinearFetch<UserAdminPayload>;
}
/**
 * A fetchable UserDemoteMember Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserDemoteMemberMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserDemoteMember mutation and return a UserAdminPayload
     *
     * @param id - required id to pass to userDemoteMember
     * @returns parsed response from UserDemoteMemberMutation
     */
    fetch(id: string): LinearFetch<UserAdminPayload>;
}
/**
 * A fetchable UserDiscordConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserDiscordConnectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserDiscordConnect mutation and return a UserPayload
     *
     * @param code - required code to pass to userDiscordConnect
     * @param redirectUri - required redirectUri to pass to userDiscordConnect
     * @returns parsed response from UserDiscordConnectMutation
     */
    fetch(code: string, redirectUri: string): LinearFetch<UserPayload>;
}
/**
 * A fetchable UserExternalUserDisconnect Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserExternalUserDisconnectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserExternalUserDisconnect mutation and return a UserPayload
     *
     * @param service - required service to pass to userExternalUserDisconnect
     * @returns parsed response from UserExternalUserDisconnectMutation
     */
    fetch(service: string): LinearFetch<UserPayload>;
}
/**
 * A fetchable UpdateUserFlag Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateUserFlagMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateUserFlag mutation and return a UserSettingsFlagPayload
     *
     * @param flag - required flag to pass to updateUserFlag
     * @param operation - required operation to pass to updateUserFlag
     * @returns parsed response from UpdateUserFlagMutation
     */
    fetch(flag: L.UserFlagType, operation: L.UserFlagUpdateOperation): LinearFetch<UserSettingsFlagPayload>;
}
/**
 * A fetchable UserGitHubConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserGitHubConnectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserGitHubConnect mutation and return a UserPayload
     *
     * @param code - required code to pass to userGitHubConnect
     * @returns parsed response from UserGitHubConnectMutation
     */
    fetch(code: string): LinearFetch<UserPayload>;
}
/**
 * A fetchable UserGoogleCalendarConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserGoogleCalendarConnectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserGoogleCalendarConnect mutation and return a UserPayload
     *
     * @param code - required code to pass to userGoogleCalendarConnect
     * @returns parsed response from UserGoogleCalendarConnectMutation
     */
    fetch(code: string): LinearFetch<UserPayload>;
}
/**
 * A fetchable UserJiraConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserJiraConnectMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserJiraConnect mutation and return a UserPayload
     *
     * @param code - required code to pass to userJiraConnect
     * @returns parsed response from UserJiraConnectMutation
     */
    fetch(code: string): LinearFetch<UserPayload>;
}
/**
 * A fetchable UserPromoteAdmin Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserPromoteAdminMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserPromoteAdmin mutation and return a UserAdminPayload
     *
     * @param id - required id to pass to userPromoteAdmin
     * @returns parsed response from UserPromoteAdminMutation
     */
    fetch(id: string): LinearFetch<UserAdminPayload>;
}
/**
 * A fetchable UserPromoteMember Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserPromoteMemberMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserPromoteMember mutation and return a UserAdminPayload
     *
     * @param id - required id to pass to userPromoteMember
     * @returns parsed response from UserPromoteMemberMutation
     */
    fetch(id: string): LinearFetch<UserAdminPayload>;
}
/**
 * A fetchable UserSettingsFlagIncrement Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserSettingsFlagIncrementMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserSettingsFlagIncrement mutation and return a UserSettingsFlagPayload
     *
     * @param flag - required flag to pass to userSettingsFlagIncrement
     * @returns parsed response from UserSettingsFlagIncrementMutation
     */
    fetch(flag: string): LinearFetch<UserSettingsFlagPayload>;
}
/**
 * A fetchable UserSettingsFlagsReset Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UserSettingsFlagsResetMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserSettingsFlagsReset mutation and return a UserSettingsFlagsResetPayload
     *
     * @param variables - variables to pass into the UserSettingsFlagsResetMutation
     * @returns parsed response from UserSettingsFlagsResetMutation
     */
    fetch(variables?: L.UserSettingsFlagsResetMutationVariables): LinearFetch<UserSettingsFlagsResetPayload>;
}
/**
 * A fetchable UpdateUserSettings Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateUserSettingsMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateUserSettings mutation and return a UserSettingsPayload
     *
     * @param id - required id to pass to updateUserSettings
     * @param input - required input to pass to updateUserSettings
     * @returns parsed response from UpdateUserSettingsMutation
     */
    fetch(id: string, input: L.UserSettingsUpdateInput): LinearFetch<UserSettingsPayload>;
}
/**
 * A fetchable SuspendUser Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class SuspendUserMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the SuspendUser mutation and return a UserAdminPayload
     *
     * @param id - required id to pass to suspendUser
     * @returns parsed response from SuspendUserMutation
     */
    fetch(id: string): LinearFetch<UserAdminPayload>;
}
/**
 * A fetchable UnsuspendUser Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UnsuspendUserMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UnsuspendUser mutation and return a UserAdminPayload
     *
     * @param id - required id to pass to unsuspendUser
     * @returns parsed response from UnsuspendUserMutation
     */
    fetch(id: string): LinearFetch<UserAdminPayload>;
}
/**
 * A fetchable UpdateUser Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateUserMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateUser mutation and return a UserPayload
     *
     * @param id - required id to pass to updateUser
     * @param input - required input to pass to updateUser
     * @returns parsed response from UpdateUserMutation
     */
    fetch(id: string, input: L.UpdateUserInput): LinearFetch<UserPayload>;
}
/**
 * A fetchable CreateViewPreferences Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateViewPreferencesMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateViewPreferences mutation and return a ViewPreferencesPayload
     *
     * @param input - required input to pass to createViewPreferences
     * @returns parsed response from CreateViewPreferencesMutation
     */
    fetch(input: L.ViewPreferencesCreateInput): LinearFetch<ViewPreferencesPayload>;
}
/**
 * A fetchable DeleteViewPreferences Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteViewPreferencesMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteViewPreferences mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteViewPreferences
     * @returns parsed response from DeleteViewPreferencesMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable UpdateViewPreferences Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateViewPreferencesMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateViewPreferences mutation and return a ViewPreferencesPayload
     *
     * @param id - required id to pass to updateViewPreferences
     * @param input - required input to pass to updateViewPreferences
     * @returns parsed response from UpdateViewPreferencesMutation
     */
    fetch(id: string, input: L.ViewPreferencesUpdateInput): LinearFetch<ViewPreferencesPayload>;
}
/**
 * A fetchable CreateWebhook Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateWebhookMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateWebhook mutation and return a WebhookPayload
     *
     * @param input - required input to pass to createWebhook
     * @returns parsed response from CreateWebhookMutation
     */
    fetch(input: L.WebhookCreateInput): LinearFetch<WebhookPayload>;
}
/**
 * A fetchable DeleteWebhook Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class DeleteWebhookMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the DeleteWebhook mutation and return a DeletePayload
     *
     * @param id - required id to pass to deleteWebhook
     * @returns parsed response from DeleteWebhookMutation
     */
    fetch(id: string): LinearFetch<DeletePayload>;
}
/**
 * A fetchable UpdateWebhook Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateWebhookMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateWebhook mutation and return a WebhookPayload
     *
     * @param id - required id to pass to updateWebhook
     * @param input - required input to pass to updateWebhook
     * @returns parsed response from UpdateWebhookMutation
     */
    fetch(id: string, input: L.WebhookUpdateInput): LinearFetch<WebhookPayload>;
}
/**
 * A fetchable ArchiveWorkflowState Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class ArchiveWorkflowStateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ArchiveWorkflowState mutation and return a WorkflowStateArchivePayload
     *
     * @param id - required id to pass to archiveWorkflowState
     * @returns parsed response from ArchiveWorkflowStateMutation
     */
    fetch(id: string): LinearFetch<WorkflowStateArchivePayload>;
}
/**
 * A fetchable CreateWorkflowState Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class CreateWorkflowStateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CreateWorkflowState mutation and return a WorkflowStatePayload
     *
     * @param input - required input to pass to createWorkflowState
     * @returns parsed response from CreateWorkflowStateMutation
     */
    fetch(input: L.WorkflowStateCreateInput): LinearFetch<WorkflowStatePayload>;
}
/**
 * A fetchable UpdateWorkflowState Mutation
 *
 * @param request - function to call the graphql client
 */
export declare class UpdateWorkflowStateMutation extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UpdateWorkflowState mutation and return a WorkflowStatePayload
     *
     * @param id - required id to pass to updateWorkflowState
     * @param input - required input to pass to updateWorkflowState
     * @returns parsed response from UpdateWorkflowStateMutation
     */
    fetch(id: string, input: L.WorkflowStateUpdateInput): LinearFetch<WorkflowStatePayload>;
}
/**
 * A fetchable ProjectMilestone Query
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectMilestoneQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectMilestone query and return a ProjectMilestone
     *
     * @param id - required id to pass to ProjectMilestone
     * @returns parsed response from ProjectMilestoneQuery
     */
    fetch(id: string): LinearFetch<ProjectMilestone>;
}
/**
 * A fetchable ProjectMilestones Query
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectMilestonesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectMilestones query and return a ProjectMilestoneConnection
     *
     * @param variables - variables to pass into the ProjectMilestonesQuery
     * @returns parsed response from ProjectMilestonesQuery
     */
    fetch(variables?: L.ProjectMilestonesQueryVariables): LinearFetch<ProjectMilestoneConnection>;
}
/**
 * A fetchable AdministrableTeams Query
 *
 * @param request - function to call the graphql client
 */
export declare class AdministrableTeamsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AdministrableTeams query and return a TeamConnection
     *
     * @param variables - variables to pass into the AdministrableTeamsQuery
     * @returns parsed response from AdministrableTeamsQuery
     */
    fetch(variables?: L.AdministrableTeamsQueryVariables): LinearFetch<TeamConnection>;
}
/**
 * A fetchable ApiKeys Query
 *
 * @param request - function to call the graphql client
 */
export declare class ApiKeysQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ApiKeys query and return a ApiKeyConnection
     *
     * @param variables - variables to pass into the ApiKeysQuery
     * @returns parsed response from ApiKeysQuery
     */
    fetch(variables?: L.ApiKeysQueryVariables): LinearFetch<ApiKeyConnection>;
}
/**
 * A fetchable ApplicationInfo Query
 *
 * @param request - function to call the graphql client
 */
export declare class ApplicationInfoQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ApplicationInfo query and return a Application
     *
     * @param clientId - required clientId to pass to applicationInfo
     * @returns parsed response from ApplicationInfoQuery
     */
    fetch(clientId: string): LinearFetch<Application>;
}
/**
 * A fetchable ApplicationWithAuthorization Query
 *
 * @param request - function to call the graphql client
 */
export declare class ApplicationWithAuthorizationQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ApplicationWithAuthorization query and return a UserAuthorizedApplication
     *
     * @param clientId - required clientId to pass to applicationWithAuthorization
     * @param scope - required scope to pass to applicationWithAuthorization
     * @param variables - variables without 'clientId', 'scope' to pass into the ApplicationWithAuthorizationQuery
     * @returns parsed response from ApplicationWithAuthorizationQuery
     */
    fetch(clientId: string, scope: string[], variables?: Omit<L.ApplicationWithAuthorizationQueryVariables, "clientId" | "scope">): LinearFetch<UserAuthorizedApplication>;
}
/**
 * A fetchable Attachment Query
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Attachment query and return a Attachment
     *
     * @param id - required id to pass to attachment
     * @returns parsed response from AttachmentQuery
     */
    fetch(id: string): LinearFetch<Attachment>;
}
/**
 * A fetchable AttachmentIssue Query
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentIssueQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentIssue query and return a Issue
     *
     * @param id - required id to pass to attachmentIssue
     * @returns parsed response from AttachmentIssueQuery
     */
    fetch(id: string): LinearFetch<Issue>;
}
/**
 * A fetchable Attachments Query
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Attachments query and return a AttachmentConnection
     *
     * @param variables - variables to pass into the AttachmentsQuery
     * @returns parsed response from AttachmentsQuery
     */
    fetch(variables?: L.AttachmentsQueryVariables): LinearFetch<AttachmentConnection>;
}
/**
 * A fetchable AttachmentsForUrl Query
 *
 * @param request - function to call the graphql client
 */
export declare class AttachmentsForUrlQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AttachmentsForUrl query and return a AttachmentConnection
     *
     * @param url - required url to pass to attachmentsForURL
     * @param variables - variables without 'url' to pass into the AttachmentsForUrlQuery
     * @returns parsed response from AttachmentsForUrlQuery
     */
    fetch(url: string, variables?: Omit<L.AttachmentsForUrlQueryVariables, "url">): LinearFetch<AttachmentConnection>;
}
/**
 * A fetchable AuditEntries Query
 *
 * @param request - function to call the graphql client
 */
export declare class AuditEntriesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AuditEntries query and return a AuditEntryConnection
     *
     * @param variables - variables to pass into the AuditEntriesQuery
     * @returns parsed response from AuditEntriesQuery
     */
    fetch(variables?: L.AuditEntriesQueryVariables): LinearFetch<AuditEntryConnection>;
}
/**
 * A fetchable AuditEntryTypes Query
 *
 * @param request - function to call the graphql client
 */
export declare class AuditEntryTypesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AuditEntryTypes query and return a AuditEntryType list
     *
     * @returns parsed response from AuditEntryTypesQuery
     */
    fetch(): LinearFetch<AuditEntryType[]>;
}
/**
 * A fetchable AvailableUsers Query
 *
 * @param request - function to call the graphql client
 */
export declare class AvailableUsersQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the AvailableUsers query and return a AuthResolverResponse
     *
     * @returns parsed response from AvailableUsersQuery
     */
    fetch(): LinearFetch<AuthResolverResponse>;
}
/**
 * A fetchable Comment Query
 *
 * @param request - function to call the graphql client
 */
export declare class CommentQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Comment query and return a Comment
     *
     * @param id - required id to pass to comment
     * @returns parsed response from CommentQuery
     */
    fetch(id: string): LinearFetch<Comment>;
}
/**
 * A fetchable Comments Query
 *
 * @param request - function to call the graphql client
 */
export declare class CommentsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Comments query and return a CommentConnection
     *
     * @param variables - variables to pass into the CommentsQuery
     * @returns parsed response from CommentsQuery
     */
    fetch(variables?: L.CommentsQueryVariables): LinearFetch<CommentConnection>;
}
/**
 * A fetchable CustomView Query
 *
 * @param request - function to call the graphql client
 */
export declare class CustomViewQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CustomView query and return a CustomView
     *
     * @param id - required id to pass to customView
     * @returns parsed response from CustomViewQuery
     */
    fetch(id: string): LinearFetch<CustomView>;
}
/**
 * A fetchable CustomViews Query
 *
 * @param request - function to call the graphql client
 */
export declare class CustomViewsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the CustomViews query and return a CustomViewConnection
     *
     * @param variables - variables to pass into the CustomViewsQuery
     * @returns parsed response from CustomViewsQuery
     */
    fetch(variables?: L.CustomViewsQueryVariables): LinearFetch<CustomViewConnection>;
}
/**
 * A fetchable Cycle Query
 *
 * @param request - function to call the graphql client
 */
export declare class CycleQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Cycle query and return a Cycle
     *
     * @param id - required id to pass to cycle
     * @returns parsed response from CycleQuery
     */
    fetch(id: string): LinearFetch<Cycle>;
}
/**
 * A fetchable Cycles Query
 *
 * @param request - function to call the graphql client
 */
export declare class CyclesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Cycles query and return a CycleConnection
     *
     * @param variables - variables to pass into the CyclesQuery
     * @returns parsed response from CyclesQuery
     */
    fetch(variables?: L.CyclesQueryVariables): LinearFetch<CycleConnection>;
}
/**
 * A fetchable Document Query
 *
 * @param request - function to call the graphql client
 */
export declare class DocumentQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Document query and return a Document
     *
     * @param id - required id to pass to document
     * @returns parsed response from DocumentQuery
     */
    fetch(id: string): LinearFetch<Document>;
}
/**
 * A fetchable Documents Query
 *
 * @param request - function to call the graphql client
 */
export declare class DocumentsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Documents query and return a DocumentConnection
     *
     * @param variables - variables to pass into the DocumentsQuery
     * @returns parsed response from DocumentsQuery
     */
    fetch(variables?: L.DocumentsQueryVariables): LinearFetch<DocumentConnection>;
}
/**
 * A fetchable EmbedInfo Query
 *
 * @param request - function to call the graphql client
 */
export declare class EmbedInfoQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the EmbedInfo query and return a EmbedPayload
     *
     * @param url - required url to pass to embedInfo
     * @returns parsed response from EmbedInfoQuery
     */
    fetch(url: string): LinearFetch<EmbedPayload>;
}
/**
 * A fetchable Emoji Query
 *
 * @param request - function to call the graphql client
 */
export declare class EmojiQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Emoji query and return a Emoji
     *
     * @param id - required id to pass to emoji
     * @returns parsed response from EmojiQuery
     */
    fetch(id: string): LinearFetch<Emoji>;
}
/**
 * A fetchable Emojis Query
 *
 * @param request - function to call the graphql client
 */
export declare class EmojisQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Emojis query and return a EmojiConnection
     *
     * @param variables - variables to pass into the EmojisQuery
     * @returns parsed response from EmojisQuery
     */
    fetch(variables?: L.EmojisQueryVariables): LinearFetch<EmojiConnection>;
}
/**
 * A fetchable Favorite Query
 *
 * @param request - function to call the graphql client
 */
export declare class FavoriteQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Favorite query and return a Favorite
     *
     * @param id - required id to pass to favorite
     * @returns parsed response from FavoriteQuery
     */
    fetch(id: string): LinearFetch<Favorite>;
}
/**
 * A fetchable Favorites Query
 *
 * @param request - function to call the graphql client
 */
export declare class FavoritesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Favorites query and return a FavoriteConnection
     *
     * @param variables - variables to pass into the FavoritesQuery
     * @returns parsed response from FavoritesQuery
     */
    fetch(variables?: L.FavoritesQueryVariables): LinearFetch<FavoriteConnection>;
}
/**
 * A fetchable FigmaEmbedInfo Query
 *
 * @param request - function to call the graphql client
 */
export declare class FigmaEmbedInfoQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the FigmaEmbedInfo query and return a FigmaEmbedPayload
     *
     * @param fileId - required fileId to pass to figmaEmbedInfo
     * @param variables - variables without 'fileId' to pass into the FigmaEmbedInfoQuery
     * @returns parsed response from FigmaEmbedInfoQuery
     */
    fetch(fileId: string, variables?: Omit<L.FigmaEmbedInfoQueryVariables, "fileId">): LinearFetch<FigmaEmbedPayload>;
}
/**
 * A fetchable Integration Query
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Integration query and return a Integration
     *
     * @param id - required id to pass to integration
     * @returns parsed response from IntegrationQuery
     */
    fetch(id: string): LinearFetch<Integration>;
}
/**
 * A fetchable IntegrationTemplate Query
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationTemplateQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationTemplate query and return a IntegrationTemplate
     *
     * @param id - required id to pass to integrationTemplate
     * @returns parsed response from IntegrationTemplateQuery
     */
    fetch(id: string): LinearFetch<IntegrationTemplate>;
}
/**
 * A fetchable IntegrationTemplates Query
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationTemplatesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationTemplates query and return a IntegrationTemplateConnection
     *
     * @param variables - variables to pass into the IntegrationTemplatesQuery
     * @returns parsed response from IntegrationTemplatesQuery
     */
    fetch(variables?: L.IntegrationTemplatesQueryVariables): LinearFetch<IntegrationTemplateConnection>;
}
/**
 * A fetchable Integrations Query
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Integrations query and return a IntegrationConnection
     *
     * @param variables - variables to pass into the IntegrationsQuery
     * @returns parsed response from IntegrationsQuery
     */
    fetch(variables?: L.IntegrationsQueryVariables): LinearFetch<IntegrationConnection>;
}
/**
 * A fetchable IntegrationsSettings Query
 *
 * @param request - function to call the graphql client
 */
export declare class IntegrationsSettingsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IntegrationsSettings query and return a IntegrationsSettings
     *
     * @param id - required id to pass to integrationsSettings
     * @returns parsed response from IntegrationsSettingsQuery
     */
    fetch(id: string): LinearFetch<IntegrationsSettings>;
}
/**
 * A fetchable Issue Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Issue query and return a Issue
     *
     * @param id - required id to pass to issue
     * @returns parsed response from IssueQuery
     */
    fetch(id: string): LinearFetch<Issue>;
}
/**
 * A fetchable IssueFigmaFileKeySearch Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueFigmaFileKeySearchQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueFigmaFileKeySearch query and return a IssueConnection
     *
     * @param fileKey - required fileKey to pass to issueFigmaFileKeySearch
     * @param variables - variables without 'fileKey' to pass into the IssueFigmaFileKeySearchQuery
     * @returns parsed response from IssueFigmaFileKeySearchQuery
     */
    fetch(fileKey: string, variables?: Omit<L.IssueFigmaFileKeySearchQueryVariables, "fileKey">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable IssueFilterSuggestion Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueFilterSuggestionQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueFilterSuggestion query and return a IssueFilterSuggestionPayload
     *
     * @param prompt - required prompt to pass to issueFilterSuggestion
     * @returns parsed response from IssueFilterSuggestionQuery
     */
    fetch(prompt: string): LinearFetch<IssueFilterSuggestionPayload>;
}
/**
 * A fetchable IssueImportCheckCsv Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueImportCheckCsvQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueImportCheckCsv query and return a IssueImportCheckPayload
     *
     * @param csvUrl - required csvUrl to pass to issueImportCheckCSV
     * @param service - required service to pass to issueImportCheckCSV
     * @returns parsed response from IssueImportCheckCsvQuery
     */
    fetch(csvUrl: string, service: string): LinearFetch<IssueImportCheckPayload>;
}
/**
 * A fetchable IssueImportFinishGithubOAuth Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueImportFinishGithubOAuthQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueImportFinishGithubOAuth query and return a GithubOAuthTokenPayload
     *
     * @param code - required code to pass to issueImportFinishGithubOAuth
     * @returns parsed response from IssueImportFinishGithubOAuthQuery
     */
    fetch(code: string): LinearFetch<GithubOAuthTokenPayload>;
}
/**
 * A fetchable IssueLabel Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueLabelQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueLabel query and return a IssueLabel
     *
     * @param id - required id to pass to issueLabel
     * @returns parsed response from IssueLabelQuery
     */
    fetch(id: string): LinearFetch<IssueLabel>;
}
/**
 * A fetchable IssueLabels Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueLabelsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueLabels query and return a IssueLabelConnection
     *
     * @param variables - variables to pass into the IssueLabelsQuery
     * @returns parsed response from IssueLabelsQuery
     */
    fetch(variables?: L.IssueLabelsQueryVariables): LinearFetch<IssueLabelConnection>;
}
/**
 * A fetchable IssuePriorityValues Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssuePriorityValuesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssuePriorityValues query and return a IssuePriorityValue list
     *
     * @returns parsed response from IssuePriorityValuesQuery
     */
    fetch(): LinearFetch<IssuePriorityValue[]>;
}
/**
 * A fetchable IssueRelation Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueRelationQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueRelation query and return a IssueRelation
     *
     * @param id - required id to pass to issueRelation
     * @returns parsed response from IssueRelationQuery
     */
    fetch(id: string): LinearFetch<IssueRelation>;
}
/**
 * A fetchable IssueRelations Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueRelationsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueRelations query and return a IssueRelationConnection
     *
     * @param variables - variables to pass into the IssueRelationsQuery
     * @returns parsed response from IssueRelationsQuery
     */
    fetch(variables?: L.IssueRelationsQueryVariables): LinearFetch<IssueRelationConnection>;
}
/**
 * A fetchable IssueSearch Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueSearchQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueSearch query and return a IssueConnection
     *
     * @param variables - variables to pass into the IssueSearchQuery
     * @returns parsed response from IssueSearchQuery
     */
    fetch(variables?: L.IssueSearchQueryVariables): LinearFetch<IssueConnection>;
}
/**
 * A fetchable IssueVcsBranchSearch Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssueVcsBranchSearchQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the IssueVcsBranchSearch query and return a Issue
     *
     * @param branchName - required branchName to pass to issueVcsBranchSearch
     * @returns parsed response from IssueVcsBranchSearchQuery
     */
    fetch(branchName: string): LinearFetch<Issue | undefined>;
}
/**
 * A fetchable Issues Query
 *
 * @param request - function to call the graphql client
 */
export declare class IssuesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Issues query and return a IssueConnection
     *
     * @param variables - variables to pass into the IssuesQuery
     * @returns parsed response from IssuesQuery
     */
    fetch(variables?: L.IssuesQueryVariables): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Notification Query
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Notification query and return a Notification
     *
     * @param id - required id to pass to notification
     * @returns parsed response from NotificationQuery
     */
    fetch(id: string): LinearFetch<IssueNotification | OauthClientApprovalNotification | ProjectNotification | Notification>;
}
/**
 * A fetchable NotificationSubscription Query
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationSubscriptionQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the NotificationSubscription query and return a NotificationSubscription
     *
     * @param id - required id to pass to notificationSubscription
     * @returns parsed response from NotificationSubscriptionQuery
     */
    fetch(id: string): LinearFetch<CustomViewNotificationSubscription | CycleNotificationSubscription | LabelNotificationSubscription | ProjectNotificationSubscription | TeamNotificationSubscription | UserNotificationSubscription | NotificationSubscription>;
}
/**
 * A fetchable NotificationSubscriptions Query
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationSubscriptionsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the NotificationSubscriptions query and return a NotificationSubscriptionConnection
     *
     * @param variables - variables to pass into the NotificationSubscriptionsQuery
     * @returns parsed response from NotificationSubscriptionsQuery
     */
    fetch(variables?: L.NotificationSubscriptionsQueryVariables): LinearFetch<NotificationSubscriptionConnection>;
}
/**
 * A fetchable Notifications Query
 *
 * @param request - function to call the graphql client
 */
export declare class NotificationsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Notifications query and return a NotificationConnection
     *
     * @param variables - variables to pass into the NotificationsQuery
     * @returns parsed response from NotificationsQuery
     */
    fetch(variables?: L.NotificationsQueryVariables): LinearFetch<NotificationConnection>;
}
/**
 * A fetchable Organization Query
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Organization query and return a Organization
     *
     * @returns parsed response from OrganizationQuery
     */
    fetch(): LinearFetch<Organization>;
}
/**
 * A fetchable OrganizationExists Query
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationExistsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationExists query and return a OrganizationExistsPayload
     *
     * @param urlKey - required urlKey to pass to organizationExists
     * @returns parsed response from OrganizationExistsQuery
     */
    fetch(urlKey: string): LinearFetch<OrganizationExistsPayload>;
}
/**
 * A fetchable OrganizationInvite Query
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationInviteQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationInvite query and return a OrganizationInvite
     *
     * @param id - required id to pass to organizationInvite
     * @returns parsed response from OrganizationInviteQuery
     */
    fetch(id: string): LinearFetch<OrganizationInvite>;
}
/**
 * A fetchable OrganizationInvites Query
 *
 * @param request - function to call the graphql client
 */
export declare class OrganizationInvitesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the OrganizationInvites query and return a OrganizationInviteConnection
     *
     * @param variables - variables to pass into the OrganizationInvitesQuery
     * @returns parsed response from OrganizationInvitesQuery
     */
    fetch(variables?: L.OrganizationInvitesQueryVariables): LinearFetch<OrganizationInviteConnection>;
}
/**
 * A fetchable Project Query
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Project query and return a Project
     *
     * @param id - required id to pass to project
     * @returns parsed response from ProjectQuery
     */
    fetch(id: string): LinearFetch<Project>;
}
/**
 * A fetchable ProjectFilterSuggestion Query
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectFilterSuggestionQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectFilterSuggestion query and return a ProjectFilterSuggestionPayload
     *
     * @param prompt - required prompt to pass to projectFilterSuggestion
     * @returns parsed response from ProjectFilterSuggestionQuery
     */
    fetch(prompt: string): LinearFetch<ProjectFilterSuggestionPayload>;
}
/**
 * A fetchable ProjectLink Query
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectLinkQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectLink query and return a ProjectLink
     *
     * @param id - required id to pass to projectLink
     * @returns parsed response from ProjectLinkQuery
     */
    fetch(id: string): LinearFetch<ProjectLink>;
}
/**
 * A fetchable ProjectLinks Query
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectLinksQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectLinks query and return a ProjectLinkConnection
     *
     * @param variables - variables to pass into the ProjectLinksQuery
     * @returns parsed response from ProjectLinksQuery
     */
    fetch(variables?: L.ProjectLinksQueryVariables): LinearFetch<ProjectLinkConnection>;
}
/**
 * A fetchable ProjectUpdate Query
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectUpdateQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectUpdate query and return a ProjectUpdate
     *
     * @param id - required id to pass to projectUpdate
     * @returns parsed response from ProjectUpdateQuery
     */
    fetch(id: string): LinearFetch<ProjectUpdate>;
}
/**
 * A fetchable ProjectUpdateInteraction Query
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectUpdateInteractionQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectUpdateInteraction query and return a ProjectUpdateInteraction
     *
     * @param id - required id to pass to projectUpdateInteraction
     * @returns parsed response from ProjectUpdateInteractionQuery
     */
    fetch(id: string): LinearFetch<ProjectUpdateInteraction>;
}
/**
 * A fetchable ProjectUpdateInteractions Query
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectUpdateInteractionsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectUpdateInteractions query and return a ProjectUpdateInteractionConnection
     *
     * @param variables - variables to pass into the ProjectUpdateInteractionsQuery
     * @returns parsed response from ProjectUpdateInteractionsQuery
     */
    fetch(variables?: L.ProjectUpdateInteractionsQueryVariables): LinearFetch<ProjectUpdateInteractionConnection>;
}
/**
 * A fetchable ProjectUpdates Query
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectUpdatesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the ProjectUpdates query and return a ProjectUpdateConnection
     *
     * @param variables - variables to pass into the ProjectUpdatesQuery
     * @returns parsed response from ProjectUpdatesQuery
     */
    fetch(variables?: L.ProjectUpdatesQueryVariables): LinearFetch<ProjectUpdateConnection>;
}
/**
 * A fetchable Projects Query
 *
 * @param request - function to call the graphql client
 */
export declare class ProjectsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Projects query and return a ProjectConnection
     *
     * @param variables - variables to pass into the ProjectsQuery
     * @returns parsed response from ProjectsQuery
     */
    fetch(variables?: L.ProjectsQueryVariables): LinearFetch<ProjectConnection>;
}
/**
 * A fetchable PushSubscriptionTest Query
 *
 * @param request - function to call the graphql client
 */
export declare class PushSubscriptionTestQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the PushSubscriptionTest query and return a PushSubscriptionTestPayload
     *
     * @returns parsed response from PushSubscriptionTestQuery
     */
    fetch(): LinearFetch<PushSubscriptionTestPayload>;
}
/**
 * A fetchable RateLimitStatus Query
 *
 * @param request - function to call the graphql client
 */
export declare class RateLimitStatusQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the RateLimitStatus query and return a RateLimitPayload
     *
     * @returns parsed response from RateLimitStatusQuery
     */
    fetch(): LinearFetch<RateLimitPayload>;
}
/**
 * A fetchable Roadmap Query
 *
 * @param request - function to call the graphql client
 */
export declare class RoadmapQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Roadmap query and return a Roadmap
     *
     * @param id - required id to pass to roadmap
     * @returns parsed response from RoadmapQuery
     */
    fetch(id: string): LinearFetch<Roadmap>;
}
/**
 * A fetchable RoadmapToProject Query
 *
 * @param request - function to call the graphql client
 */
export declare class RoadmapToProjectQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the RoadmapToProject query and return a RoadmapToProject
     *
     * @param id - required id to pass to roadmapToProject
     * @returns parsed response from RoadmapToProjectQuery
     */
    fetch(id: string): LinearFetch<RoadmapToProject>;
}
/**
 * A fetchable RoadmapToProjects Query
 *
 * @param request - function to call the graphql client
 */
export declare class RoadmapToProjectsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the RoadmapToProjects query and return a RoadmapToProjectConnection
     *
     * @param variables - variables to pass into the RoadmapToProjectsQuery
     * @returns parsed response from RoadmapToProjectsQuery
     */
    fetch(variables?: L.RoadmapToProjectsQueryVariables): LinearFetch<RoadmapToProjectConnection>;
}
/**
 * A fetchable Roadmaps Query
 *
 * @param request - function to call the graphql client
 */
export declare class RoadmapsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Roadmaps query and return a RoadmapConnection
     *
     * @param variables - variables to pass into the RoadmapsQuery
     * @returns parsed response from RoadmapsQuery
     */
    fetch(variables?: L.RoadmapsQueryVariables): LinearFetch<RoadmapConnection>;
}
/**
 * A fetchable SearchDocuments Query
 *
 * @param request - function to call the graphql client
 */
export declare class SearchDocumentsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the SearchDocuments query and return a DocumentSearchPayload
     *
     * @param term - required term to pass to searchDocuments
     * @param variables - variables without 'term' to pass into the SearchDocumentsQuery
     * @returns parsed response from SearchDocumentsQuery
     */
    fetch(term: string, variables?: Omit<L.SearchDocumentsQueryVariables, "term">): LinearFetch<DocumentSearchPayload>;
}
/**
 * A fetchable SearchIssues Query
 *
 * @param request - function to call the graphql client
 */
export declare class SearchIssuesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the SearchIssues query and return a IssueSearchPayload
     *
     * @param term - required term to pass to searchIssues
     * @param variables - variables without 'term' to pass into the SearchIssuesQuery
     * @returns parsed response from SearchIssuesQuery
     */
    fetch(term: string, variables?: Omit<L.SearchIssuesQueryVariables, "term">): LinearFetch<IssueSearchPayload>;
}
/**
 * A fetchable SearchProjects Query
 *
 * @param request - function to call the graphql client
 */
export declare class SearchProjectsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the SearchProjects query and return a ProjectSearchPayload
     *
     * @param term - required term to pass to searchProjects
     * @param variables - variables without 'term' to pass into the SearchProjectsQuery
     * @returns parsed response from SearchProjectsQuery
     */
    fetch(term: string, variables?: Omit<L.SearchProjectsQueryVariables, "term">): LinearFetch<ProjectSearchPayload>;
}
/**
 * A fetchable SsoUrlFromEmail Query
 *
 * @param request - function to call the graphql client
 */
export declare class SsoUrlFromEmailQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the SsoUrlFromEmail query and return a SsoUrlFromEmailResponse
     *
     * @param email - required email to pass to ssoUrlFromEmail
     * @param variables - variables without 'email' to pass into the SsoUrlFromEmailQuery
     * @returns parsed response from SsoUrlFromEmailQuery
     */
    fetch(email: string, variables?: Omit<L.SsoUrlFromEmailQueryVariables, "email">): LinearFetch<SsoUrlFromEmailResponse>;
}
/**
 * A fetchable Team Query
 *
 * @param request - function to call the graphql client
 */
export declare class TeamQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Team query and return a Team
     *
     * @param id - required id to pass to team
     * @returns parsed response from TeamQuery
     */
    fetch(id: string): LinearFetch<Team>;
}
/**
 * A fetchable TeamMembership Query
 *
 * @param request - function to call the graphql client
 */
export declare class TeamMembershipQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the TeamMembership query and return a TeamMembership
     *
     * @param id - required id to pass to teamMembership
     * @returns parsed response from TeamMembershipQuery
     */
    fetch(id: string): LinearFetch<TeamMembership>;
}
/**
 * A fetchable TeamMemberships Query
 *
 * @param request - function to call the graphql client
 */
export declare class TeamMembershipsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the TeamMemberships query and return a TeamMembershipConnection
     *
     * @param variables - variables to pass into the TeamMembershipsQuery
     * @returns parsed response from TeamMembershipsQuery
     */
    fetch(variables?: L.TeamMembershipsQueryVariables): LinearFetch<TeamMembershipConnection>;
}
/**
 * A fetchable Teams Query
 *
 * @param request - function to call the graphql client
 */
export declare class TeamsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Teams query and return a TeamConnection
     *
     * @param variables - variables to pass into the TeamsQuery
     * @returns parsed response from TeamsQuery
     */
    fetch(variables?: L.TeamsQueryVariables): LinearFetch<TeamConnection>;
}
/**
 * A fetchable Template Query
 *
 * @param request - function to call the graphql client
 */
export declare class TemplateQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Template query and return a Template
     *
     * @param id - required id to pass to template
     * @returns parsed response from TemplateQuery
     */
    fetch(id: string): LinearFetch<Template>;
}
/**
 * A fetchable Templates Query
 *
 * @param request - function to call the graphql client
 */
export declare class TemplatesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Templates query and return a Template list
     *
     * @returns parsed response from TemplatesQuery
     */
    fetch(): LinearFetch<Template[]>;
}
/**
 * A fetchable TemplatesForIntegration Query
 *
 * @param request - function to call the graphql client
 */
export declare class TemplatesForIntegrationQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the TemplatesForIntegration query and return a Template list
     *
     * @param integrationType - required integrationType to pass to templatesForIntegration
     * @returns parsed response from TemplatesForIntegrationQuery
     */
    fetch(integrationType: string): LinearFetch<Template[]>;
}
/**
 * A fetchable User Query
 *
 * @param request - function to call the graphql client
 */
export declare class UserQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the User query and return a User
     *
     * @param id - required id to pass to user
     * @returns parsed response from UserQuery
     */
    fetch(id: string): LinearFetch<User>;
}
/**
 * A fetchable UserSettings Query
 *
 * @param request - function to call the graphql client
 */
export declare class UserSettingsQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the UserSettings query and return a UserSettings
     *
     * @returns parsed response from UserSettingsQuery
     */
    fetch(): LinearFetch<UserSettings>;
}
/**
 * A fetchable Users Query
 *
 * @param request - function to call the graphql client
 */
export declare class UsersQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Users query and return a UserConnection
     *
     * @param variables - variables to pass into the UsersQuery
     * @returns parsed response from UsersQuery
     */
    fetch(variables?: L.UsersQueryVariables): LinearFetch<UserConnection>;
}
/**
 * A fetchable Viewer Query
 *
 * @param request - function to call the graphql client
 */
export declare class ViewerQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Viewer query and return a User
     *
     * @returns parsed response from ViewerQuery
     */
    fetch(): LinearFetch<User>;
}
/**
 * A fetchable Webhook Query
 *
 * @param request - function to call the graphql client
 */
export declare class WebhookQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Webhook query and return a Webhook
     *
     * @param id - required id to pass to webhook
     * @returns parsed response from WebhookQuery
     */
    fetch(id: string): LinearFetch<Webhook>;
}
/**
 * A fetchable Webhooks Query
 *
 * @param request - function to call the graphql client
 */
export declare class WebhooksQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Webhooks query and return a WebhookConnection
     *
     * @param variables - variables to pass into the WebhooksQuery
     * @returns parsed response from WebhooksQuery
     */
    fetch(variables?: L.WebhooksQueryVariables): LinearFetch<WebhookConnection>;
}
/**
 * A fetchable WorkflowState Query
 *
 * @param request - function to call the graphql client
 */
export declare class WorkflowStateQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the WorkflowState query and return a WorkflowState
     *
     * @param id - required id to pass to workflowState
     * @returns parsed response from WorkflowStateQuery
     */
    fetch(id: string): LinearFetch<WorkflowState>;
}
/**
 * A fetchable WorkflowStates Query
 *
 * @param request - function to call the graphql client
 */
export declare class WorkflowStatesQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the WorkflowStates query and return a WorkflowStateConnection
     *
     * @param variables - variables to pass into the WorkflowStatesQuery
     * @returns parsed response from WorkflowStatesQuery
     */
    fetch(variables?: L.WorkflowStatesQueryVariables): LinearFetch<WorkflowStateConnection>;
}
/**
 * A fetchable AttachmentIssue_Attachments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_AttachmentsQuery
 */
export declare class AttachmentIssue_AttachmentsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.AttachmentIssue_AttachmentsQueryVariables, "id">);
    /**
     * Call the AttachmentIssue_Attachments query and return a AttachmentConnection
     *
     * @param variables - variables without 'id' to pass into the AttachmentIssue_AttachmentsQuery
     * @returns parsed response from AttachmentIssue_AttachmentsQuery
     */
    fetch(variables?: Omit<L.AttachmentIssue_AttachmentsQueryVariables, "id">): LinearFetch<AttachmentConnection>;
}
/**
 * A fetchable AttachmentIssue_Children Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_ChildrenQuery
 */
export declare class AttachmentIssue_ChildrenQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.AttachmentIssue_ChildrenQueryVariables, "id">);
    /**
     * Call the AttachmentIssue_Children query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the AttachmentIssue_ChildrenQuery
     * @returns parsed response from AttachmentIssue_ChildrenQuery
     */
    fetch(variables?: Omit<L.AttachmentIssue_ChildrenQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable AttachmentIssue_Comments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_CommentsQuery
 */
export declare class AttachmentIssue_CommentsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.AttachmentIssue_CommentsQueryVariables, "id">);
    /**
     * Call the AttachmentIssue_Comments query and return a CommentConnection
     *
     * @param variables - variables without 'id' to pass into the AttachmentIssue_CommentsQuery
     * @returns parsed response from AttachmentIssue_CommentsQuery
     */
    fetch(variables?: Omit<L.AttachmentIssue_CommentsQueryVariables, "id">): LinearFetch<CommentConnection>;
}
/**
 * A fetchable AttachmentIssue_History Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_HistoryQuery
 */
export declare class AttachmentIssue_HistoryQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.AttachmentIssue_HistoryQueryVariables, "id">);
    /**
     * Call the AttachmentIssue_History query and return a IssueHistoryConnection
     *
     * @param variables - variables without 'id' to pass into the AttachmentIssue_HistoryQuery
     * @returns parsed response from AttachmentIssue_HistoryQuery
     */
    fetch(variables?: Omit<L.AttachmentIssue_HistoryQueryVariables, "id">): LinearFetch<IssueHistoryConnection>;
}
/**
 * A fetchable AttachmentIssue_InverseRelations Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_InverseRelationsQuery
 */
export declare class AttachmentIssue_InverseRelationsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.AttachmentIssue_InverseRelationsQueryVariables, "id">);
    /**
     * Call the AttachmentIssue_InverseRelations query and return a IssueRelationConnection
     *
     * @param variables - variables without 'id' to pass into the AttachmentIssue_InverseRelationsQuery
     * @returns parsed response from AttachmentIssue_InverseRelationsQuery
     */
    fetch(variables?: Omit<L.AttachmentIssue_InverseRelationsQueryVariables, "id">): LinearFetch<IssueRelationConnection>;
}
/**
 * A fetchable AttachmentIssue_Labels Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_LabelsQuery
 */
export declare class AttachmentIssue_LabelsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.AttachmentIssue_LabelsQueryVariables, "id">);
    /**
     * Call the AttachmentIssue_Labels query and return a IssueLabelConnection
     *
     * @param variables - variables without 'id' to pass into the AttachmentIssue_LabelsQuery
     * @returns parsed response from AttachmentIssue_LabelsQuery
     */
    fetch(variables?: Omit<L.AttachmentIssue_LabelsQueryVariables, "id">): LinearFetch<IssueLabelConnection>;
}
/**
 * A fetchable AttachmentIssue_Relations Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_RelationsQuery
 */
export declare class AttachmentIssue_RelationsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.AttachmentIssue_RelationsQueryVariables, "id">);
    /**
     * Call the AttachmentIssue_Relations query and return a IssueRelationConnection
     *
     * @param variables - variables without 'id' to pass into the AttachmentIssue_RelationsQuery
     * @returns parsed response from AttachmentIssue_RelationsQuery
     */
    fetch(variables?: Omit<L.AttachmentIssue_RelationsQueryVariables, "id">): LinearFetch<IssueRelationConnection>;
}
/**
 * A fetchable AttachmentIssue_Subscribers Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_SubscribersQuery
 */
export declare class AttachmentIssue_SubscribersQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.AttachmentIssue_SubscribersQueryVariables, "id">);
    /**
     * Call the AttachmentIssue_Subscribers query and return a UserConnection
     *
     * @param variables - variables without 'id' to pass into the AttachmentIssue_SubscribersQuery
     * @returns parsed response from AttachmentIssue_SubscribersQuery
     */
    fetch(variables?: Omit<L.AttachmentIssue_SubscribersQueryVariables, "id">): LinearFetch<UserConnection>;
}
/**
 * A fetchable Comment_Children Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to comment
 * @param variables - variables without 'id' to pass into the Comment_ChildrenQuery
 */
export declare class Comment_ChildrenQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Comment_ChildrenQueryVariables, "id">);
    /**
     * Call the Comment_Children query and return a CommentConnection
     *
     * @param variables - variables without 'id' to pass into the Comment_ChildrenQuery
     * @returns parsed response from Comment_ChildrenQuery
     */
    fetch(variables?: Omit<L.Comment_ChildrenQueryVariables, "id">): LinearFetch<CommentConnection>;
}
/**
 * A fetchable Cycle_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to cycle
 * @param variables - variables without 'id' to pass into the Cycle_IssuesQuery
 */
export declare class Cycle_IssuesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Cycle_IssuesQueryVariables, "id">);
    /**
     * Call the Cycle_Issues query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the Cycle_IssuesQuery
     * @returns parsed response from Cycle_IssuesQuery
     */
    fetch(variables?: Omit<L.Cycle_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Cycle_UncompletedIssuesUponClose Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to cycle
 * @param variables - variables without 'id' to pass into the Cycle_UncompletedIssuesUponCloseQuery
 */
export declare class Cycle_UncompletedIssuesUponCloseQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Cycle_UncompletedIssuesUponCloseQueryVariables, "id">);
    /**
     * Call the Cycle_UncompletedIssuesUponClose query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the Cycle_UncompletedIssuesUponCloseQuery
     * @returns parsed response from Cycle_UncompletedIssuesUponCloseQuery
     */
    fetch(variables?: Omit<L.Cycle_UncompletedIssuesUponCloseQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable EmbedInfo_Embed Query
 *
 * @param request - function to call the graphql client
 * @param url - required url to pass to embedInfo
 */
export declare class EmbedInfo_EmbedQuery extends Request {
    private _url;
    constructor(request: LinearRequest, url: string);
    /**
     * Call the EmbedInfo_Embed query and return a Embed
     *
     * @returns parsed response from EmbedInfo_EmbedQuery
     */
    fetch(): LinearFetch<Embed | undefined>;
}
/**
 * A fetchable Favorite_Children Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to favorite
 * @param variables - variables without 'id' to pass into the Favorite_ChildrenQuery
 */
export declare class Favorite_ChildrenQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Favorite_ChildrenQueryVariables, "id">);
    /**
     * Call the Favorite_Children query and return a FavoriteConnection
     *
     * @param variables - variables without 'id' to pass into the Favorite_ChildrenQuery
     * @returns parsed response from Favorite_ChildrenQuery
     */
    fetch(variables?: Omit<L.Favorite_ChildrenQueryVariables, "id">): LinearFetch<FavoriteConnection>;
}
/**
 * A fetchable FigmaEmbedInfo_FigmaEmbed Query
 *
 * @param request - function to call the graphql client
 * @param fileId - required fileId to pass to figmaEmbedInfo
 * @param variables - variables without 'fileId' to pass into the FigmaEmbedInfo_FigmaEmbedQuery
 */
export declare class FigmaEmbedInfo_FigmaEmbedQuery extends Request {
    private _fileId;
    private _variables?;
    constructor(request: LinearRequest, fileId: string, variables?: Omit<L.FigmaEmbedInfo_FigmaEmbedQueryVariables, "fileId">);
    /**
     * Call the FigmaEmbedInfo_FigmaEmbed query and return a FigmaEmbed
     *
     * @param variables - variables without 'fileId' to pass into the FigmaEmbedInfo_FigmaEmbedQuery
     * @returns parsed response from FigmaEmbedInfo_FigmaEmbedQuery
     */
    fetch(variables?: Omit<L.FigmaEmbedInfo_FigmaEmbedQueryVariables, "fileId">): LinearFetch<FigmaEmbed | undefined>;
}
/**
 * A fetchable Issue_Attachments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_AttachmentsQuery
 */
export declare class Issue_AttachmentsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_AttachmentsQueryVariables, "id">);
    /**
     * Call the Issue_Attachments query and return a AttachmentConnection
     *
     * @param variables - variables without 'id' to pass into the Issue_AttachmentsQuery
     * @returns parsed response from Issue_AttachmentsQuery
     */
    fetch(variables?: Omit<L.Issue_AttachmentsQueryVariables, "id">): LinearFetch<AttachmentConnection>;
}
/**
 * A fetchable Issue_Children Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_ChildrenQuery
 */
export declare class Issue_ChildrenQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_ChildrenQueryVariables, "id">);
    /**
     * Call the Issue_Children query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the Issue_ChildrenQuery
     * @returns parsed response from Issue_ChildrenQuery
     */
    fetch(variables?: Omit<L.Issue_ChildrenQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Issue_Comments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_CommentsQuery
 */
export declare class Issue_CommentsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_CommentsQueryVariables, "id">);
    /**
     * Call the Issue_Comments query and return a CommentConnection
     *
     * @param variables - variables without 'id' to pass into the Issue_CommentsQuery
     * @returns parsed response from Issue_CommentsQuery
     */
    fetch(variables?: Omit<L.Issue_CommentsQueryVariables, "id">): LinearFetch<CommentConnection>;
}
/**
 * A fetchable Issue_History Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_HistoryQuery
 */
export declare class Issue_HistoryQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_HistoryQueryVariables, "id">);
    /**
     * Call the Issue_History query and return a IssueHistoryConnection
     *
     * @param variables - variables without 'id' to pass into the Issue_HistoryQuery
     * @returns parsed response from Issue_HistoryQuery
     */
    fetch(variables?: Omit<L.Issue_HistoryQueryVariables, "id">): LinearFetch<IssueHistoryConnection>;
}
/**
 * A fetchable Issue_InverseRelations Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_InverseRelationsQuery
 */
export declare class Issue_InverseRelationsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_InverseRelationsQueryVariables, "id">);
    /**
     * Call the Issue_InverseRelations query and return a IssueRelationConnection
     *
     * @param variables - variables without 'id' to pass into the Issue_InverseRelationsQuery
     * @returns parsed response from Issue_InverseRelationsQuery
     */
    fetch(variables?: Omit<L.Issue_InverseRelationsQueryVariables, "id">): LinearFetch<IssueRelationConnection>;
}
/**
 * A fetchable Issue_Labels Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_LabelsQuery
 */
export declare class Issue_LabelsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_LabelsQueryVariables, "id">);
    /**
     * Call the Issue_Labels query and return a IssueLabelConnection
     *
     * @param variables - variables without 'id' to pass into the Issue_LabelsQuery
     * @returns parsed response from Issue_LabelsQuery
     */
    fetch(variables?: Omit<L.Issue_LabelsQueryVariables, "id">): LinearFetch<IssueLabelConnection>;
}
/**
 * A fetchable Issue_Relations Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_RelationsQuery
 */
export declare class Issue_RelationsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_RelationsQueryVariables, "id">);
    /**
     * Call the Issue_Relations query and return a IssueRelationConnection
     *
     * @param variables - variables without 'id' to pass into the Issue_RelationsQuery
     * @returns parsed response from Issue_RelationsQuery
     */
    fetch(variables?: Omit<L.Issue_RelationsQueryVariables, "id">): LinearFetch<IssueRelationConnection>;
}
/**
 * A fetchable Issue_Subscribers Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_SubscribersQuery
 */
export declare class Issue_SubscribersQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_SubscribersQueryVariables, "id">);
    /**
     * Call the Issue_Subscribers query and return a UserConnection
     *
     * @param variables - variables without 'id' to pass into the Issue_SubscribersQuery
     * @returns parsed response from Issue_SubscribersQuery
     */
    fetch(variables?: Omit<L.Issue_SubscribersQueryVariables, "id">): LinearFetch<UserConnection>;
}
/**
 * A fetchable IssueLabel_Children Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issueLabel
 * @param variables - variables without 'id' to pass into the IssueLabel_ChildrenQuery
 */
export declare class IssueLabel_ChildrenQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.IssueLabel_ChildrenQueryVariables, "id">);
    /**
     * Call the IssueLabel_Children query and return a IssueLabelConnection
     *
     * @param variables - variables without 'id' to pass into the IssueLabel_ChildrenQuery
     * @returns parsed response from IssueLabel_ChildrenQuery
     */
    fetch(variables?: Omit<L.IssueLabel_ChildrenQueryVariables, "id">): LinearFetch<IssueLabelConnection>;
}
/**
 * A fetchable IssueLabel_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issueLabel
 * @param variables - variables without 'id' to pass into the IssueLabel_IssuesQuery
 */
export declare class IssueLabel_IssuesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.IssueLabel_IssuesQueryVariables, "id">);
    /**
     * Call the IssueLabel_Issues query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the IssueLabel_IssuesQuery
     * @returns parsed response from IssueLabel_IssuesQuery
     */
    fetch(variables?: Omit<L.IssueLabel_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable IssueVcsBranchSearch_Attachments Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_AttachmentsQuery
 */
export declare class IssueVcsBranchSearch_AttachmentsQuery extends Request {
    private _branchName;
    private _variables?;
    constructor(request: LinearRequest, branchName: string, variables?: Omit<L.IssueVcsBranchSearch_AttachmentsQueryVariables, "branchName">);
    /**
     * Call the IssueVcsBranchSearch_Attachments query and return a AttachmentConnection
     *
     * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_AttachmentsQuery
     * @returns parsed response from IssueVcsBranchSearch_AttachmentsQuery
     */
    fetch(variables?: Omit<L.IssueVcsBranchSearch_AttachmentsQueryVariables, "branchName">): LinearFetch<AttachmentConnection | undefined>;
}
/**
 * A fetchable IssueVcsBranchSearch_Children Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_ChildrenQuery
 */
export declare class IssueVcsBranchSearch_ChildrenQuery extends Request {
    private _branchName;
    private _variables?;
    constructor(request: LinearRequest, branchName: string, variables?: Omit<L.IssueVcsBranchSearch_ChildrenQueryVariables, "branchName">);
    /**
     * Call the IssueVcsBranchSearch_Children query and return a IssueConnection
     *
     * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_ChildrenQuery
     * @returns parsed response from IssueVcsBranchSearch_ChildrenQuery
     */
    fetch(variables?: Omit<L.IssueVcsBranchSearch_ChildrenQueryVariables, "branchName">): LinearFetch<IssueConnection | undefined>;
}
/**
 * A fetchable IssueVcsBranchSearch_Comments Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_CommentsQuery
 */
export declare class IssueVcsBranchSearch_CommentsQuery extends Request {
    private _branchName;
    private _variables?;
    constructor(request: LinearRequest, branchName: string, variables?: Omit<L.IssueVcsBranchSearch_CommentsQueryVariables, "branchName">);
    /**
     * Call the IssueVcsBranchSearch_Comments query and return a CommentConnection
     *
     * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_CommentsQuery
     * @returns parsed response from IssueVcsBranchSearch_CommentsQuery
     */
    fetch(variables?: Omit<L.IssueVcsBranchSearch_CommentsQueryVariables, "branchName">): LinearFetch<CommentConnection | undefined>;
}
/**
 * A fetchable IssueVcsBranchSearch_History Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_HistoryQuery
 */
export declare class IssueVcsBranchSearch_HistoryQuery extends Request {
    private _branchName;
    private _variables?;
    constructor(request: LinearRequest, branchName: string, variables?: Omit<L.IssueVcsBranchSearch_HistoryQueryVariables, "branchName">);
    /**
     * Call the IssueVcsBranchSearch_History query and return a IssueHistoryConnection
     *
     * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_HistoryQuery
     * @returns parsed response from IssueVcsBranchSearch_HistoryQuery
     */
    fetch(variables?: Omit<L.IssueVcsBranchSearch_HistoryQueryVariables, "branchName">): LinearFetch<IssueHistoryConnection | undefined>;
}
/**
 * A fetchable IssueVcsBranchSearch_InverseRelations Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_InverseRelationsQuery
 */
export declare class IssueVcsBranchSearch_InverseRelationsQuery extends Request {
    private _branchName;
    private _variables?;
    constructor(request: LinearRequest, branchName: string, variables?: Omit<L.IssueVcsBranchSearch_InverseRelationsQueryVariables, "branchName">);
    /**
     * Call the IssueVcsBranchSearch_InverseRelations query and return a IssueRelationConnection
     *
     * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_InverseRelationsQuery
     * @returns parsed response from IssueVcsBranchSearch_InverseRelationsQuery
     */
    fetch(variables?: Omit<L.IssueVcsBranchSearch_InverseRelationsQueryVariables, "branchName">): LinearFetch<IssueRelationConnection | undefined>;
}
/**
 * A fetchable IssueVcsBranchSearch_Labels Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_LabelsQuery
 */
export declare class IssueVcsBranchSearch_LabelsQuery extends Request {
    private _branchName;
    private _variables?;
    constructor(request: LinearRequest, branchName: string, variables?: Omit<L.IssueVcsBranchSearch_LabelsQueryVariables, "branchName">);
    /**
     * Call the IssueVcsBranchSearch_Labels query and return a IssueLabelConnection
     *
     * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_LabelsQuery
     * @returns parsed response from IssueVcsBranchSearch_LabelsQuery
     */
    fetch(variables?: Omit<L.IssueVcsBranchSearch_LabelsQueryVariables, "branchName">): LinearFetch<IssueLabelConnection | undefined>;
}
/**
 * A fetchable IssueVcsBranchSearch_Relations Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_RelationsQuery
 */
export declare class IssueVcsBranchSearch_RelationsQuery extends Request {
    private _branchName;
    private _variables?;
    constructor(request: LinearRequest, branchName: string, variables?: Omit<L.IssueVcsBranchSearch_RelationsQueryVariables, "branchName">);
    /**
     * Call the IssueVcsBranchSearch_Relations query and return a IssueRelationConnection
     *
     * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_RelationsQuery
     * @returns parsed response from IssueVcsBranchSearch_RelationsQuery
     */
    fetch(variables?: Omit<L.IssueVcsBranchSearch_RelationsQueryVariables, "branchName">): LinearFetch<IssueRelationConnection | undefined>;
}
/**
 * A fetchable IssueVcsBranchSearch_Subscribers Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_SubscribersQuery
 */
export declare class IssueVcsBranchSearch_SubscribersQuery extends Request {
    private _branchName;
    private _variables?;
    constructor(request: LinearRequest, branchName: string, variables?: Omit<L.IssueVcsBranchSearch_SubscribersQueryVariables, "branchName">);
    /**
     * Call the IssueVcsBranchSearch_Subscribers query and return a UserConnection
     *
     * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_SubscribersQuery
     * @returns parsed response from IssueVcsBranchSearch_SubscribersQuery
     */
    fetch(variables?: Omit<L.IssueVcsBranchSearch_SubscribersQueryVariables, "branchName">): LinearFetch<UserConnection | undefined>;
}
/**
 * A fetchable Organization_Integrations Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_IntegrationsQuery
 */
export declare class Organization_IntegrationsQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Organization_IntegrationsQueryVariables);
    /**
     * Call the Organization_Integrations query and return a IntegrationConnection
     *
     * @param variables - variables to pass into the Organization_IntegrationsQuery
     * @returns parsed response from Organization_IntegrationsQuery
     */
    fetch(variables?: L.Organization_IntegrationsQueryVariables): LinearFetch<IntegrationConnection>;
}
/**
 * A fetchable Organization_Labels Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_LabelsQuery
 */
export declare class Organization_LabelsQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Organization_LabelsQueryVariables);
    /**
     * Call the Organization_Labels query and return a IssueLabelConnection
     *
     * @param variables - variables to pass into the Organization_LabelsQuery
     * @returns parsed response from Organization_LabelsQuery
     */
    fetch(variables?: L.Organization_LabelsQueryVariables): LinearFetch<IssueLabelConnection>;
}
/**
 * A fetchable Organization_Subscription Query
 *
 * @param request - function to call the graphql client
 */
export declare class Organization_SubscriptionQuery extends Request {
    constructor(request: LinearRequest);
    /**
     * Call the Organization_Subscription query and return a PaidSubscription
     *
     * @returns parsed response from Organization_SubscriptionQuery
     */
    fetch(): LinearFetch<PaidSubscription | undefined>;
}
/**
 * A fetchable Organization_Teams Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_TeamsQuery
 */
export declare class Organization_TeamsQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Organization_TeamsQueryVariables);
    /**
     * Call the Organization_Teams query and return a TeamConnection
     *
     * @param variables - variables to pass into the Organization_TeamsQuery
     * @returns parsed response from Organization_TeamsQuery
     */
    fetch(variables?: L.Organization_TeamsQueryVariables): LinearFetch<TeamConnection>;
}
/**
 * A fetchable Organization_Templates Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_TemplatesQuery
 */
export declare class Organization_TemplatesQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Organization_TemplatesQueryVariables);
    /**
     * Call the Organization_Templates query and return a TemplateConnection
     *
     * @param variables - variables to pass into the Organization_TemplatesQuery
     * @returns parsed response from Organization_TemplatesQuery
     */
    fetch(variables?: L.Organization_TemplatesQueryVariables): LinearFetch<TemplateConnection>;
}
/**
 * A fetchable Organization_Users Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_UsersQuery
 */
export declare class Organization_UsersQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Organization_UsersQueryVariables);
    /**
     * Call the Organization_Users query and return a UserConnection
     *
     * @param variables - variables to pass into the Organization_UsersQuery
     * @returns parsed response from Organization_UsersQuery
     */
    fetch(variables?: L.Organization_UsersQueryVariables): LinearFetch<UserConnection>;
}
/**
 * A fetchable Project_Documents Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_DocumentsQuery
 */
export declare class Project_DocumentsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_DocumentsQueryVariables, "id">);
    /**
     * Call the Project_Documents query and return a DocumentConnection
     *
     * @param variables - variables without 'id' to pass into the Project_DocumentsQuery
     * @returns parsed response from Project_DocumentsQuery
     */
    fetch(variables?: Omit<L.Project_DocumentsQueryVariables, "id">): LinearFetch<DocumentConnection>;
}
/**
 * A fetchable Project_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_IssuesQuery
 */
export declare class Project_IssuesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_IssuesQueryVariables, "id">);
    /**
     * Call the Project_Issues query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the Project_IssuesQuery
     * @returns parsed response from Project_IssuesQuery
     */
    fetch(variables?: Omit<L.Project_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Project_Links Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_LinksQuery
 */
export declare class Project_LinksQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_LinksQueryVariables, "id">);
    /**
     * Call the Project_Links query and return a ProjectLinkConnection
     *
     * @param variables - variables without 'id' to pass into the Project_LinksQuery
     * @returns parsed response from Project_LinksQuery
     */
    fetch(variables?: Omit<L.Project_LinksQueryVariables, "id">): LinearFetch<ProjectLinkConnection>;
}
/**
 * A fetchable Project_Members Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_MembersQuery
 */
export declare class Project_MembersQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_MembersQueryVariables, "id">);
    /**
     * Call the Project_Members query and return a UserConnection
     *
     * @param variables - variables without 'id' to pass into the Project_MembersQuery
     * @returns parsed response from Project_MembersQuery
     */
    fetch(variables?: Omit<L.Project_MembersQueryVariables, "id">): LinearFetch<UserConnection>;
}
/**
 * A fetchable Project_ProjectMilestones Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_ProjectMilestonesQuery
 */
export declare class Project_ProjectMilestonesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_ProjectMilestonesQueryVariables, "id">);
    /**
     * Call the Project_ProjectMilestones query and return a ProjectMilestoneConnection
     *
     * @param variables - variables without 'id' to pass into the Project_ProjectMilestonesQuery
     * @returns parsed response from Project_ProjectMilestonesQuery
     */
    fetch(variables?: Omit<L.Project_ProjectMilestonesQueryVariables, "id">): LinearFetch<ProjectMilestoneConnection>;
}
/**
 * A fetchable Project_ProjectUpdates Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_ProjectUpdatesQuery
 */
export declare class Project_ProjectUpdatesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_ProjectUpdatesQueryVariables, "id">);
    /**
     * Call the Project_ProjectUpdates query and return a ProjectUpdateConnection
     *
     * @param variables - variables without 'id' to pass into the Project_ProjectUpdatesQuery
     * @returns parsed response from Project_ProjectUpdatesQuery
     */
    fetch(variables?: Omit<L.Project_ProjectUpdatesQueryVariables, "id">): LinearFetch<ProjectUpdateConnection>;
}
/**
 * A fetchable Project_Teams Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_TeamsQuery
 */
export declare class Project_TeamsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_TeamsQueryVariables, "id">);
    /**
     * Call the Project_Teams query and return a TeamConnection
     *
     * @param variables - variables without 'id' to pass into the Project_TeamsQuery
     * @returns parsed response from Project_TeamsQuery
     */
    fetch(variables?: Omit<L.Project_TeamsQueryVariables, "id">): LinearFetch<TeamConnection>;
}
/**
 * A fetchable Roadmap_Projects Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to roadmap
 * @param variables - variables without 'id' to pass into the Roadmap_ProjectsQuery
 */
export declare class Roadmap_ProjectsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Roadmap_ProjectsQueryVariables, "id">);
    /**
     * Call the Roadmap_Projects query and return a ProjectConnection
     *
     * @param variables - variables without 'id' to pass into the Roadmap_ProjectsQuery
     * @returns parsed response from Roadmap_ProjectsQuery
     */
    fetch(variables?: Omit<L.Roadmap_ProjectsQueryVariables, "id">): LinearFetch<ProjectConnection>;
}
/**
 * A fetchable SearchDocuments_ArchivePayload Query
 *
 * @param request - function to call the graphql client
 * @param term - required term to pass to searchDocuments
 * @param variables - variables without 'term' to pass into the SearchDocuments_ArchivePayloadQuery
 */
export declare class SearchDocuments_ArchivePayloadQuery extends Request {
    private _term;
    private _variables?;
    constructor(request: LinearRequest, term: string, variables?: Omit<L.SearchDocuments_ArchivePayloadQueryVariables, "term">);
    /**
     * Call the SearchDocuments_ArchivePayload query and return a ArchiveResponse
     *
     * @param variables - variables without 'term' to pass into the SearchDocuments_ArchivePayloadQuery
     * @returns parsed response from SearchDocuments_ArchivePayloadQuery
     */
    fetch(variables?: Omit<L.SearchDocuments_ArchivePayloadQueryVariables, "term">): LinearFetch<ArchiveResponse>;
}
/**
 * A fetchable SearchIssues_ArchivePayload Query
 *
 * @param request - function to call the graphql client
 * @param term - required term to pass to searchIssues
 * @param variables - variables without 'term' to pass into the SearchIssues_ArchivePayloadQuery
 */
export declare class SearchIssues_ArchivePayloadQuery extends Request {
    private _term;
    private _variables?;
    constructor(request: LinearRequest, term: string, variables?: Omit<L.SearchIssues_ArchivePayloadQueryVariables, "term">);
    /**
     * Call the SearchIssues_ArchivePayload query and return a ArchiveResponse
     *
     * @param variables - variables without 'term' to pass into the SearchIssues_ArchivePayloadQuery
     * @returns parsed response from SearchIssues_ArchivePayloadQuery
     */
    fetch(variables?: Omit<L.SearchIssues_ArchivePayloadQueryVariables, "term">): LinearFetch<ArchiveResponse>;
}
/**
 * A fetchable SearchProjects_ArchivePayload Query
 *
 * @param request - function to call the graphql client
 * @param term - required term to pass to searchProjects
 * @param variables - variables without 'term' to pass into the SearchProjects_ArchivePayloadQuery
 */
export declare class SearchProjects_ArchivePayloadQuery extends Request {
    private _term;
    private _variables?;
    constructor(request: LinearRequest, term: string, variables?: Omit<L.SearchProjects_ArchivePayloadQueryVariables, "term">);
    /**
     * Call the SearchProjects_ArchivePayload query and return a ArchiveResponse
     *
     * @param variables - variables without 'term' to pass into the SearchProjects_ArchivePayloadQuery
     * @returns parsed response from SearchProjects_ArchivePayloadQuery
     */
    fetch(variables?: Omit<L.SearchProjects_ArchivePayloadQueryVariables, "term">): LinearFetch<ArchiveResponse>;
}
/**
 * A fetchable Team_Cycles Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_CyclesQuery
 */
export declare class Team_CyclesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_CyclesQueryVariables, "id">);
    /**
     * Call the Team_Cycles query and return a CycleConnection
     *
     * @param variables - variables without 'id' to pass into the Team_CyclesQuery
     * @returns parsed response from Team_CyclesQuery
     */
    fetch(variables?: Omit<L.Team_CyclesQueryVariables, "id">): LinearFetch<CycleConnection>;
}
/**
 * A fetchable Team_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_IssuesQuery
 */
export declare class Team_IssuesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_IssuesQueryVariables, "id">);
    /**
     * Call the Team_Issues query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the Team_IssuesQuery
     * @returns parsed response from Team_IssuesQuery
     */
    fetch(variables?: Omit<L.Team_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Team_Labels Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_LabelsQuery
 */
export declare class Team_LabelsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_LabelsQueryVariables, "id">);
    /**
     * Call the Team_Labels query and return a IssueLabelConnection
     *
     * @param variables - variables without 'id' to pass into the Team_LabelsQuery
     * @returns parsed response from Team_LabelsQuery
     */
    fetch(variables?: Omit<L.Team_LabelsQueryVariables, "id">): LinearFetch<IssueLabelConnection>;
}
/**
 * A fetchable Team_Members Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_MembersQuery
 */
export declare class Team_MembersQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_MembersQueryVariables, "id">);
    /**
     * Call the Team_Members query and return a UserConnection
     *
     * @param variables - variables without 'id' to pass into the Team_MembersQuery
     * @returns parsed response from Team_MembersQuery
     */
    fetch(variables?: Omit<L.Team_MembersQueryVariables, "id">): LinearFetch<UserConnection>;
}
/**
 * A fetchable Team_Memberships Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_MembershipsQuery
 */
export declare class Team_MembershipsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_MembershipsQueryVariables, "id">);
    /**
     * Call the Team_Memberships query and return a TeamMembershipConnection
     *
     * @param variables - variables without 'id' to pass into the Team_MembershipsQuery
     * @returns parsed response from Team_MembershipsQuery
     */
    fetch(variables?: Omit<L.Team_MembershipsQueryVariables, "id">): LinearFetch<TeamMembershipConnection>;
}
/**
 * A fetchable Team_Projects Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_ProjectsQuery
 */
export declare class Team_ProjectsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_ProjectsQueryVariables, "id">);
    /**
     * Call the Team_Projects query and return a ProjectConnection
     *
     * @param variables - variables without 'id' to pass into the Team_ProjectsQuery
     * @returns parsed response from Team_ProjectsQuery
     */
    fetch(variables?: Omit<L.Team_ProjectsQueryVariables, "id">): LinearFetch<ProjectConnection>;
}
/**
 * A fetchable Team_States Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_StatesQuery
 */
export declare class Team_StatesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_StatesQueryVariables, "id">);
    /**
     * Call the Team_States query and return a WorkflowStateConnection
     *
     * @param variables - variables without 'id' to pass into the Team_StatesQuery
     * @returns parsed response from Team_StatesQuery
     */
    fetch(variables?: Omit<L.Team_StatesQueryVariables, "id">): LinearFetch<WorkflowStateConnection>;
}
/**
 * A fetchable Team_Templates Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_TemplatesQuery
 */
export declare class Team_TemplatesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_TemplatesQueryVariables, "id">);
    /**
     * Call the Team_Templates query and return a TemplateConnection
     *
     * @param variables - variables without 'id' to pass into the Team_TemplatesQuery
     * @returns parsed response from Team_TemplatesQuery
     */
    fetch(variables?: Omit<L.Team_TemplatesQueryVariables, "id">): LinearFetch<TemplateConnection>;
}
/**
 * A fetchable Team_Webhooks Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_WebhooksQuery
 */
export declare class Team_WebhooksQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_WebhooksQueryVariables, "id">);
    /**
     * Call the Team_Webhooks query and return a WebhookConnection
     *
     * @param variables - variables without 'id' to pass into the Team_WebhooksQuery
     * @returns parsed response from Team_WebhooksQuery
     */
    fetch(variables?: Omit<L.Team_WebhooksQueryVariables, "id">): LinearFetch<WebhookConnection>;
}
/**
 * A fetchable User_AssignedIssues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to user
 * @param variables - variables without 'id' to pass into the User_AssignedIssuesQuery
 */
export declare class User_AssignedIssuesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.User_AssignedIssuesQueryVariables, "id">);
    /**
     * Call the User_AssignedIssues query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the User_AssignedIssuesQuery
     * @returns parsed response from User_AssignedIssuesQuery
     */
    fetch(variables?: Omit<L.User_AssignedIssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable User_CreatedIssues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to user
 * @param variables - variables without 'id' to pass into the User_CreatedIssuesQuery
 */
export declare class User_CreatedIssuesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.User_CreatedIssuesQueryVariables, "id">);
    /**
     * Call the User_CreatedIssues query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the User_CreatedIssuesQuery
     * @returns parsed response from User_CreatedIssuesQuery
     */
    fetch(variables?: Omit<L.User_CreatedIssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * A fetchable User_TeamMemberships Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to user
 * @param variables - variables without 'id' to pass into the User_TeamMembershipsQuery
 */
export declare class User_TeamMembershipsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.User_TeamMembershipsQueryVariables, "id">);
    /**
     * Call the User_TeamMemberships query and return a TeamMembershipConnection
     *
     * @param variables - variables without 'id' to pass into the User_TeamMembershipsQuery
     * @returns parsed response from User_TeamMembershipsQuery
     */
    fetch(variables?: Omit<L.User_TeamMembershipsQueryVariables, "id">): LinearFetch<TeamMembershipConnection>;
}
/**
 * A fetchable User_Teams Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to user
 * @param variables - variables without 'id' to pass into the User_TeamsQuery
 */
export declare class User_TeamsQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.User_TeamsQueryVariables, "id">);
    /**
     * Call the User_Teams query and return a TeamConnection
     *
     * @param variables - variables without 'id' to pass into the User_TeamsQuery
     * @returns parsed response from User_TeamsQuery
     */
    fetch(variables?: Omit<L.User_TeamsQueryVariables, "id">): LinearFetch<TeamConnection>;
}
/**
 * A fetchable Viewer_AssignedIssues Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Viewer_AssignedIssuesQuery
 */
export declare class Viewer_AssignedIssuesQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Viewer_AssignedIssuesQueryVariables);
    /**
     * Call the Viewer_AssignedIssues query and return a IssueConnection
     *
     * @param variables - variables to pass into the Viewer_AssignedIssuesQuery
     * @returns parsed response from Viewer_AssignedIssuesQuery
     */
    fetch(variables?: L.Viewer_AssignedIssuesQueryVariables): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Viewer_CreatedIssues Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Viewer_CreatedIssuesQuery
 */
export declare class Viewer_CreatedIssuesQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Viewer_CreatedIssuesQueryVariables);
    /**
     * Call the Viewer_CreatedIssues query and return a IssueConnection
     *
     * @param variables - variables to pass into the Viewer_CreatedIssuesQuery
     * @returns parsed response from Viewer_CreatedIssuesQuery
     */
    fetch(variables?: L.Viewer_CreatedIssuesQueryVariables): LinearFetch<IssueConnection>;
}
/**
 * A fetchable Viewer_TeamMemberships Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Viewer_TeamMembershipsQuery
 */
export declare class Viewer_TeamMembershipsQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Viewer_TeamMembershipsQueryVariables);
    /**
     * Call the Viewer_TeamMemberships query and return a TeamMembershipConnection
     *
     * @param variables - variables to pass into the Viewer_TeamMembershipsQuery
     * @returns parsed response from Viewer_TeamMembershipsQuery
     */
    fetch(variables?: L.Viewer_TeamMembershipsQueryVariables): LinearFetch<TeamMembershipConnection>;
}
/**
 * A fetchable Viewer_Teams Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Viewer_TeamsQuery
 */
export declare class Viewer_TeamsQuery extends Request {
    private _variables?;
    constructor(request: LinearRequest, variables?: L.Viewer_TeamsQueryVariables);
    /**
     * Call the Viewer_Teams query and return a TeamConnection
     *
     * @param variables - variables to pass into the Viewer_TeamsQuery
     * @returns parsed response from Viewer_TeamsQuery
     */
    fetch(variables?: L.Viewer_TeamsQueryVariables): LinearFetch<TeamConnection>;
}
/**
 * A fetchable WorkflowState_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to workflowState
 * @param variables - variables without 'id' to pass into the WorkflowState_IssuesQuery
 */
export declare class WorkflowState_IssuesQuery extends Request {
    private _id;
    private _variables?;
    constructor(request: LinearRequest, id: string, variables?: Omit<L.WorkflowState_IssuesQueryVariables, "id">);
    /**
     * Call the WorkflowState_Issues query and return a IssueConnection
     *
     * @param variables - variables without 'id' to pass into the WorkflowState_IssuesQuery
     * @returns parsed response from WorkflowState_IssuesQuery
     */
    fetch(variables?: Omit<L.WorkflowState_IssuesQueryVariables, "id">): LinearFetch<IssueConnection>;
}
/**
 * The SDK class containing all root operations
 *
 * @param request - function to call the graphql client
 */
export declare class LinearSdk extends Request {
    constructor(request: LinearRequest);
    /**
     * Creates an integration api key for Airbyte to connect with Linear
     *
     * @param input - required input to pass to airbyteIntegrationConnect
     * @returns IntegrationPayload
     */
    airbyteIntegrationConnect(input: L.AirbyteConfigurationInput): LinearFetch<IntegrationPayload>;
    /**
     * Creates a new API key.
     *
     * @param input - required input to pass to createApiKey
     * @returns ApiKeyPayload
     */
    createApiKey(input: L.ApiKeyCreateInput): LinearFetch<ApiKeyPayload>;
    /**
     * Deletes an API key.
     *
     * @param id - required id to pass to deleteApiKey
     * @returns DeletePayload
     */
    deleteApiKey(id: string): LinearFetch<DeletePayload>;
    /**
     * [DEPRECATED] Archives an issue attachment.
     *
     * @param id - required id to pass to archiveAttachment
     * @returns AttachmentArchivePayload
     */
    archiveAttachment(id: string): LinearFetch<AttachmentArchivePayload>;
    /**
     * Creates a new attachment, or updates existing if the same `url` and `issueId` is used.
     *
     * @param input - required input to pass to createAttachment
     * @returns AttachmentPayload
     */
    createAttachment(input: L.AttachmentCreateInput): LinearFetch<AttachmentPayload>;
    /**
     * Deletes an issue attachment.
     *
     * @param id - required id to pass to deleteAttachment
     * @returns DeletePayload
     */
    deleteAttachment(id: string): LinearFetch<DeletePayload>;
    /**
     * Link an existing Discord message to an issue.
     *
     * @param channelId - required channelId to pass to attachmentLinkDiscord
     * @param issueId - required issueId to pass to attachmentLinkDiscord
     * @param messageId - required messageId to pass to attachmentLinkDiscord
     * @param url - required url to pass to attachmentLinkDiscord
     * @returns AttachmentPayload
     */
    attachmentLinkDiscord(channelId: string, issueId: string, messageId: string, url: string): LinearFetch<AttachmentPayload>;
    /**
     * Link an existing Front conversation to an issue.
     *
     * @param conversationId - required conversationId to pass to attachmentLinkFront
     * @param issueId - required issueId to pass to attachmentLinkFront
     * @returns FrontAttachmentPayload
     */
    attachmentLinkFront(conversationId: string, issueId: string): LinearFetch<FrontAttachmentPayload>;
    /**
     * Link an existing Intercom conversation to an issue.
     *
     * @param conversationId - required conversationId to pass to attachmentLinkIntercom
     * @param issueId - required issueId to pass to attachmentLinkIntercom
     * @returns AttachmentPayload
     */
    attachmentLinkIntercom(conversationId: string, issueId: string): LinearFetch<AttachmentPayload>;
    /**
     * Link an existing Jira issue to an issue.
     *
     * @param issueId - required issueId to pass to attachmentLinkJiraIssue
     * @param jiraIssueId - required jiraIssueId to pass to attachmentLinkJiraIssue
     * @returns AttachmentPayload
     */
    attachmentLinkJiraIssue(issueId: string, jiraIssueId: string): LinearFetch<AttachmentPayload>;
    /**
     * Link an existing Slack message to an issue.
     *
     * @param channel - required channel to pass to attachmentLinkSlack
     * @param issueId - required issueId to pass to attachmentLinkSlack
     * @param latest - required latest to pass to attachmentLinkSlack
     * @param url - required url to pass to attachmentLinkSlack
     * @param variables - variables without 'channel', 'issueId', 'latest', 'url' to pass into the AttachmentLinkSlackMutation
     * @returns AttachmentPayload
     */
    attachmentLinkSlack(channel: string, issueId: string, latest: string, url: string, variables?: Omit<L.AttachmentLinkSlackMutationVariables, "channel" | "issueId" | "latest" | "url">): LinearFetch<AttachmentPayload>;
    /**
     * Link any url to an issue.
     *
     * @param issueId - required issueId to pass to attachmentLinkURL
     * @param url - required url to pass to attachmentLinkURL
     * @param variables - variables without 'issueId', 'url' to pass into the AttachmentLinkUrlMutation
     * @returns AttachmentPayload
     */
    attachmentLinkURL(issueId: string, url: string, variables?: Omit<L.AttachmentLinkUrlMutationVariables, "issueId" | "url">): LinearFetch<AttachmentPayload>;
    /**
     * Link an existing Zendesk ticket to an issue.
     *
     * @param issueId - required issueId to pass to attachmentLinkZendesk
     * @param ticketId - required ticketId to pass to attachmentLinkZendesk
     * @returns AttachmentPayload
     */
    attachmentLinkZendesk(issueId: string, ticketId: string): LinearFetch<AttachmentPayload>;
    /**
     * Unsyncs an existing synced Slack attachment.
     *
     * @param id - required id to pass to attachmentUnsyncSlack
     * @returns AttachmentPayload
     */
    attachmentUnsyncSlack(id: string): LinearFetch<AttachmentPayload>;
    /**
     * Updates an existing issue attachment.
     *
     * @param id - required id to pass to updateAttachment
     * @param input - required input to pass to updateAttachment
     * @returns AttachmentPayload
     */
    updateAttachment(id: string, input: L.AttachmentUpdateInput): LinearFetch<AttachmentPayload>;
    /**
     * Creates a new comment.
     *
     * @param input - required input to pass to createComment
     * @returns CommentPayload
     */
    createComment(input: L.CommentCreateInput): LinearFetch<CommentPayload>;
    /**
     * Deletes a comment.
     *
     * @param id - required id to pass to deleteComment
     * @returns DeletePayload
     */
    deleteComment(id: string): LinearFetch<DeletePayload>;
    /**
     * Updates a comment.
     *
     * @param id - required id to pass to updateComment
     * @param input - required input to pass to updateComment
     * @returns CommentPayload
     */
    updateComment(id: string, input: L.CommentUpdateInput): LinearFetch<CommentPayload>;
    /**
     * Saves user message.
     *
     * @param input - required input to pass to createContact
     * @returns ContactPayload
     */
    createContact(input: L.ContactCreateInput): LinearFetch<ContactPayload>;
    /**
     * Create CSV export report for the organization.
     *
     * @param variables - variables to pass into the CreateCsvExportReportMutation
     * @returns CreateCsvExportReportPayload
     */
    createCsvExportReport(variables?: L.CreateCsvExportReportMutationVariables): LinearFetch<CreateCsvExportReportPayload>;
    /**
     * Creates an organization from onboarding.
     *
     * @param input - required input to pass to createOrganizationFromOnboarding
     * @param variables - variables without 'input' to pass into the CreateOrganizationFromOnboardingMutation
     * @returns CreateOrJoinOrganizationResponse
     */
    createOrganizationFromOnboarding(input: L.CreateOrganizationInput, variables?: Omit<L.CreateOrganizationFromOnboardingMutationVariables, "input">): LinearFetch<CreateOrJoinOrganizationResponse>;
    /**
     * Creates a new custom view.
     *
     * @param input - required input to pass to createCustomView
     * @returns CustomViewPayload
     */
    createCustomView(input: L.CustomViewCreateInput): LinearFetch<CustomViewPayload>;
    /**
     * Deletes a custom view.
     *
     * @param id - required id to pass to deleteCustomView
     * @returns DeletePayload
     */
    deleteCustomView(id: string): LinearFetch<DeletePayload>;
    /**
     * Updates a custom view.
     *
     * @param id - required id to pass to updateCustomView
     * @param input - required input to pass to updateCustomView
     * @returns CustomViewPayload
     */
    updateCustomView(id: string, input: L.CustomViewUpdateInput): LinearFetch<CustomViewPayload>;
    /**
     * Archives a cycle.
     *
     * @param id - required id to pass to archiveCycle
     * @returns CycleArchivePayload
     */
    archiveCycle(id: string): LinearFetch<CycleArchivePayload>;
    /**
     * Creates a new cycle.
     *
     * @param input - required input to pass to createCycle
     * @returns CyclePayload
     */
    createCycle(input: L.CycleCreateInput): LinearFetch<CyclePayload>;
    /**
     * Updates a cycle.
     *
     * @param id - required id to pass to updateCycle
     * @param input - required input to pass to updateCycle
     * @returns CyclePayload
     */
    updateCycle(id: string, input: L.CycleUpdateInput): LinearFetch<CyclePayload>;
    /**
     * Creates a new document.
     *
     * @param input - required input to pass to createDocument
     * @returns DocumentPayload
     */
    createDocument(input: L.DocumentCreateInput): LinearFetch<DocumentPayload>;
    /**
     * Deletes a document.
     *
     * @param id - required id to pass to deleteDocument
     * @returns DeletePayload
     */
    deleteDocument(id: string): LinearFetch<DeletePayload>;
    /**
     * Updates a document.
     *
     * @param id - required id to pass to updateDocument
     * @param input - required input to pass to updateDocument
     * @returns DocumentPayload
     */
    updateDocument(id: string, input: L.DocumentUpdateInput): LinearFetch<DocumentPayload>;
    /**
     * Authenticates a user account via email and authentication token.
     *
     * @param input - required input to pass to emailTokenUserAccountAuth
     * @returns AuthResolverResponse
     */
    emailTokenUserAccountAuth(input: L.TokenUserAccountAuthInput): LinearFetch<AuthResolverResponse>;
    /**
     * Unsubscribes the user from one type of emails.
     *
     * @param input - required input to pass to emailUnsubscribe
     * @returns EmailUnsubscribePayload
     */
    emailUnsubscribe(input: L.EmailUnsubscribeInput): LinearFetch<EmailUnsubscribePayload>;
    /**
     * Finds or creates a new user account by email and sends an email with token.
     *
     * @param input - required input to pass to emailUserAccountAuthChallenge
     * @returns EmailUserAccountAuthChallengeResponse
     */
    emailUserAccountAuthChallenge(input: L.EmailUserAccountAuthChallengeInput): LinearFetch<EmailUserAccountAuthChallengeResponse>;
    /**
     * Creates a custom emoji.
     *
     * @param input - required input to pass to createEmoji
     * @returns EmojiPayload
     */
    createEmoji(input: L.EmojiCreateInput): LinearFetch<EmojiPayload>;
    /**
     * Deletes an emoji.
     *
     * @param id - required id to pass to deleteEmoji
     * @returns DeletePayload
     */
    deleteEmoji(id: string): LinearFetch<DeletePayload>;
    /**
     * Creates a new favorite (project, cycle etc).
     *
     * @param input - required input to pass to createFavorite
     * @returns FavoritePayload
     */
    createFavorite(input: L.FavoriteCreateInput): LinearFetch<FavoritePayload>;
    /**
     * Deletes a favorite reference.
     *
     * @param id - required id to pass to deleteFavorite
     * @returns DeletePayload
     */
    deleteFavorite(id: string): LinearFetch<DeletePayload>;
    /**
     * Updates a favorite.
     *
     * @param id - required id to pass to updateFavorite
     * @param input - required input to pass to updateFavorite
     * @returns FavoritePayload
     */
    updateFavorite(id: string, input: L.FavoriteUpdateInput): LinearFetch<FavoritePayload>;
    /**
     * XHR request payload to upload an images, video and other attachments directly to Linear's cloud storage.
     *
     * @param contentType - required contentType to pass to fileUpload
     * @param filename - required filename to pass to fileUpload
     * @param size - required size to pass to fileUpload
     * @param variables - variables without 'contentType', 'filename', 'size' to pass into the FileUploadMutation
     * @returns UploadPayload
     */
    fileUpload(contentType: string, filename: string, size: number, variables?: Omit<L.FileUploadMutationVariables, "contentType" | "filename" | "size">): LinearFetch<UploadPayload>;
    /**
     * Authenticate user account through Google OAuth. This is the 2nd step of OAuth flow.
     *
     * @param input - required input to pass to googleUserAccountAuth
     * @returns AuthResolverResponse
     */
    googleUserAccountAuth(input: L.GoogleUserAccountAuthInput): LinearFetch<AuthResolverResponse>;
    /**
     * Upload an image from an URL to Linear.
     *
     * @param url - required url to pass to imageUploadFromUrl
     * @returns ImageUploadFromUrlPayload
     */
    imageUploadFromUrl(url: string): LinearFetch<ImageUploadFromUrlPayload>;
    /**
     * XHR request payload to upload a file for import, directly to Linear's cloud storage.
     *
     * @param contentType - required contentType to pass to importFileUpload
     * @param filename - required filename to pass to importFileUpload
     * @param size - required size to pass to importFileUpload
     * @param variables - variables without 'contentType', 'filename', 'size' to pass into the ImportFileUploadMutation
     * @returns UploadPayload
     */
    importFileUpload(contentType: string, filename: string, size: number, variables?: Omit<L.ImportFileUploadMutationVariables, "contentType" | "filename" | "size">): LinearFetch<UploadPayload>;
    /**
     * Deletes an integration.
     *
     * @param id - required id to pass to deleteIntegration
     * @returns DeletePayload
     */
    deleteIntegration(id: string): LinearFetch<DeletePayload>;
    /**
     * Integrates the organization with Discord.
     *
     * @param code - required code to pass to integrationDiscord
     * @param redirectUri - required redirectUri to pass to integrationDiscord
     * @returns IntegrationPayload
     */
    integrationDiscord(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
    /**
     * Integrates the organization with Figma.
     *
     * @param code - required code to pass to integrationFigma
     * @param redirectUri - required redirectUri to pass to integrationFigma
     * @returns IntegrationPayload
     */
    integrationFigma(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
    /**
     * Integrates the organization with Front.
     *
     * @param code - required code to pass to integrationFront
     * @param redirectUri - required redirectUri to pass to integrationFront
     * @returns IntegrationPayload
     */
    integrationFront(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
    /**
     * Generates a webhook for the GitHub commit integration.
     *
     * @returns GitHubCommitIntegrationPayload
     */
    get createIntegrationGithubCommit(): LinearFetch<GitHubCommitIntegrationPayload>;
    /**
     * Connects the organization with the GitHub App.
     *
     * @param installationId - required installationId to pass to integrationGithubConnect
     * @returns IntegrationPayload
     */
    integrationGithubConnect(installationId: string): LinearFetch<IntegrationPayload>;
    /**
     * Connects the organization with a GitLab Access Token.
     *
     * @param accessToken - required accessToken to pass to integrationGitlabConnect
     * @param gitlabUrl - required gitlabUrl to pass to integrationGitlabConnect
     * @returns IntegrationPayload
     */
    integrationGitlabConnect(accessToken: string, gitlabUrl: string): LinearFetch<IntegrationPayload>;
    /**
     * Integrates the organization with Google Sheets.
     *
     * @param code - required code to pass to integrationGoogleSheets
     * @returns IntegrationPayload
     */
    integrationGoogleSheets(code: string): LinearFetch<IntegrationPayload>;
    /**
     * Integrates the organization with Intercom.
     *
     * @param code - required code to pass to integrationIntercom
     * @param redirectUri - required redirectUri to pass to integrationIntercom
     * @param variables - variables without 'code', 'redirectUri' to pass into the IntegrationIntercomMutation
     * @returns IntegrationPayload
     */
    integrationIntercom(code: string, redirectUri: string, variables?: Omit<L.IntegrationIntercomMutationVariables, "code" | "redirectUri">): LinearFetch<IntegrationPayload>;
    /**
     * Disconnects the organization from Intercom.
     *
     * @returns IntegrationPayload
     */
    get deleteIntegrationIntercom(): LinearFetch<IntegrationPayload>;
    /**
     * [DEPRECATED] Updates settings on the Intercom integration.
     *
     * @param input - required input to pass to updateIntegrationIntercomSettings
     * @returns IntegrationPayload
     */
    updateIntegrationIntercomSettings(input: L.IntercomSettingsInput): LinearFetch<IntegrationPayload>;
    /**
     * Enables Loom integration for the organization.
     *
     * @returns IntegrationPayload
     */
    get integrationLoom(): LinearFetch<IntegrationPayload>;
    /**
     * Requests a currently unavailable integration.
     *
     * @param input - required input to pass to integrationRequest
     * @returns IntegrationRequestPayload
     */
    integrationRequest(input: L.IntegrationRequestInput): LinearFetch<IntegrationRequestPayload>;
    /**
     * Integrates the organization with Sentry.
     *
     * @param code - required code to pass to integrationSentryConnect
     * @param installationId - required installationId to pass to integrationSentryConnect
     * @param organizationSlug - required organizationSlug to pass to integrationSentryConnect
     * @returns IntegrationPayload
     */
    integrationSentryConnect(code: string, installationId: string, organizationSlug: string): LinearFetch<IntegrationPayload>;
    /**
     * Integrates the organization with Slack.
     *
     * @param code - required code to pass to integrationSlack
     * @param redirectUri - required redirectUri to pass to integrationSlack
     * @param variables - variables without 'code', 'redirectUri' to pass into the IntegrationSlackMutation
     * @returns IntegrationPayload
     */
    integrationSlack(code: string, redirectUri: string, variables?: Omit<L.IntegrationSlackMutationVariables, "code" | "redirectUri">): LinearFetch<IntegrationPayload>;
    /**
     * Integrates the organization with the Slack Asks app
     *
     * @param code - required code to pass to integrationSlackAsks
     * @param redirectUri - required redirectUri to pass to integrationSlackAsks
     * @returns IntegrationPayload
     */
    integrationSlackAsks(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
    /**
     * Imports custom emojis from your Slack workspace.
     *
     * @param code - required code to pass to integrationSlackImportEmojis
     * @param redirectUri - required redirectUri to pass to integrationSlackImportEmojis
     * @returns IntegrationPayload
     */
    integrationSlackImportEmojis(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
    /**
     * Slack integration for organization level project update notifications.
     *
     * @param code - required code to pass to integrationSlackOrgProjectUpdatesPost
     * @param redirectUri - required redirectUri to pass to integrationSlackOrgProjectUpdatesPost
     * @returns IntegrationPayload
     */
    integrationSlackOrgProjectUpdatesPost(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
    /**
     * Integrates your personal notifications with Slack.
     *
     * @param code - required code to pass to integrationSlackPersonal
     * @param redirectUri - required redirectUri to pass to integrationSlackPersonal
     * @returns IntegrationPayload
     */
    integrationSlackPersonal(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
    /**
     * Slack webhook integration.
     *
     * @param code - required code to pass to integrationSlackPost
     * @param redirectUri - required redirectUri to pass to integrationSlackPost
     * @param teamId - required teamId to pass to integrationSlackPost
     * @param variables - variables without 'code', 'redirectUri', 'teamId' to pass into the IntegrationSlackPostMutation
     * @returns IntegrationPayload
     */
    integrationSlackPost(code: string, redirectUri: string, teamId: string, variables?: Omit<L.IntegrationSlackPostMutationVariables, "code" | "redirectUri" | "teamId">): LinearFetch<IntegrationPayload>;
    /**
     * Slack integration for project notifications.
     *
     * @param code - required code to pass to integrationSlackProjectPost
     * @param projectId - required projectId to pass to integrationSlackProjectPost
     * @param redirectUri - required redirectUri to pass to integrationSlackProjectPost
     * @param service - required service to pass to integrationSlackProjectPost
     * @returns IntegrationPayload
     */
    integrationSlackProjectPost(code: string, projectId: string, redirectUri: string, service: string): LinearFetch<IntegrationPayload>;
    /**
     * Creates a new integrationTemplate join.
     *
     * @param input - required input to pass to createIntegrationTemplate
     * @returns IntegrationTemplatePayload
     */
    createIntegrationTemplate(input: L.IntegrationTemplateCreateInput): LinearFetch<IntegrationTemplatePayload>;
    /**
     * Deletes a integrationTemplate.
     *
     * @param id - required id to pass to deleteIntegrationTemplate
     * @returns DeletePayload
     */
    deleteIntegrationTemplate(id: string): LinearFetch<DeletePayload>;
    /**
     * Updates the organization's Slack integration.
     *
     * @param code - required code to pass to integrationUpdateSlack
     * @param redirectUri - required redirectUri to pass to integrationUpdateSlack
     * @returns IntegrationPayload
     */
    integrationUpdateSlack(code: string, redirectUri: string): LinearFetch<IntegrationPayload>;
    /**
     * Integrates the organization with Zendesk.
     *
     * @param code - required code to pass to integrationZendesk
     * @param redirectUri - required redirectUri to pass to integrationZendesk
     * @param scope - required scope to pass to integrationZendesk
     * @param subdomain - required subdomain to pass to integrationZendesk
     * @returns IntegrationPayload
     */
    integrationZendesk(code: string, redirectUri: string, scope: string, subdomain: string): LinearFetch<IntegrationPayload>;
    /**
     * Creates new settings for one or more integrations.
     *
     * @param input - required input to pass to createIntegrationsSettings
     * @returns IntegrationsSettingsPayload
     */
    createIntegrationsSettings(input: L.IntegrationsSettingsCreateInput): LinearFetch<IntegrationsSettingsPayload>;
    /**
     * Updates settings related to integrations for a project or a team.
     *
     * @param id - required id to pass to updateIntegrationsSettings
     * @param input - required input to pass to updateIntegrationsSettings
     * @returns IntegrationsSettingsPayload
     */
    updateIntegrationsSettings(id: string, input: L.IntegrationsSettingsUpdateInput): LinearFetch<IntegrationsSettingsPayload>;
    /**
     * Archives an issue.
     *
     * @param id - required id to pass to archiveIssue
     * @param variables - variables without 'id' to pass into the ArchiveIssueMutation
     * @returns IssueArchivePayload
     */
    archiveIssue(id: string, variables?: Omit<L.ArchiveIssueMutationVariables, "id">): LinearFetch<IssueArchivePayload>;
    /**
     * Updates multiple issues at once.
     *
     * @param ids - required ids to pass to updateIssueBatch
     * @param input - required input to pass to updateIssueBatch
     * @returns IssueBatchPayload
     */
    updateIssueBatch(ids: L.Scalars["UUID"][], input: L.IssueUpdateInput): LinearFetch<IssueBatchPayload>;
    /**
     * Creates a new issue.
     *
     * @param input - required input to pass to createIssue
     * @returns IssuePayload
     */
    createIssue(input: L.IssueCreateInput): LinearFetch<IssuePayload>;
    /**
     * Deletes (trashes) an issue.
     *
     * @param id - required id to pass to deleteIssue
     * @returns IssueArchivePayload
     */
    deleteIssue(id: string): LinearFetch<IssueArchivePayload>;
    /**
     * Kicks off an Asana import job.
     *
     * @param asanaTeamName - required asanaTeamName to pass to issueImportCreateAsana
     * @param asanaToken - required asanaToken to pass to issueImportCreateAsana
     * @param variables - variables without 'asanaTeamName', 'asanaToken' to pass into the IssueImportCreateAsanaMutation
     * @returns IssueImportPayload
     */
    issueImportCreateAsana(asanaTeamName: string, asanaToken: string, variables?: Omit<L.IssueImportCreateAsanaMutationVariables, "asanaTeamName" | "asanaToken">): LinearFetch<IssueImportPayload>;
    /**
     * Kicks off a Jira import job from a CSV.
     *
     * @param csvUrl - required csvUrl to pass to issueImportCreateCSVJira
     * @param variables - variables without 'csvUrl' to pass into the IssueImportCreateCsvJiraMutation
     * @returns IssueImportPayload
     */
    issueImportCreateCSVJira(csvUrl: string, variables?: Omit<L.IssueImportCreateCsvJiraMutationVariables, "csvUrl">): LinearFetch<IssueImportPayload>;
    /**
     * Kicks off a Shortcut (formerly Clubhouse) import job.
     *
     * @param clubhouseGroupName - required clubhouseGroupName to pass to issueImportCreateClubhouse
     * @param clubhouseToken - required clubhouseToken to pass to issueImportCreateClubhouse
     * @param variables - variables without 'clubhouseGroupName', 'clubhouseToken' to pass into the IssueImportCreateClubhouseMutation
     * @returns IssueImportPayload
     */
    issueImportCreateClubhouse(clubhouseGroupName: string, clubhouseToken: string, variables?: Omit<L.IssueImportCreateClubhouseMutationVariables, "clubhouseGroupName" | "clubhouseToken">): LinearFetch<IssueImportPayload>;
    /**
     * Kicks off a GitHub import job.
     *
     * @param githubRepoName - required githubRepoName to pass to issueImportCreateGithub
     * @param githubRepoOwner - required githubRepoOwner to pass to issueImportCreateGithub
     * @param githubToken - required githubToken to pass to issueImportCreateGithub
     * @param variables - variables without 'githubRepoName', 'githubRepoOwner', 'githubToken' to pass into the IssueImportCreateGithubMutation
     * @returns IssueImportPayload
     */
    issueImportCreateGithub(githubRepoName: string, githubRepoOwner: string, githubToken: string, variables?: Omit<L.IssueImportCreateGithubMutationVariables, "githubRepoName" | "githubRepoOwner" | "githubToken">): LinearFetch<IssueImportPayload>;
    /**
     * Kicks off a Jira import job.
     *
     * @param jiraEmail - required jiraEmail to pass to issueImportCreateJira
     * @param jiraHostname - required jiraHostname to pass to issueImportCreateJira
     * @param jiraProject - required jiraProject to pass to issueImportCreateJira
     * @param jiraToken - required jiraToken to pass to issueImportCreateJira
     * @param variables - variables without 'jiraEmail', 'jiraHostname', 'jiraProject', 'jiraToken' to pass into the IssueImportCreateJiraMutation
     * @returns IssueImportPayload
     */
    issueImportCreateJira(jiraEmail: string, jiraHostname: string, jiraProject: string, jiraToken: string, variables?: Omit<L.IssueImportCreateJiraMutationVariables, "jiraEmail" | "jiraHostname" | "jiraProject" | "jiraToken">): LinearFetch<IssueImportPayload>;
    /**
     * Deletes an import job.
     *
     * @param issueImportId - required issueImportId to pass to deleteIssueImport
     * @returns IssueImportDeletePayload
     */
    deleteIssueImport(issueImportId: string): LinearFetch<IssueImportDeletePayload>;
    /**
     * Kicks off import processing.
     *
     * @param issueImportId - required issueImportId to pass to issueImportProcess
     * @param mapping - required mapping to pass to issueImportProcess
     * @returns IssueImportPayload
     */
    issueImportProcess(issueImportId: string, mapping: Record<string, unknown>): LinearFetch<IssueImportPayload>;
    /**
     * Updates the mapping for the issue import.
     *
     * @param id - required id to pass to updateIssueImport
     * @param input - required input to pass to updateIssueImport
     * @returns IssueImportPayload
     */
    updateIssueImport(id: string, input: L.IssueImportUpdateInput): LinearFetch<IssueImportPayload>;
    /**
     * Creates a new label.
     *
     * @param input - required input to pass to createIssueLabel
     * @param variables - variables without 'input' to pass into the CreateIssueLabelMutation
     * @returns IssueLabelPayload
     */
    createIssueLabel(input: L.IssueLabelCreateInput, variables?: Omit<L.CreateIssueLabelMutationVariables, "input">): LinearFetch<IssueLabelPayload>;
    /**
     * Deletes an issue label.
     *
     * @param id - required id to pass to deleteIssueLabel
     * @returns DeletePayload
     */
    deleteIssueLabel(id: string): LinearFetch<DeletePayload>;
    /**
     * Updates an label.
     *
     * @param id - required id to pass to updateIssueLabel
     * @param input - required input to pass to updateIssueLabel
     * @returns IssueLabelPayload
     */
    updateIssueLabel(id: string, input: L.IssueLabelUpdateInput): LinearFetch<IssueLabelPayload>;
    /**
     * Creates a new issue relation.
     *
     * @param input - required input to pass to createIssueRelation
     * @returns IssueRelationPayload
     */
    createIssueRelation(input: L.IssueRelationCreateInput): LinearFetch<IssueRelationPayload>;
    /**
     * Deletes an issue relation.
     *
     * @param id - required id to pass to deleteIssueRelation
     * @returns DeletePayload
     */
    deleteIssueRelation(id: string): LinearFetch<DeletePayload>;
    /**
     * Updates an issue relation.
     *
     * @param id - required id to pass to updateIssueRelation
     * @param input - required input to pass to updateIssueRelation
     * @returns IssueRelationPayload
     */
    updateIssueRelation(id: string, input: L.IssueRelationUpdateInput): LinearFetch<IssueRelationPayload>;
    /**
     * Adds an issue reminder. Will cause a notification to be sent when the issue reminder time is reached.
     *
     * @param id - required id to pass to issueReminder
     * @param reminderAt - required reminderAt to pass to issueReminder
     * @returns IssuePayload
     */
    issueReminder(id: string, reminderAt: Date): LinearFetch<IssuePayload>;
    /**
     * Unarchives an issue.
     *
     * @param id - required id to pass to unarchiveIssue
     * @returns IssueArchivePayload
     */
    unarchiveIssue(id: string): LinearFetch<IssueArchivePayload>;
    /**
     * Updates an issue.
     *
     * @param id - required id to pass to updateIssue
     * @param input - required input to pass to updateIssue
     * @returns IssuePayload
     */
    updateIssue(id: string, input: L.IssueUpdateInput): LinearFetch<IssuePayload>;
    /**
     * Join an organization from onboarding.
     *
     * @param input - required input to pass to joinOrganizationFromOnboarding
     * @returns CreateOrJoinOrganizationResponse
     */
    joinOrganizationFromOnboarding(input: L.JoinOrganizationInput): LinearFetch<CreateOrJoinOrganizationResponse>;
    /**
     * Leave an organization.
     *
     * @param organizationId - required organizationId to pass to leaveOrganization
     * @returns CreateOrJoinOrganizationResponse
     */
    leaveOrganization(organizationId: string): LinearFetch<CreateOrJoinOrganizationResponse>;
    /**
     * Logout of all clients.
     *
     * @returns LogoutResponse
     */
    get logout(): LinearFetch<LogoutResponse>;
    /**
     * Archives a notification.
     *
     * @param id - required id to pass to archiveNotification
     * @returns NotificationArchivePayload
     */
    archiveNotification(id: string): LinearFetch<NotificationArchivePayload>;
    /**
     * Archives all of the user's past notifications for the associated entity.
     *
     * @param input - required input to pass to notificationArchiveAll
     * @returns NotificationBatchActionPayload
     */
    notificationArchiveAll(input: L.NotificationEntityInput): LinearFetch<NotificationBatchActionPayload>;
    /**
     * Marks all past notifications for the associated entity as read.
     *
     * @param input - required input to pass to notificationMarkReadAll
     * @param readAt - required readAt to pass to notificationMarkReadAll
     * @returns NotificationBatchActionPayload
     */
    notificationMarkReadAll(input: L.NotificationEntityInput, readAt: Date): LinearFetch<NotificationBatchActionPayload>;
    /**
     * Marks all past notifications for the associated entity as unread.
     *
     * @param input - required input to pass to notificationMarkUnreadAll
     * @returns NotificationBatchActionPayload
     */
    notificationMarkUnreadAll(input: L.NotificationEntityInput): LinearFetch<NotificationBatchActionPayload>;
    /**
     * Snoozes a notification and all past notifications for the associated entity.
     *
     * @param input - required input to pass to notificationSnoozeAll
     * @param snoozedUntilAt - required snoozedUntilAt to pass to notificationSnoozeAll
     * @returns NotificationBatchActionPayload
     */
    notificationSnoozeAll(input: L.NotificationEntityInput, snoozedUntilAt: Date): LinearFetch<NotificationBatchActionPayload>;
    /**
     * Creates a new notification subscription for a cycle, custom view, label, project or team.
     *
     * @param input - required input to pass to createNotificationSubscription
     * @returns NotificationSubscriptionPayload
     */
    createNotificationSubscription(input: L.NotificationSubscriptionCreateInput): LinearFetch<NotificationSubscriptionPayload>;
    /**
     * Deletes a notification subscription reference.
     *
     * @param id - required id to pass to deleteNotificationSubscription
     * @returns DeletePayload
     */
    deleteNotificationSubscription(id: string): LinearFetch<DeletePayload>;
    /**
     * Updates a notification subscription.
     *
     * @param id - required id to pass to updateNotificationSubscription
     * @param input - required input to pass to updateNotificationSubscription
     * @returns NotificationSubscriptionPayload
     */
    updateNotificationSubscription(id: string, input: L.NotificationSubscriptionUpdateInput): LinearFetch<NotificationSubscriptionPayload>;
    /**
     * Unarchives a notification.
     *
     * @param id - required id to pass to unarchiveNotification
     * @returns NotificationArchivePayload
     */
    unarchiveNotification(id: string): LinearFetch<NotificationArchivePayload>;
    /**
     * Unsnoozes a notification and all past notifications for the associated entity.
     *
     * @param input - required input to pass to notificationUnsnoozeAll
     * @param unsnoozedAt - required unsnoozedAt to pass to notificationUnsnoozeAll
     * @returns NotificationBatchActionPayload
     */
    notificationUnsnoozeAll(input: L.NotificationEntityInput, unsnoozedAt: Date): LinearFetch<NotificationBatchActionPayload>;
    /**
     * Updates a notification.
     *
     * @param id - required id to pass to updateNotification
     * @param input - required input to pass to updateNotification
     * @returns NotificationPayload
     */
    updateNotification(id: string, input: L.NotificationUpdateInput): LinearFetch<NotificationPayload>;
    /**
     * Cancels the deletion of an organization. Administrator privileges required.
     *
     * @returns OrganizationCancelDeletePayload
     */
    get deleteOrganizationCancel(): LinearFetch<OrganizationCancelDeletePayload>;
    /**
     * Delete's an organization. Administrator privileges required.
     *
     * @param input - required input to pass to deleteOrganization
     * @returns OrganizationDeletePayload
     */
    deleteOrganization(input: L.DeleteOrganizationInput): LinearFetch<OrganizationDeletePayload>;
    /**
     * Get an organization's delete confirmation token. Administrator privileges required.
     *
     * @returns OrganizationDeletePayload
     */
    get organizationDeleteChallenge(): LinearFetch<OrganizationDeletePayload>;
    /**
     * Deletes a domain.
     *
     * @param id - required id to pass to deleteOrganizationDomain
     * @returns DeletePayload
     */
    deleteOrganizationDomain(id: string): LinearFetch<DeletePayload>;
    /**
     * Creates a new organization invite.
     *
     * @param input - required input to pass to createOrganizationInvite
     * @returns OrganizationInvitePayload
     */
    createOrganizationInvite(input: L.OrganizationInviteCreateInput): LinearFetch<OrganizationInvitePayload>;
    /**
     * Deletes an organization invite.
     *
     * @param id - required id to pass to deleteOrganizationInvite
     * @returns DeletePayload
     */
    deleteOrganizationInvite(id: string): LinearFetch<DeletePayload>;
    /**
     * Updates an organization invite.
     *
     * @param id - required id to pass to updateOrganizationInvite
     * @param input - required input to pass to updateOrganizationInvite
     * @returns OrganizationInvitePayload
     */
    updateOrganizationInvite(id: string, input: L.OrganizationInviteUpdateInput): LinearFetch<OrganizationInvitePayload>;
    /**
     * Starts a plus trial for the organization. Administrator privileges required.
     *
     * @returns OrganizationStartPlusTrialPayload
     */
    get organizationStartPlusTrial(): LinearFetch<OrganizationStartPlusTrialPayload>;
    /**
     * Updates the user's organization.
     *
     * @param input - required input to pass to updateOrganization
     * @returns OrganizationPayload
     */
    updateOrganization(input: L.UpdateOrganizationInput): LinearFetch<OrganizationPayload>;
    /**
     * Archives a project.
     *
     * @param id - required id to pass to archiveProject
     * @returns ProjectArchivePayload
     */
    archiveProject(id: string): LinearFetch<ProjectArchivePayload>;
    /**
     * Creates a new project.
     *
     * @param input - required input to pass to createProject
     * @returns ProjectPayload
     */
    createProject(input: L.ProjectCreateInput): LinearFetch<ProjectPayload>;
    /**
     * Deletes a project. All issues will be disassociated from the deleted project.
     *
     * @param id - required id to pass to deleteProject
     * @returns DeletePayload
     */
    deleteProject(id: string): LinearFetch<DeletePayload>;
    /**
     * Creates a new project link.
     *
     * @param input - required input to pass to createProjectLink
     * @returns ProjectLinkPayload
     */
    createProjectLink(input: L.ProjectLinkCreateInput): LinearFetch<ProjectLinkPayload>;
    /**
     * Deletes a project link.
     *
     * @param id - required id to pass to deleteProjectLink
     * @returns DeletePayload
     */
    deleteProjectLink(id: string): LinearFetch<DeletePayload>;
    /**
     * Updates a project link.
     *
     * @param id - required id to pass to updateProjectLink
     * @param input - required input to pass to updateProjectLink
     * @returns ProjectLinkPayload
     */
    updateProjectLink(id: string, input: L.ProjectLinkUpdateInput): LinearFetch<ProjectLinkPayload>;
    /**
     * Creates a new project milestone.
     *
     * @param input - required input to pass to createProjectMilestone
     * @returns ProjectMilestonePayload
     */
    createProjectMilestone(input: L.ProjectMilestoneCreateInput): LinearFetch<ProjectMilestonePayload>;
    /**
     * Deletes a project milestone.
     *
     * @param id - required id to pass to deleteProjectMilestone
     * @returns DeletePayload
     */
    deleteProjectMilestone(id: string): LinearFetch<DeletePayload>;
    /**
     * Updates a project milestone.
     *
     * @param id - required id to pass to updateProjectMilestone
     * @param input - required input to pass to updateProjectMilestone
     * @returns ProjectMilestonePayload
     */
    updateProjectMilestone(id: string, input: L.ProjectMilestoneUpdateInput): LinearFetch<ProjectMilestonePayload>;
    /**
     * Unarchives a project.
     *
     * @param id - required id to pass to unarchiveProject
     * @returns ProjectArchivePayload
     */
    unarchiveProject(id: string): LinearFetch<ProjectArchivePayload>;
    /**
     * Updates a project.
     *
     * @param id - required id to pass to updateProject
     * @param input - required input to pass to updateProject
     * @returns ProjectPayload
     */
    updateProject(id: string, input: L.ProjectUpdateInput): LinearFetch<ProjectPayload>;
    /**
     * Creates a new project update.
     *
     * @param input - required input to pass to createProjectUpdate
     * @returns ProjectUpdatePayload
     */
    createProjectUpdate(input: L.ProjectUpdateCreateInput): LinearFetch<ProjectUpdatePayload>;
    /**
     * Deletes a project update.
     *
     * @param id - required id to pass to deleteProjectUpdate
     * @returns DeletePayload
     */
    deleteProjectUpdate(id: string): LinearFetch<DeletePayload>;
    /**
     * Creates a new interaction on a project update.
     *
     * @param input - required input to pass to createProjectUpdateInteraction
     * @returns ProjectUpdateInteractionPayload
     */
    createProjectUpdateInteraction(input: L.ProjectUpdateInteractionCreateInput): LinearFetch<ProjectUpdateInteractionPayload>;
    /**
     * Mark a project update as read.
     *
     * @param id - required id to pass to projectUpdateMarkAsRead
     * @returns ProjectUpdateWithInteractionPayload
     */
    projectUpdateMarkAsRead(id: string): LinearFetch<ProjectUpdateWithInteractionPayload>;
    /**
     * Updates a project update.
     *
     * @param id - required id to pass to updateProjectUpdate
     * @param input - required input to pass to updateProjectUpdate
     * @returns ProjectUpdatePayload
     */
    updateProjectUpdate(id: string, input: L.ProjectUpdateUpdateInput): LinearFetch<ProjectUpdatePayload>;
    /**
     * Creates a push subscription.
     *
     * @param input - required input to pass to createPushSubscription
     * @returns PushSubscriptionPayload
     */
    createPushSubscription(input: L.PushSubscriptionCreateInput): LinearFetch<PushSubscriptionPayload>;
    /**
     * Deletes a push subscription.
     *
     * @param id - required id to pass to deletePushSubscription
     * @returns PushSubscriptionPayload
     */
    deletePushSubscription(id: string): LinearFetch<PushSubscriptionPayload>;
    /**
     * Creates a new reaction.
     *
     * @param input - required input to pass to createReaction
     * @returns ReactionPayload
     */
    createReaction(input: L.ReactionCreateInput): LinearFetch<ReactionPayload>;
    /**
     * Deletes a reaction.
     *
     * @param id - required id to pass to deleteReaction
     * @returns DeletePayload
     */
    deleteReaction(id: string): LinearFetch<DeletePayload>;
    /**
     * Manually update Google Sheets data.
     *
     * @param id - required id to pass to refreshGoogleSheetsData
     * @returns IntegrationPayload
     */
    refreshGoogleSheetsData(id: string): LinearFetch<IntegrationPayload>;
    /**
     * Re-send an organization invite.
     *
     * @param id - required id to pass to resendOrganizationInvite
     * @returns DeletePayload
     */
    resendOrganizationInvite(id: string): LinearFetch<DeletePayload>;
    /**
     * Archives a roadmap.
     *
     * @param id - required id to pass to archiveRoadmap
     * @returns RoadmapArchivePayload
     */
    archiveRoadmap(id: string): LinearFetch<RoadmapArchivePayload>;
    /**
     * Creates a new roadmap.
     *
     * @param input - required input to pass to createRoadmap
     * @returns RoadmapPayload
     */
    createRoadmap(input: L.RoadmapCreateInput): LinearFetch<RoadmapPayload>;
    /**
     * Deletes a roadmap.
     *
     * @param id - required id to pass to deleteRoadmap
     * @returns DeletePayload
     */
    deleteRoadmap(id: string): LinearFetch<DeletePayload>;
    /**
     * Creates a new roadmapToProject join.
     *
     * @param input - required input to pass to createRoadmapToProject
     * @returns RoadmapToProjectPayload
     */
    createRoadmapToProject(input: L.RoadmapToProjectCreateInput): LinearFetch<RoadmapToProjectPayload>;
    /**
     * Deletes a roadmapToProject.
     *
     * @param id - required id to pass to deleteRoadmapToProject
     * @returns DeletePayload
     */
    deleteRoadmapToProject(id: string): LinearFetch<DeletePayload>;
    /**
     * Updates a roadmapToProject.
     *
     * @param id - required id to pass to updateRoadmapToProject
     * @param input - required input to pass to updateRoadmapToProject
     * @returns RoadmapToProjectPayload
     */
    updateRoadmapToProject(id: string, input: L.RoadmapToProjectUpdateInput): LinearFetch<RoadmapToProjectPayload>;
    /**
     * Unarchives a roadmap.
     *
     * @param id - required id to pass to unarchiveRoadmap
     * @returns RoadmapArchivePayload
     */
    unarchiveRoadmap(id: string): LinearFetch<RoadmapArchivePayload>;
    /**
     * Updates a roadmap.
     *
     * @param id - required id to pass to updateRoadmap
     * @param input - required input to pass to updateRoadmap
     * @returns RoadmapPayload
     */
    updateRoadmap(id: string, input: L.RoadmapUpdateInput): LinearFetch<RoadmapPayload>;
    /**
     * Authenticates a user account via email and authentication token for SAML.
     *
     * @param input - required input to pass to samlTokenUserAccountAuth
     * @returns AuthResolverResponse
     */
    samlTokenUserAccountAuth(input: L.TokenUserAccountAuthInput): LinearFetch<AuthResolverResponse>;
    /**
     * Creates a new team. The user who creates the team will automatically be added as a member to the newly created team.
     *
     * @param input - required input to pass to createTeam
     * @param variables - variables without 'input' to pass into the CreateTeamMutation
     * @returns TeamPayload
     */
    createTeam(input: L.TeamCreateInput, variables?: Omit<L.CreateTeamMutationVariables, "input">): LinearFetch<TeamPayload>;
    /**
     * Deletes team's cycles data
     *
     * @param id - required id to pass to deleteTeamCycles
     * @returns TeamPayload
     */
    deleteTeamCycles(id: string): LinearFetch<TeamPayload>;
    /**
     * Deletes a team.
     *
     * @param id - required id to pass to deleteTeam
     * @returns DeletePayload
     */
    deleteTeam(id: string): LinearFetch<DeletePayload>;
    /**
     * Deletes a previously used team key.
     *
     * @param id - required id to pass to deleteTeamKey
     * @returns DeletePayload
     */
    deleteTeamKey(id: string): LinearFetch<DeletePayload>;
    /**
     * Creates a new team membership.
     *
     * @param input - required input to pass to createTeamMembership
     * @returns TeamMembershipPayload
     */
    createTeamMembership(input: L.TeamMembershipCreateInput): LinearFetch<TeamMembershipPayload>;
    /**
     * Deletes a team membership.
     *
     * @param id - required id to pass to deleteTeamMembership
     * @returns DeletePayload
     */
    deleteTeamMembership(id: string): LinearFetch<DeletePayload>;
    /**
     * Updates a team membership.
     *
     * @param id - required id to pass to updateTeamMembership
     * @param input - required input to pass to updateTeamMembership
     * @returns TeamMembershipPayload
     */
    updateTeamMembership(id: string, input: L.TeamMembershipUpdateInput): LinearFetch<TeamMembershipPayload>;
    /**
     * Updates a team.
     *
     * @param id - required id to pass to updateTeam
     * @param input - required input to pass to updateTeam
     * @returns TeamPayload
     */
    updateTeam(id: string, input: L.TeamUpdateInput): LinearFetch<TeamPayload>;
    /**
     * Creates a new template.
     *
     * @param input - required input to pass to createTemplate
     * @returns TemplatePayload
     */
    createTemplate(input: L.TemplateCreateInput): LinearFetch<TemplatePayload>;
    /**
     * Deletes a template.
     *
     * @param id - required id to pass to deleteTemplate
     * @returns DeletePayload
     */
    deleteTemplate(id: string): LinearFetch<DeletePayload>;
    /**
     * Updates an existing template.
     *
     * @param id - required id to pass to updateTemplate
     * @param input - required input to pass to updateTemplate
     * @returns TemplatePayload
     */
    updateTemplate(id: string, input: L.TemplateUpdateInput): LinearFetch<TemplatePayload>;
    /**
     * Makes user a regular user. Can only be called by an admin.
     *
     * @param id - required id to pass to userDemoteAdmin
     * @returns UserAdminPayload
     */
    userDemoteAdmin(id: string): LinearFetch<UserAdminPayload>;
    /**
     * Makes user a guest. Can only be called by an admin.
     *
     * @param id - required id to pass to userDemoteMember
     * @returns UserAdminPayload
     */
    userDemoteMember(id: string): LinearFetch<UserAdminPayload>;
    /**
     * Connects the Discord user to this Linear account via OAuth2.
     *
     * @param code - required code to pass to userDiscordConnect
     * @param redirectUri - required redirectUri to pass to userDiscordConnect
     * @returns UserPayload
     */
    userDiscordConnect(code: string, redirectUri: string): LinearFetch<UserPayload>;
    /**
     * Disconnects the external user from this Linear account.
     *
     * @param service - required service to pass to userExternalUserDisconnect
     * @returns UserPayload
     */
    userExternalUserDisconnect(service: string): LinearFetch<UserPayload>;
    /**
     * Updates a user's settings flag.
     *
     * @param flag - required flag to pass to updateUserFlag
     * @param operation - required operation to pass to updateUserFlag
     * @returns UserSettingsFlagPayload
     */
    updateUserFlag(flag: L.UserFlagType, operation: L.UserFlagUpdateOperation): LinearFetch<UserSettingsFlagPayload>;
    /**
     * Connects the GitHub user to this Linear account via OAuth2.
     *
     * @param code - required code to pass to userGitHubConnect
     * @returns UserPayload
     */
    userGitHubConnect(code: string): LinearFetch<UserPayload>;
    /**
     * Connects the Google Calendar to the user to this Linear account via OAuth2.
     *
     * @param code - required code to pass to userGoogleCalendarConnect
     * @returns UserPayload
     */
    userGoogleCalendarConnect(code: string): LinearFetch<UserPayload>;
    /**
     * Connects the Jira user to this Linear account via OAuth2.
     *
     * @param code - required code to pass to userJiraConnect
     * @returns UserPayload
     */
    userJiraConnect(code: string): LinearFetch<UserPayload>;
    /**
     * Makes user an admin. Can only be called by an admin.
     *
     * @param id - required id to pass to userPromoteAdmin
     * @returns UserAdminPayload
     */
    userPromoteAdmin(id: string): LinearFetch<UserAdminPayload>;
    /**
     * Makes user a regular user. Can only be called by an admin.
     *
     * @param id - required id to pass to userPromoteMember
     * @returns UserAdminPayload
     */
    userPromoteMember(id: string): LinearFetch<UserAdminPayload>;
    /**
     * [Deprecated] Updates a user's settings flag.
     *
     * @param flag - required flag to pass to userSettingsFlagIncrement
     * @returns UserSettingsFlagPayload
     */
    userSettingsFlagIncrement(flag: string): LinearFetch<UserSettingsFlagPayload>;
    /**
     * Resets user's setting flags.
     *
     * @param variables - variables to pass into the UserSettingsFlagsResetMutation
     * @returns UserSettingsFlagsResetPayload
     */
    userSettingsFlagsReset(variables?: L.UserSettingsFlagsResetMutationVariables): LinearFetch<UserSettingsFlagsResetPayload>;
    /**
     * Updates the user's settings.
     *
     * @param id - required id to pass to updateUserSettings
     * @param input - required input to pass to updateUserSettings
     * @returns UserSettingsPayload
     */
    updateUserSettings(id: string, input: L.UserSettingsUpdateInput): LinearFetch<UserSettingsPayload>;
    /**
     * Suspends a user. Can only be called by an admin.
     *
     * @param id - required id to pass to suspendUser
     * @returns UserAdminPayload
     */
    suspendUser(id: string): LinearFetch<UserAdminPayload>;
    /**
     * Un-suspends a user. Can only be called by an admin.
     *
     * @param id - required id to pass to unsuspendUser
     * @returns UserAdminPayload
     */
    unsuspendUser(id: string): LinearFetch<UserAdminPayload>;
    /**
     * Updates a user. Only available to organization admins and the user themselves.
     *
     * @param id - required id to pass to updateUser
     * @param input - required input to pass to updateUser
     * @returns UserPayload
     */
    updateUser(id: string, input: L.UpdateUserInput): LinearFetch<UserPayload>;
    /**
     * Creates a new ViewPreferences object.
     *
     * @param input - required input to pass to createViewPreferences
     * @returns ViewPreferencesPayload
     */
    createViewPreferences(input: L.ViewPreferencesCreateInput): LinearFetch<ViewPreferencesPayload>;
    /**
     * Deletes a ViewPreferences.
     *
     * @param id - required id to pass to deleteViewPreferences
     * @returns DeletePayload
     */
    deleteViewPreferences(id: string): LinearFetch<DeletePayload>;
    /**
     * Updates an existing ViewPreferences object.
     *
     * @param id - required id to pass to updateViewPreferences
     * @param input - required input to pass to updateViewPreferences
     * @returns ViewPreferencesPayload
     */
    updateViewPreferences(id: string, input: L.ViewPreferencesUpdateInput): LinearFetch<ViewPreferencesPayload>;
    /**
     * Creates a new webhook.
     *
     * @param input - required input to pass to createWebhook
     * @returns WebhookPayload
     */
    createWebhook(input: L.WebhookCreateInput): LinearFetch<WebhookPayload>;
    /**
     * Deletes a Webhook.
     *
     * @param id - required id to pass to deleteWebhook
     * @returns DeletePayload
     */
    deleteWebhook(id: string): LinearFetch<DeletePayload>;
    /**
     * Updates an existing Webhook.
     *
     * @param id - required id to pass to updateWebhook
     * @param input - required input to pass to updateWebhook
     * @returns WebhookPayload
     */
    updateWebhook(id: string, input: L.WebhookUpdateInput): LinearFetch<WebhookPayload>;
    /**
     * Archives a state. Only states with issues that have all been archived can be archived.
     *
     * @param id - required id to pass to archiveWorkflowState
     * @returns WorkflowStateArchivePayload
     */
    archiveWorkflowState(id: string): LinearFetch<WorkflowStateArchivePayload>;
    /**
     * Creates a new state, adding it to the workflow of a team.
     *
     * @param input - required input to pass to createWorkflowState
     * @returns WorkflowStatePayload
     */
    createWorkflowState(input: L.WorkflowStateCreateInput): LinearFetch<WorkflowStatePayload>;
    /**
     * Updates a state.
     *
     * @param id - required id to pass to updateWorkflowState
     * @param input - required input to pass to updateWorkflowState
     * @returns WorkflowStatePayload
     */
    updateWorkflowState(id: string, input: L.WorkflowStateUpdateInput): LinearFetch<WorkflowStatePayload>;
    /**
     * One specific project milestone.
     *
     * @param id - required id to pass to ProjectMilestone
     * @returns ProjectMilestone
     */
    ProjectMilestone(id: string): LinearFetch<ProjectMilestone>;
    /**
     * All milestones for the project.
     *
     * @param variables - variables to pass into the ProjectMilestonesQuery
     * @returns ProjectMilestoneConnection
     */
    ProjectMilestones(variables?: L.ProjectMilestonesQueryVariables): LinearFetch<ProjectMilestoneConnection>;
    /**
     * All teams you the user can administrate. Administrable teams are teams whose settings the user can change, but to whose issues the user doesn't necessarily have access to.
     *
     * @param variables - variables to pass into the AdministrableTeamsQuery
     * @returns TeamConnection
     */
    administrableTeams(variables?: L.AdministrableTeamsQueryVariables): LinearFetch<TeamConnection>;
    /**
     * All API keys for the user.
     *
     * @param variables - variables to pass into the ApiKeysQuery
     * @returns ApiKeyConnection
     */
    apiKeys(variables?: L.ApiKeysQueryVariables): LinearFetch<ApiKeyConnection>;
    /**
     * Get basic information for an application.
     *
     * @param clientId - required clientId to pass to applicationInfo
     * @returns Application
     */
    applicationInfo(clientId: string): LinearFetch<Application>;
    /**
     * Get information for an application and whether a user has approved it for the given scopes.
     *
     * @param clientId - required clientId to pass to applicationWithAuthorization
     * @param scope - required scope to pass to applicationWithAuthorization
     * @param variables - variables without 'clientId', 'scope' to pass into the ApplicationWithAuthorizationQuery
     * @returns UserAuthorizedApplication
     */
    applicationWithAuthorization(clientId: string, scope: string[], variables?: Omit<L.ApplicationWithAuthorizationQueryVariables, "clientId" | "scope">): LinearFetch<UserAuthorizedApplication>;
    /**
     * One specific issue attachment.
     * [Deprecated] 'url' can no longer be used as the 'id' parameter. Use 'attachmentsForUrl' instead
     *
     * @param id - required id to pass to attachment
     * @returns Attachment
     */
    attachment(id: string): LinearFetch<Attachment>;
    /**
     * Query an issue by its associated attachment, and its id.
     *
     * @param id - required id to pass to attachmentIssue
     * @returns Issue
     */
    attachmentIssue(id: string): LinearFetch<Issue>;
    /**
     * All issue attachments.
     *
     * To get attachments for a given URL, use `attachmentsForURL` query.
     *
     * @param variables - variables to pass into the AttachmentsQuery
     * @returns AttachmentConnection
     */
    attachments(variables?: L.AttachmentsQueryVariables): LinearFetch<AttachmentConnection>;
    /**
     * Returns issue attachments for a given `url`.
     *
     * @param url - required url to pass to attachmentsForURL
     * @param variables - variables without 'url' to pass into the AttachmentsForUrlQuery
     * @returns AttachmentConnection
     */
    attachmentsForURL(url: string, variables?: Omit<L.AttachmentsForUrlQueryVariables, "url">): LinearFetch<AttachmentConnection>;
    /**
     * All audit log entries.
     *
     * @param variables - variables to pass into the AuditEntriesQuery
     * @returns AuditEntryConnection
     */
    auditEntries(variables?: L.AuditEntriesQueryVariables): LinearFetch<AuditEntryConnection>;
    /**
     * List of audit entry types.
     *
     * @returns AuditEntryType[]
     */
    get auditEntryTypes(): LinearFetch<AuditEntryType[]>;
    /**
     * Fetch users belonging to this user account.
     *
     * @returns AuthResolverResponse
     */
    get availableUsers(): LinearFetch<AuthResolverResponse>;
    /**
     * A specific comment.
     *
     * @param id - required id to pass to comment
     * @returns Comment
     */
    comment(id: string): LinearFetch<Comment>;
    /**
     * All comments.
     *
     * @param variables - variables to pass into the CommentsQuery
     * @returns CommentConnection
     */
    comments(variables?: L.CommentsQueryVariables): LinearFetch<CommentConnection>;
    /**
     * One specific custom view.
     *
     * @param id - required id to pass to customView
     * @returns CustomView
     */
    customView(id: string): LinearFetch<CustomView>;
    /**
     * Custom views for the user.
     *
     * @param variables - variables to pass into the CustomViewsQuery
     * @returns CustomViewConnection
     */
    customViews(variables?: L.CustomViewsQueryVariables): LinearFetch<CustomViewConnection>;
    /**
     * One specific cycle.
     *
     * @param id - required id to pass to cycle
     * @returns Cycle
     */
    cycle(id: string): LinearFetch<Cycle>;
    /**
     * All cycles.
     *
     * @param variables - variables to pass into the CyclesQuery
     * @returns CycleConnection
     */
    cycles(variables?: L.CyclesQueryVariables): LinearFetch<CycleConnection>;
    /**
     * One specific document.
     *
     * @param id - required id to pass to document
     * @returns Document
     */
    document(id: string): LinearFetch<Document>;
    /**
     * All documents for the project.
     *
     * @param variables - variables to pass into the DocumentsQuery
     * @returns DocumentConnection
     */
    documents(variables?: L.DocumentsQueryVariables): LinearFetch<DocumentConnection>;
    /**
     * Returns embed info for any url
     *
     * @param url - required url to pass to embedInfo
     * @returns EmbedPayload
     */
    embedInfo(url: string): LinearFetch<EmbedPayload>;
    /**
     * A specific emoji.
     *
     * @param id - required id to pass to emoji
     * @returns Emoji
     */
    emoji(id: string): LinearFetch<Emoji>;
    /**
     * All custom emojis.
     *
     * @param variables - variables to pass into the EmojisQuery
     * @returns EmojiConnection
     */
    emojis(variables?: L.EmojisQueryVariables): LinearFetch<EmojiConnection>;
    /**
     * One specific favorite.
     *
     * @param id - required id to pass to favorite
     * @returns Favorite
     */
    favorite(id: string): LinearFetch<Favorite>;
    /**
     * The user's favorites.
     *
     * @param variables - variables to pass into the FavoritesQuery
     * @returns FavoriteConnection
     */
    favorites(variables?: L.FavoritesQueryVariables): LinearFetch<FavoriteConnection>;
    /**
     * Fetch Figma screenshot and other information with file and node identifiers.
     *
     * @param fileId - required fileId to pass to figmaEmbedInfo
     * @param variables - variables without 'fileId' to pass into the FigmaEmbedInfoQuery
     * @returns FigmaEmbedPayload
     */
    figmaEmbedInfo(fileId: string, variables?: Omit<L.FigmaEmbedInfoQueryVariables, "fileId">): LinearFetch<FigmaEmbedPayload>;
    /**
     * One specific integration.
     *
     * @param id - required id to pass to integration
     * @returns Integration
     */
    integration(id: string): LinearFetch<Integration>;
    /**
     * One specific integrationTemplate.
     *
     * @param id - required id to pass to integrationTemplate
     * @returns IntegrationTemplate
     */
    integrationTemplate(id: string): LinearFetch<IntegrationTemplate>;
    /**
     * Template and integration connections.
     *
     * @param variables - variables to pass into the IntegrationTemplatesQuery
     * @returns IntegrationTemplateConnection
     */
    integrationTemplates(variables?: L.IntegrationTemplatesQueryVariables): LinearFetch<IntegrationTemplateConnection>;
    /**
     * All integrations.
     *
     * @param variables - variables to pass into the IntegrationsQuery
     * @returns IntegrationConnection
     */
    integrations(variables?: L.IntegrationsQueryVariables): LinearFetch<IntegrationConnection>;
    /**
     * One specific set of settings.
     *
     * @param id - required id to pass to integrationsSettings
     * @returns IntegrationsSettings
     */
    integrationsSettings(id: string): LinearFetch<IntegrationsSettings>;
    /**
     * One specific issue.
     *
     * @param id - required id to pass to issue
     * @returns Issue
     */
    issue(id: string): LinearFetch<Issue>;
    /**
     * Find issues that are related to a given Figma file key.
     *
     * @param fileKey - required fileKey to pass to issueFigmaFileKeySearch
     * @param variables - variables without 'fileKey' to pass into the IssueFigmaFileKeySearchQuery
     * @returns IssueConnection
     */
    issueFigmaFileKeySearch(fileKey: string, variables?: Omit<L.IssueFigmaFileKeySearchQueryVariables, "fileKey">): LinearFetch<IssueConnection>;
    /**
     * Suggests filters for an issue view based on a text prompt.
     *
     * @param prompt - required prompt to pass to issueFilterSuggestion
     * @returns IssueFilterSuggestionPayload
     */
    issueFilterSuggestion(prompt: string): LinearFetch<IssueFilterSuggestionPayload>;
    /**
     * Checks a CSV file validity against a specific import service.
     *
     * @param csvUrl - required csvUrl to pass to issueImportCheckCSV
     * @param service - required service to pass to issueImportCheckCSV
     * @returns IssueImportCheckPayload
     */
    issueImportCheckCSV(csvUrl: string, service: string): LinearFetch<IssueImportCheckPayload>;
    /**
     * Fetches the GitHub token, completing the OAuth flow.
     *
     * @param code - required code to pass to issueImportFinishGithubOAuth
     * @returns GithubOAuthTokenPayload
     */
    issueImportFinishGithubOAuth(code: string): LinearFetch<GithubOAuthTokenPayload>;
    /**
     * One specific label.
     *
     * @param id - required id to pass to issueLabel
     * @returns IssueLabel
     */
    issueLabel(id: string): LinearFetch<IssueLabel>;
    /**
     * All issue labels.
     *
     * @param variables - variables to pass into the IssueLabelsQuery
     * @returns IssueLabelConnection
     */
    issueLabels(variables?: L.IssueLabelsQueryVariables): LinearFetch<IssueLabelConnection>;
    /**
     * Issue priority values and corresponding labels.
     *
     * @returns IssuePriorityValue[]
     */
    get issuePriorityValues(): LinearFetch<IssuePriorityValue[]>;
    /**
     * One specific issue relation.
     *
     * @param id - required id to pass to issueRelation
     * @returns IssueRelation
     */
    issueRelation(id: string): LinearFetch<IssueRelation>;
    /**
     * All issue relationships.
     *
     * @param variables - variables to pass into the IssueRelationsQuery
     * @returns IssueRelationConnection
     */
    issueRelations(variables?: L.IssueRelationsQueryVariables): LinearFetch<IssueRelationConnection>;
    /**
     * [DEPRECATED] Search issues. This endpoint is deprecated and will be removed in the future  use `searchIssues` instead.
     *
     * @param variables - variables to pass into the IssueSearchQuery
     * @returns IssueConnection
     */
    issueSearch(variables?: L.IssueSearchQueryVariables): LinearFetch<IssueConnection>;
    /**
     * Find issue based on the VCS branch name.
     *
     * @param branchName - required branchName to pass to issueVcsBranchSearch
     * @returns Issue
     */
    issueVcsBranchSearch(branchName: string): LinearFetch<Issue | undefined>;
    /**
     * All issues.
     *
     * @param variables - variables to pass into the IssuesQuery
     * @returns IssueConnection
     */
    issues(variables?: L.IssuesQueryVariables): LinearFetch<IssueConnection>;
    /**
     * One specific notification.
     *
     * @param id - required id to pass to notification
     * @returns Notification
     */
    notification(id: string): LinearFetch<IssueNotification | OauthClientApprovalNotification | ProjectNotification | Notification>;
    /**
     * One specific notification subscription.
     *
     * @param id - required id to pass to notificationSubscription
     * @returns NotificationSubscription
     */
    notificationSubscription(id: string): LinearFetch<CustomViewNotificationSubscription | CycleNotificationSubscription | LabelNotificationSubscription | ProjectNotificationSubscription | TeamNotificationSubscription | UserNotificationSubscription | NotificationSubscription>;
    /**
     * The user's notification subscriptions.
     *
     * @param variables - variables to pass into the NotificationSubscriptionsQuery
     * @returns NotificationSubscriptionConnection
     */
    notificationSubscriptions(variables?: L.NotificationSubscriptionsQueryVariables): LinearFetch<NotificationSubscriptionConnection>;
    /**
     * All notifications.
     *
     * @param variables - variables to pass into the NotificationsQuery
     * @returns NotificationConnection
     */
    notifications(variables?: L.NotificationsQueryVariables): LinearFetch<NotificationConnection>;
    /**
     * The user's organization.
     *
     * @returns Organization
     */
    get organization(): LinearFetch<Organization>;
    /**
     * Does the organization exist.
     *
     * @param urlKey - required urlKey to pass to organizationExists
     * @returns OrganizationExistsPayload
     */
    organizationExists(urlKey: string): LinearFetch<OrganizationExistsPayload>;
    /**
     * One specific organization invite.
     *
     * @param id - required id to pass to organizationInvite
     * @returns OrganizationInvite
     */
    organizationInvite(id: string): LinearFetch<OrganizationInvite>;
    /**
     * All invites for the organization.
     *
     * @param variables - variables to pass into the OrganizationInvitesQuery
     * @returns OrganizationInviteConnection
     */
    organizationInvites(variables?: L.OrganizationInvitesQueryVariables): LinearFetch<OrganizationInviteConnection>;
    /**
     * One specific project.
     *
     * @param id - required id to pass to project
     * @returns Project
     */
    project(id: string): LinearFetch<Project>;
    /**
     * Suggests filters for a project view based on a text prompt.
     *
     * @param prompt - required prompt to pass to projectFilterSuggestion
     * @returns ProjectFilterSuggestionPayload
     */
    projectFilterSuggestion(prompt: string): LinearFetch<ProjectFilterSuggestionPayload>;
    /**
     * One specific project link.
     *
     * @param id - required id to pass to projectLink
     * @returns ProjectLink
     */
    projectLink(id: string): LinearFetch<ProjectLink>;
    /**
     * All links for the project.
     *
     * @param variables - variables to pass into the ProjectLinksQuery
     * @returns ProjectLinkConnection
     */
    projectLinks(variables?: L.ProjectLinksQueryVariables): LinearFetch<ProjectLinkConnection>;
    /**
     * A specific project update.
     *
     * @param id - required id to pass to projectUpdate
     * @returns ProjectUpdate
     */
    projectUpdate(id: string): LinearFetch<ProjectUpdate>;
    /**
     * A specific interaction on a project update.
     *
     * @param id - required id to pass to projectUpdateInteraction
     * @returns ProjectUpdateInteraction
     */
    projectUpdateInteraction(id: string): LinearFetch<ProjectUpdateInteraction>;
    /**
     * All interactions on project updates.
     *
     * @param variables - variables to pass into the ProjectUpdateInteractionsQuery
     * @returns ProjectUpdateInteractionConnection
     */
    projectUpdateInteractions(variables?: L.ProjectUpdateInteractionsQueryVariables): LinearFetch<ProjectUpdateInteractionConnection>;
    /**
     * All project updates.
     *
     * @param variables - variables to pass into the ProjectUpdatesQuery
     * @returns ProjectUpdateConnection
     */
    projectUpdates(variables?: L.ProjectUpdatesQueryVariables): LinearFetch<ProjectUpdateConnection>;
    /**
     * All projects.
     *
     * @param variables - variables to pass into the ProjectsQuery
     * @returns ProjectConnection
     */
    projects(variables?: L.ProjectsQueryVariables): LinearFetch<ProjectConnection>;
    /**
     * Sends a test push message.
     *
     * @returns PushSubscriptionTestPayload
     */
    get pushSubscriptionTest(): LinearFetch<PushSubscriptionTestPayload>;
    /**
     * The status of the rate limiter.
     *
     * @returns RateLimitPayload
     */
    get rateLimitStatus(): LinearFetch<RateLimitPayload>;
    /**
     * One specific roadmap.
     *
     * @param id - required id to pass to roadmap
     * @returns Roadmap
     */
    roadmap(id: string): LinearFetch<Roadmap>;
    /**
     * One specific roadmapToProject.
     *
     * @param id - required id to pass to roadmapToProject
     * @returns RoadmapToProject
     */
    roadmapToProject(id: string): LinearFetch<RoadmapToProject>;
    /**
     * Custom views for the user.
     *
     * @param variables - variables to pass into the RoadmapToProjectsQuery
     * @returns RoadmapToProjectConnection
     */
    roadmapToProjects(variables?: L.RoadmapToProjectsQueryVariables): LinearFetch<RoadmapToProjectConnection>;
    /**
     * All roadmaps in the workspace.
     *
     * @param variables - variables to pass into the RoadmapsQuery
     * @returns RoadmapConnection
     */
    roadmaps(variables?: L.RoadmapsQueryVariables): LinearFetch<RoadmapConnection>;
    /**
     * Search documents.
     *
     * @param term - required term to pass to searchDocuments
     * @param variables - variables without 'term' to pass into the SearchDocumentsQuery
     * @returns DocumentSearchPayload
     */
    searchDocuments(term: string, variables?: Omit<L.SearchDocumentsQueryVariables, "term">): LinearFetch<DocumentSearchPayload>;
    /**
     * Search issues.
     *
     * @param term - required term to pass to searchIssues
     * @param variables - variables without 'term' to pass into the SearchIssuesQuery
     * @returns IssueSearchPayload
     */
    searchIssues(term: string, variables?: Omit<L.SearchIssuesQueryVariables, "term">): LinearFetch<IssueSearchPayload>;
    /**
     * Search projects.
     *
     * @param term - required term to pass to searchProjects
     * @param variables - variables without 'term' to pass into the SearchProjectsQuery
     * @returns ProjectSearchPayload
     */
    searchProjects(term: string, variables?: Omit<L.SearchProjectsQueryVariables, "term">): LinearFetch<ProjectSearchPayload>;
    /**
     * Fetch SSO login URL for the email provided.
     *
     * @param email - required email to pass to ssoUrlFromEmail
     * @param variables - variables without 'email' to pass into the SsoUrlFromEmailQuery
     * @returns SsoUrlFromEmailResponse
     */
    ssoUrlFromEmail(email: string, variables?: Omit<L.SsoUrlFromEmailQueryVariables, "email">): LinearFetch<SsoUrlFromEmailResponse>;
    /**
     * One specific team.
     *
     * @param id - required id to pass to team
     * @returns Team
     */
    team(id: string): LinearFetch<Team>;
    /**
     * One specific team membership.
     *
     * @param id - required id to pass to teamMembership
     * @returns TeamMembership
     */
    teamMembership(id: string): LinearFetch<TeamMembership>;
    /**
     * All team memberships.
     *
     * @param variables - variables to pass into the TeamMembershipsQuery
     * @returns TeamMembershipConnection
     */
    teamMemberships(variables?: L.TeamMembershipsQueryVariables): LinearFetch<TeamMembershipConnection>;
    /**
     * All teams whose issues can be accessed by the user. This might be different from `administrableTeams`, which also includes teams whose settings can be changed by the user.
     *
     * @param variables - variables to pass into the TeamsQuery
     * @returns TeamConnection
     */
    teams(variables?: L.TeamsQueryVariables): LinearFetch<TeamConnection>;
    /**
     * A specific template.
     *
     * @param id - required id to pass to template
     * @returns Template
     */
    template(id: string): LinearFetch<Template>;
    /**
     * All templates from all users.
     *
     * @returns Template[]
     */
    get templates(): LinearFetch<Template[]>;
    /**
     * Returns all templates that are associated with the integration type.
     *
     * @param integrationType - required integrationType to pass to templatesForIntegration
     * @returns Template[]
     */
    templatesForIntegration(integrationType: string): LinearFetch<Template[]>;
    /**
     * One specific user.
     *
     * @param id - required id to pass to user
     * @returns User
     */
    user(id: string): LinearFetch<User>;
    /**
     * The user's settings.
     *
     * @returns UserSettings
     */
    get userSettings(): LinearFetch<UserSettings>;
    /**
     * All users for the organization.
     *
     * @param variables - variables to pass into the UsersQuery
     * @returns UserConnection
     */
    users(variables?: L.UsersQueryVariables): LinearFetch<UserConnection>;
    /**
     * The currently authenticated user.
     *
     * @returns User
     */
    get viewer(): LinearFetch<User>;
    /**
     * A specific webhook.
     *
     * @param id - required id to pass to webhook
     * @returns Webhook
     */
    webhook(id: string): LinearFetch<Webhook>;
    /**
     * All webhooks.
     *
     * @param variables - variables to pass into the WebhooksQuery
     * @returns WebhookConnection
     */
    webhooks(variables?: L.WebhooksQueryVariables): LinearFetch<WebhookConnection>;
    /**
     * One specific state.
     *
     * @param id - required id to pass to workflowState
     * @returns WorkflowState
     */
    workflowState(id: string): LinearFetch<WorkflowState>;
    /**
     * All issue workflow states.
     *
     * @param variables - variables to pass into the WorkflowStatesQuery
     * @returns WorkflowStateConnection
     */
    workflowStates(variables?: L.WorkflowStatesQueryVariables): LinearFetch<WorkflowStateConnection>;
}
//# sourceMappingURL=_generated_sdk.d.ts.map